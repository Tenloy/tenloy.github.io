<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Tenloy">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Tenloy">
    
    <meta name="keywords" content="Tenloy,iOS,Swift">
    
    <meta name="description" content="学习 生活 记录 回忆">
    <meta name="description" content="一、模块化1.1 什么是模块化那么，到底什么是模块化开发呢？  模块：1、在通信、计算机、数据处理控制系统的电路中，可以组合和更换的硬件单元。2、大型软件系统中的一个具有独立功能的部分。   现实生活中模块化的例子：模块化计算机(cpu、内存、显卡、风扇、硬盘、光驱等等模块)、谷歌模块化手机、模块化房屋 代码模块化例子：日期模块、数学计算模块、日志模块等，所有这些模块共同组成了程序软件系统  模块">
<meta property="og:type" content="article">
<meta property="og:title" content="前端各种模块化方案总结">
<meta property="og:url" content="https://tenloy.github.io/2021/06/06/Web-Module.html">
<meta property="og:site_name" content="Tenloy&#39;s Blog">
<meta property="og:description" content="一、模块化1.1 什么是模块化那么，到底什么是模块化开发呢？  模块：1、在通信、计算机、数据处理控制系统的电路中，可以组合和更换的硬件单元。2、大型软件系统中的一个具有独立功能的部分。   现实生活中模块化的例子：模块化计算机(cpu、内存、显卡、风扇、硬盘、光驱等等模块)、谷歌模块化手机、模块化房屋 代码模块化例子：日期模块、数学计算模块、日志模块等，所有这些模块共同组成了程序软件系统  模块">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/moduleref.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/settimeoutmod.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/export1.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/export2.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/moduleexports.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/require1.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/image1.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/multiMoudlesinclude.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/moduleclssource.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/requiremethodsource.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/loadmethodsource.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/modulerunerror.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/liveserver.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/bindingProcedure.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/webmodule/lstwarning.jpg">
<meta property="article:published_time" content="2021-06-06T03:09:27.000Z">
<meta property="article:modified_time" content="2023-03-30T12:10:18.000Z">
<meta property="article:author" content="Tenloy">
<meta property="article:tag" content="Tenloy, iOS, Tenloy Blog, 博客，Swift, 编译, 计算机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tenloy.github.io/images/webmodule/moduleref.jpg">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>前端各种模块化方案总结 · Tenloy&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"Search for Posts","hits_empty":"没有找到任何搜索结果: ${query}","hits_stats":"找到约${hits}条结果（用时${time}ms）"}')

            var algolia = {
                applicationID: 'V0HYXBS9FB',
                apiKey: '6550d5de786935564142097c3e78c380',
                indexName: 'law_blog_index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="Tenloy's Blog" type="application/atom+xml">
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Tenloy&#39;s Blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">前端各种模块化方案总结</a>
            </div>
    </div>
    
    <!-- 将home-link的操作改为应用到header-top-right上 -->
    <div class="header-top-right">
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-search">
                <span class="iconfont-jian tl-search-icon">&#xe7fc;搜索</span>
            </div>
            
        <a class="home-link" href=/>Tenloy's Blog</a>
    </div>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:40vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            前端各种模块化方案总结
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">18.1k</span>Reading time: <span class="post-count reading-time">73 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2021/06/06</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="一、模块化"><a href="#一、模块化" class="headerlink" title="一、模块化"></a>一、模块化</h2><h3 id="1-1-什么是模块化"><a href="#1-1-什么是模块化" class="headerlink" title="1.1 什么是模块化"></a>1.1 什么是模块化</h3><p>那么，到底什么是模块化开发呢？</p>
<blockquote>
<p>模块：1、在通信、计算机、数据处理控制系统的电路中，可以组合和更换的硬件单元。2、大型软件系统中的一个具有独立功能的部分。</p>
</blockquote>
<ul>
<li>现实生活中模块化的例子：模块化计算机(cpu、内存、显卡、风扇、硬盘、光驱等等模块)、谷歌模块化手机、模块化房屋</li>
<li>代码模块化例子：日期模块、数学计算模块、日志模块等，所有这些模块共同组成了程序软件系统</li>
</ul>
<p><strong>模块化：</strong></p>
<ul>
<li>模块化开发就是<strong>将程序划分成一个个(互相依赖的)小文件/模块来开发，然后将小模块组合起来</strong>；</li>
<li>这个模块中编写属于自己的逻辑代码，有自己的作用域，不会影响到其他的结构；</li>
<li>这个模块可以将自己希望暴露的变量、函数、对象等导出给其结构使用；</li>
<li>也可以通过某种方式，导入另外模块中的变量、函数、对象等；</li>
</ul>
<p><strong>模块化的好处：</strong></p>
<ol>
<li>防止命名冲突</li>
<li>代码复用（非模块化开发时，代码重用时，引入 js 文件的数目可能少了或者引入的顺序不对，会导致一些问题）</li>
<li>高维护性（模块之间有高耦合低内聚的特点）</li>
</ol>
<h3 id="1-2-JavaScript设计缺陷"><a href="#1-2-JavaScript设计缺陷" class="headerlink" title="1.2 JavaScript设计缺陷"></a>1.2 JavaScript设计缺陷</h3><p>无论你多么喜欢JavaScript，以及它现在发展的有多好，我们都需要承认在<em>Brendan Eich</em>用了10天写出JavaScript的时候，它都有很多的缺陷：</p>
<ul>
<li>比如var定义的变量作用域问题；</li>
<li>比如JavaScript的面向对象并不能像常规面向对象语言一样使用class；</li>
<li>比如JavaScript没有模块化的问题；</li>
</ul>
<p><em>Brendan Eich</em>本人也多次承认过JavaScript设计之初的缺陷，但是随着JavaScript的发展以及标准化，存在的缺陷问题基本都得到了完善。</p>
<ul>
<li>JavaScript目前已经得到了快速的发展，无论是web、移动端、小程序端、服务器端、桌面应用都被广泛的使用；</li>
</ul>
<p>在网页开发的早期，<em>Brendan Eich</em>开发JavaScript仅仅作为一种脚本语言，做一些简单的表单验证或动画实现等，那个时候代码还是很少的：</p>
<ul>
<li>这个时候我们只需要讲JavaScript代码写到<code>&lt;script&gt;</code>标签中即可；</li>
<li>并没有必要放到多个文件中来编写；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id=<span class="string">&quot;btn&quot;</span>&gt;按钮&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;btn&quot;</span>).<span class="property">onclick</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;按钮被点击了&quot;</span>);</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml">  &#125;</span></span></span><br><span class="line"><span class="language-javascript"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>但是随着前端和JavaScript的快速发展，JavaScript代码变得越来越复杂了：</p>
<ul>
<li>ajax的出现，前后端开发分离，意味着后端返回数据后，我们需要通过JavaScript进行前端页面的渲染；</li>
<li>SPA的出现，前端页面变得更加复杂：包括前端路由、状态管理等等一系列复杂的需求需要通过JavaScript来实现；</li>
<li>包括Node的实现，JavaScript编写复杂的后端程序，没有模块化是致命的硬伤；</li>
</ul>
<p>所以，模块化已经是JavaScript一个非常迫切的需求。</p>
<h3 id="1-3-没有模块化的JavaScript"><a href="#1-3-没有模块化的JavaScript" class="headerlink" title="1.3 没有模块化的JavaScript"></a>1.3 没有模块化的JavaScript</h3><h4 id="1-3-1-技术方案"><a href="#1-3-1-技术方案" class="headerlink" title="1.3.1 技术方案"></a>1.3.1 技术方案</h4><p>演变过程：</p>
<ul>
<li>全局函数<ul>
<li>”污染”了全局变量，无法保证不与其它模块发生变量名冲突</li>
<li>没有模块的划分，只能人为的认为它们属于一个模块，但是程序并不能区分哪些函数是同一个模块</li>
</ul>
</li>
<li>将函数封装到对象命名空间下<ul>
<li>从代码级别可以明显的区分出哪些函数属于同一个模块</li>
<li>从某种程度上解决了变量命名冲突的问题，但是并不能从根本上解决命名冲突</li>
<li>会暴露所有的模块成员，内部状态可以被外部改写，不安全</li>
<li>命名空间越来越长</li>
</ul>
</li>
<li>立即函数调用表达式(<strong>IIFE</strong>，Immediately Invoked Function Expression)<ul>
<li>将模块封装为立即执行函数形式，将公有方法，通过在函数内部返回值的形式向外暴露</li>
<li>会有人强调<strong>职责单一性</strong>，不要与程序的其它部分直接交互。比如当使用到第三方依赖时，通过向匿名函数注入依赖项的形式，来保证模块的独立性，还使模块之间的依赖关系变得明显<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calculator=(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">   <span class="keyword">var</span> add=<span class="keyword">function</span>(<span class="params">v1,v2</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> v1+v2;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123; <span class="attr">add</span>:add &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> calculator=(<span class="keyword">function</span>(<span class="params">cal,$</span>)&#123;</span><br><span class="line">  cal.<span class="property">add2</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">      <span class="keyword">var</span> v1=$(<span class="string">&#x27;#v1&#x27;</span>).<span class="title function_">val</span>();</span><br><span class="line">      <span class="keyword">var</span> v2= $(<span class="string">&#x27;#v2&#x27;</span>).<span class="title function_">val</span>();</span><br><span class="line">     <span class="keyword">return</span> (v1-<span class="number">0</span>)+(v2-<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> cal;</span><br><span class="line">&#125;)(<span class="variable language_">window</span>.<span class="property">calculator</span>||&#123;&#125;,<span class="variable language_">window</span>.<span class="property">$</span>)</span><br><span class="line"><span class="comment">//在这告诉我要jquery</span></span><br><span class="line"><span class="comment">//依赖注入</span></span><br><span class="line"><span class="comment">//很牵强的解决文件依赖问题的方法</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>IIFE也是有很大缺陷的，见下方代码举例</li>
</ul>
<h4 id="1-3-2-问题举例"><a href="#1-3-2-问题举例" class="headerlink" title="1.3.2 问题举例"></a>1.3.2 问题举例</h4><p>我们先来简单体会一下没有模块化代码的问题。</p>
<p>我们知道，对于一个大型的前端项目，通常是多人开发的（即使一个人开发，也会将代码划分到多个文件夹中）：</p>
<ul>
<li>我们假设有两个人：小明和小丽同时在开发一个项目，并且会将自己的JavaScript代码放在一个单独的js文件中。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 小明开发了aaa.js文件，代码如下（当然真实代码会复杂的多）：</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;aaa的flag为true&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 小丽开发了bbb.js文件，代码如下：</span></span><br><span class="line"><span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bbb使用了flag为false&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很明显出现了一个问题：</p>
<ul>
<li>大家都喜欢使用flag来存储一个boolean类型的值；</li>
<li>但是一个人赋值了true，一个人赋值了false；</li>
<li>如果之后都不再使用，那么也没有关系；</li>
</ul>
<p>但是，小明又开发了ccc.js文件：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;使用了aaa的flag&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>问题来了：小明发现ccc中的flag值不对</p>
<ul>
<li>对于聪明的你，当然一眼就看出来，是小丽将flag赋值为了false；</li>
<li>但是如果每个文件都有上千甚至更多的代码，而且有上百个文件，你可以一眼看出来flag在哪个地方被修改了吗？</li>
</ul>
<p>备注：引用路径如下：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./aaa.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./bbb.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./ccc.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>所以，没有模块化对于一个大型项目来说是灾难性的。</p>
<h4 id="1-3-3-IIFE的缺陷"><a href="#1-3-3-IIFE的缺陷" class="headerlink" title="1.3.3 IIFE的缺陷"></a>1.3.3 IIFE的缺陷</h4><p>使用IIFE解决上面的问题：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> moduleA = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;aaa的flag为true&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; <span class="attr">flag</span>: flag &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">const</span> moduleB = (<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;bbb使用了flag为false&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="keyword">const</span> moduleC = (<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> flag = moduleA.<span class="property">flag</span>;</span><br><span class="line">  <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;使用了aaa的flag&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>命名冲突的问题，有没有解决呢？解决了。</p>
<p>但是，我们其实带来了新的问题：</p>
<ul>
<li>第一，我必须记得每一个模块中返回对象的命名，才能在其他模块使用过程中正确的使用；</li>
<li>第二，代码写起来混乱不堪，每个文件中的代码都需要包裹在一个匿名函数中来编写；</li>
<li>第三，在没有合适的规范情况下，每个人、每个公司都可能会任意命名、甚至出现模块名称相同的情况；</li>
</ul>
<p><strong>所以，我们会发现，虽然实现了模块化，但是我们的实现过于简单，并且是没有规范的。</strong></p>
<ul>
<li>我们需要制定一定的规范来约束每个人都按照这个规范去编写模块化的代码；</li>
<li>这个规范中应该包括核心功能：模块本身可以导出暴露的属性，模块又可以导入自己需要的属性；</li>
</ul>
<h3 id="1-4-JavaScript中模块化方案"><a href="#1-4-JavaScript中模块化方案" class="headerlink" title="1.4 JavaScript中模块化方案"></a>1.4 JavaScript中模块化方案</h3><p>历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的<code>require</code>、Python 的<code>import</code>，甚至就连 CSS 都有<code>@import</code>。直到ES6（2015）才推出了自己的模块化方案，在此之前，社区制定了一些模块加载方案，最主要的有：</p>
<p>先有规范，后有实现：</p>
<ul>
<li>服务器端规范 <a target="_blank" rel="noopener" href="http://www.commonjs.org/">CommonJS</a> =&gt; <a target="_blank" rel="noopener" href="https://nodejs.org/">NodeJS</a>、 Browserify</li>
<li>浏览器端规范 <a target="_blank" rel="noopener" href="https://github.com/amdjs/amdjs-api">AMD</a> =&gt; <a target="_blank" rel="noopener" href="http://requirejs.org/">RequireJS</a></li>
<li>浏览器端规范 <a target="_blank" rel="noopener" href="https://github.com/amdjs/amdjs-api">CMD</a> =&gt; <a target="_blank" rel="noopener" href="http://seajs.org/">SeaJS</a></li>
</ul>
<h2 id="二、CommonJS规范"><a href="#二、CommonJS规范" class="headerlink" title="二、CommonJS规范"></a>二、CommonJS规范</h2><h3 id="2-1-CommonJS和Node"><a href="#2-1-CommonJS和Node" class="headerlink" title="2.1 CommonJS和Node"></a>2.1 CommonJS和Node</h3><p>我们需要知道CommonJS是一个规范，最初提出来是在浏览器意外的地方使用，并且当时被命名为<strong>ServerJS</strong>，后来为了体现它的广泛性，修改为<strong>CommonJS</strong>，平时我们也会简称为CJS。</p>
<ul>
<li>Node是CommonJS在服务器端一个具有代表性的实现；</li>
<li>Browserify是CommonJS在浏览器中的一种实现；</li>
<li>webpack打包工具具备对CommonJS的支持和转换（后面会讲到）；</li>
</ul>
<p>所以，Node中对CommonJS进行了支持和实现，让我们在开发node的过程中可以方便的进行模块化开发：</p>
<h3 id="2-2-Node模块化语法"><a href="#2-2-Node模块化语法" class="headerlink" title="2.2 Node模块化语法"></a>2.2 Node模块化语法</h3><h4 id="2-2-1-模块"><a href="#2-2-1-模块" class="headerlink" title="2.2.1 模块"></a>2.2.1 模块</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name</span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name); &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上面的代码会报错：</span></span><br><span class="line"><span class="comment"> - 那么，就意味着别的模块main中不能随便访问另外一个模块bar中的内容；</span></span><br><span class="line"><span class="comment"> - bar需要 导出 自己想要暴露的变量、函数、对象等；main从bar中 导入 自己想要使用的变量、函数、对象等数据之后，才能使用；</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p><strong>在node中每一个文件都是一个独立的模块，有自己的作用域</strong>。在一个模块内变量、函数、对象都属于这个模块，对外是封闭的。</p>
<p>为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module；</p>
<p>每个模块(文件)中都包括CommonJS规范的核心变量：exports、module、require；</p>
<ul>
<li>module：是一个全局对象，代表当前模块。里面保存了模块的信息路径、父子结构信息、曝露出的对象信息。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">id</span>            <span class="comment">// 带有绝对路径的模块文件名</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">filename</span>      <span class="comment">// 模块的文件名，带有绝对路径</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">loaded</span>        <span class="comment">// 表示模块是否已经完成加载</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">parent</span>        <span class="comment">// 返回一个对象，表示调用该模块的模块。</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">children</span>      <span class="comment">// 返回一个数组，表示该模块要用到的其他模块。</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span>	     <span class="comment">// 模块对外输出的值。需要打破模块封装性曝露的方法和属性，都要挂载到module.exports上。其它文件加载该模块,实际上就是读取module.exports属性</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 /Users/computer/Desktop/ccc/lib.js 文件中 console.log(module);</span></span><br><span class="line"><span class="title class_">Module</span> &#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;.&#x27;</span>,</span><br><span class="line">  <span class="attr">path</span>: <span class="string">&#x27;/Users/computer/Desktop/ccc&#x27;</span>,</span><br><span class="line">  <span class="attr">exports</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;test&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">parent</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&#x27;/Users/computer/Desktop/ccc/main.js&#x27;</span>,</span><br><span class="line">  <span class="attr">loaded</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">children</span>: [</span><br><span class="line">    <span class="title class_">Module</span> &#123;...&#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">paths</span>: [ <span class="comment">//查找路径</span></span><br><span class="line">    <span class="string">&#x27;/Users/computer/Desktop/ccc/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/computer/Desktop/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/computer/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/Users/node_modules&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;/node_modules&#x27;</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>exports是module.exports的引用。一起负责对模块中的内容进行导出；</li>
<li>require函数可以帮助我们导入其他模块（自定义模块、系统模块、第三方库模块）中的内容；</li>
</ul>
<p>在Node.js中，模块分为两类：</p>
<ul>
<li>第一类，系统核心模块(原生模块)，node自带。用名称直接可以加载。<ul>
<li>fs(file system)：与文件系统交互</li>
<li>http：提供http服务器功能</li>
<li>os：提供了与操作系统相关的实用方法和属性</li>
<li>path：处理文件路径</li>
<li>querystring：解析url查询字符串</li>
<li>url：解析url</li>
<li>util：提供一系列实用小工具</li>
<li>Buffer </li>
<li>等等很多，见<a target="_blank" rel="noopener" href="http://api.nodejs.cn/">官方文档</a></li>
<li><strong>核心模块的源码都在Node的lib子目录中。为了提高运行速度，它们安装的时候都会被编译成二进制文件</strong></li>
</ul>
</li>
<li>第二类，文件模块，也称自定义模块。用路径加载。</li>
</ul>
<p>有一种特殊的文件模块 — 包，被管理在<code>node_modules</code>文件夹中的包，也可以直接用名字加载。</p>
<h4 id="2-2-2-exports导出"><a href="#2-2-2-exports导出" class="headerlink" title="2.2.2 exports导出"></a>2.2.2 exports导出</h4><p><strong>强调：exports是一个对象，我们可以在这个对象中添加很多个属性，添加的属性会导出</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js 导出内容</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">name</span> = name;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">age</span> = age;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">sayHello</span> = sayHello;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js 导入内容</span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>上面这行代码意味着什么呢？</p>
<ul>
<li>意味着main中的bar变量等于exports对象；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">main中的bar = bar中的<span class="built_in">exports</span></span><br></pre></td></tr></table></figure>

<p>所以，我可以编写下面的代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> name = bar.<span class="property">name</span>;</span><br><span class="line"><span class="keyword">const</span> age = bar.<span class="property">age</span>;</span><br><span class="line"><span class="keyword">const</span> sayHello = bar.<span class="property">sayHello</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line"></span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&#x27;kobe&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>模块之间的引用关系：</p>
<img src="/images/webmodule/moduleref.jpg" alt="图片" style="zoom:70%;" />

<p>为了进一步论证，bar和exports是同一个对象：</p>
<ul>
<li>所以，bar对象是exports对象的浅拷贝；</li>
<li>浅拷贝的本质就是一种引用的赋值而已；</li>
</ul>
<p>定时器修改对象：</p>
<img src="/images/webmodule/settimeoutmod.jpg" alt="图片" style="zoom:80%;" />

<h4 id="2-2-3-module-exports"><a href="#2-2-3-module-exports" class="headerlink" title="2.2.3 module.exports"></a>2.2.3 module.exports</h4><p>但是Node中我们经常导出东西的时候，又是通过module.exports导出的：</p>
<ul>
<li>module.exports和exports有什么关系或者区别呢？</li>
</ul>
<p>我们追根溯源，通过维基百科中对CommonJS规范的解析：</p>
<ul>
<li>CommonJS中是没有module.exports的概念的；</li>
<li>但是为了实现模块的导出，Node中使用的是Module的类(提供了一个Module构造函数)，每一个模块都是Module的一个实例，也就是module；</li>
<li><strong>module才是导出的真正实现者；</strong></li>
<li>所以在Node中<strong>真正用于导出的其实根本不是exports，而是module.exports</strong>。只是为了实现CommonJS的规范，也为了使用方便，Node为每个模块提供了一个exports对象，让其对module.exports有一个引用而已。</li>
<li>相当于在每个模块头部，有这样一行命令：<code>var exports = module.exports;</code></li>
</ul>
<img src="/images/webmodule/export1.jpg" alt="图片" style="zoom:67%;" />

<p><strong>不能直接给exports、module.exports赋值，这样等于切断了exports和module.exports的联系。最终输出的结果只会是module.exports的值</strong>。比如代码这样修改了：</p>
<img src="/images/webmodule/export2.jpg" alt="图片" style="zoom:67%;" />

<img src="/images/webmodule/moduleexports.jpg" alt="moduleexports" style="zoom:68%;" />

<h4 id="2-2-4-require"><a href="#2-2-4-require" class="headerlink" title="2.2.4 require"></a>2.2.4 require</h4><h5 id="1-require的加载原理"><a href="#1-require的加载原理" class="headerlink" title="1. require的加载原理"></a>1. require的加载原理</h5><p>前面已经说过，CommonJS 的一个模块，就是一个脚本文件。</p>
<ul>
<li><p>CommonJS是同步加载。模块加载的顺序，按照其在代码中出现的顺序</p>
</li>
<li><p><code>require</code>命令第一次加载模块时，会执行整个模块(脚本文件)中的js代码，返回该模块的module.exports接口数据。会在内存生成一个该模块对应的module对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello aaa&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>); <span class="comment">// aaa.js中的代码在引入时会被运行一次</span></span><br></pre></td></tr></table></figure>

<p>生成的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;...&#x27;</span>,  <span class="comment">// 模块名</span></span><br><span class="line">  <span class="attr">exports</span>: &#123; ... &#125;,  <span class="comment">// 模块输出的各个接口</span></span><br><span class="line">  <span class="attr">loaded</span>: <span class="literal">true</span>,   <span class="comment">// 是一个布尔值，为false表示还没有加载，为true表示已经加载完毕。这是保证每个模块只加载、运行一次的关键。</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>以后需要用到这个模块的时候，就会到<code>exports</code>属性上面取值。</p>
</li>
<li><p>模块被多次引入时（多次执行<code>require</code>命令），CommonJS 模块<strong>只会在第一次加载时运行一次</strong>，以后再加载，会去缓存中取出第一次加载时生成的module对象并返回module.exports。除非手动清除系统缓存。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">const</span> aaa = <span class="built_in">require</span>(<span class="string">&#x27;./aaa&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> bbb = <span class="built_in">require</span>(<span class="string">&#x27;./bbb&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// aaa.js</span></span><br><span class="line"><span class="keyword">const</span> ccc = <span class="built_in">require</span>(<span class="string">&quot;./ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bbb.js</span></span><br><span class="line"><span class="keyword">const</span> ccc = <span class="built_in">require</span>(<span class="string">&quot;./ccc&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ccc.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;ccc被加载&#x27;</span>);  <span class="comment">// ccc中的代码只会运行一次。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h5 id="2-require的查找规则"><a href="#2-require的查找规则" class="headerlink" title="2. require的查找规则"></a>2. require的查找规则</h5><p>我们现在已经知道，require是一个函数，可以帮助我们引入一个文件（模块）中导出的对象。</p>
<p>那么，require的查找规则是怎么样的呢？<a target="_blank" rel="noopener" href="https://nodejs.org/dist/latest-v14.x/docs/api/modules.html#modules_all_together">官方文档</a></p>
<p><strong>这里我总结比较常见的查找规则：</strong>导入格式如下：require(X)</p>
<ul>
<li>情况一：X是一个核心模块，比如path、http。直接返回核心模块，并且停止查找<ul>
<li>加载核心模块。传入名字，不需要传入路径。因为Node.js已经将核心模块的文件代码编译到了二进制的可执行文件中了。在加载的过程中，原生的核心模块的优先级是是最高的。</li>
</ul>
</li>
<li>情况二：X是以<code>./</code>或<code>../</code>或<code>/</code>(根目录)开头的<ul>
<li>在Linux或者MAc的操作系统中，/表示系统的根路径。在Windows中，/表示当前文件模块所属的根磁盘路径</li>
<li>第一步：将X当做一个文件在对应的目录下查找；<ul>
<li>如果有后缀名，按照后缀名的格式查找对应的文件</li>
<li>如果没有后缀名，会按照如下顺序：<ol>
<li>直接查找文件X</li>
<li>查找X.js文件：当做JavaScript脚本文件解析</li>
<li>查找X.json文件：以JSON格式解析。<ul>
<li>如果是加载json文件模块，最好加上后缀.json，能稍微的提高一点加载的速度。</li>
<li>json文件Node.js也是通过fs读文件的形式读取出来的，然后通过JSON.parse()转换成一个对象</li>
</ul>
</li>
<li>查找X.node文件：以编译后的二进制文件解析。.node文件通常是c/c++写的一些扩展模块</li>
</ol>
</li>
</ul>
</li>
<li>第二步：没有找到对应的文件，将X作为一个目录。查找目录下面的index文件<ol>
<li>查找X/index.js文件</li>
<li>查找X/index.json文件</li>
<li>查找X/index.node文件</li>
</ol>
</li>
<li>如果没有找到，那么报错：<code>not found</code></li>
</ul>
</li>
<li>情况三：直接是一个X（没有路径），并且X不是一个核心模块<ul>
<li> 比如在<code>/Users/coderwhy/Desktop/Node/TestCode/04_learn_node/05_javascript-module/02_commonjs/main.js</code>中编写 <code>require(&#39;why&#39;)</code></li>
<li>查找顺序：从当前 package 的 node_modules 里面找，找不到就到当前 package 目录上层 node_modules 里面取… 一直找到全局 node_modules 目录。<img src="/images/webmodule/require1.jpg" alt="图片" style="zoom:70%;" /></li>
<li>这样找到的往往是文件夹，所以接下来就是处理一个文件目录作为 Node 模块的情况。如果文件目录下有 package.json，就根据它的 main 字段找到 js 文件。如果没有 package.json，那就<strong>默认取文件夹下的 index.js</strong>。<ul>
<li>由于 webpack browsersify 等模块打包工具是兼容 node 的模块系统的，自然也会进行同样的处理流程。不同的是，它们支持更灵活的配置。比如在 webpack 里面，可以通过 alias 和 external 字段配置，实现对默认 import 逻辑的自定义。</li>
</ul>
</li>
<li>如果上面的路径中都没有找到，那么报错：<code>not found</code></li>
</ul>
</li>
</ul>
<p>流程图：</p>
<img src="/images/webmodule/image1.jpg" alt="Alt text" style="zoom:80%;" />

<ul>
<li>Node.js会通过同步阻塞的方式看这个路径是否存在。依次尝试，直到找到为止，如果找不到，报错</li>
<li>优先从缓存加载：common.js规范：载后，再次加载时，去缓存中取module.exports <a target="_blank" rel="noopener" href="http://www.infoq.com/cn/articles/nodejs-module-mechanism/">参考文献</a></li>
</ul>
<h5 id="3-require的加载顺序"><a href="#3-require的加载顺序" class="headerlink" title="3. require的加载顺序"></a>3. require的加载顺序</h5><p><strong>如果有多个模块的引入，那么加载顺序是什么？</strong></p>
<p>如果出现下面模块的引用关系，那么加载顺序是什么呢？</p>
<ul>
<li>这个其实是一种数据结构：图结构；</li>
<li>图结构在遍历的过程中，有深度优先搜索（DFS, depth first search）和广度优先搜索（BFS, breadth first search）；</li>
<li>Node采用的是深度优先算法：main -&gt; aaa -&gt; ccc -&gt; ddd -&gt; eee -&gt;bbb</li>
</ul>
<p>多个模块的引入关系：</p>
<img src="/images/webmodule/multiMoudlesinclude.jpg" alt="multiMoudlesinclude" style="zoom:80%;" />



<h3 id="2-3-Node的源码解析"><a href="#2-3-Node的源码解析" class="headerlink" title="2.3 Node的源码解析"></a>2.3 Node的源码解析</h3><p>Module类</p>
<img src="/images/webmodule/moduleclssource.jpg" alt="图片" style="zoom:80%;" />

<p>Module.prototype.require函数</p>
<img src="/images/webmodule/requiremethodsource.jpg" alt="图片" style="zoom:80%;" />

<p>Module._load函数</p>
<img src="/images/webmodule/loadmethodsource.jpg" alt="图片" style="zoom:80%;" />

<h2 id="三、ES6-Module"><a href="#三、ES6-Module" class="headerlink" title="三、ES6 Module"></a>三、ES6 Module</h2><h3 id="3-1-认识ES6-Module"><a href="#3-1-认识ES6-Module" class="headerlink" title="3.1 认识ES6 Module"></a>3.1 认识ES6 Module</h3><h4 id="3-1-1-ES6-Module的优势"><a href="#3-1-1-ES6-Module的优势" class="headerlink" title="3.1.1 ES6 Module的优势"></a>3.1.1 ES6 Module的优势</h4><p>ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西，导致完全没办法在编译时做“静态优化”。</p>
<p>由于 ES6 模块是编译时加载：</p>
<ul>
<li>可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高；</li>
<li>使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。</li>
</ul>
<p>除了静态加载带来的各种好处，ES6 模块还有以下好处。</p>
<ul>
<li>不再需要<code>UMD</code>模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。</li>
<li>将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者<code>navigator</code>对象的属性。</li>
<li>不再需要对象作为命名空间（比如<code>Math</code>对象），未来这些功能可以通过模块提供。</li>
</ul>
<h4 id="3-1-2-自动启动严格模式"><a href="#3-1-2-自动启动严格模式" class="headerlink" title="3.1.2 自动启动严格模式"></a>3.1.2 自动启动严格模式</h4><p>ES6 的模块自动采用严格模式，不管你有没有在模块头部加上<code>&quot;use strict&quot;;</code>。</p>
<ul>
<li>其中，尤其需要注意<code>this</code>的限制。<font color=red>ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>，即不应该在顶层代码使用<code>this</code></font>。</li>
<li>参考链接：<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式—MDN</a></li>
<li><a href="https://tenloy.github.io/pnote/web_note/05-JS%E9%AB%98%E7%BA%A7/Sources/3.6_ES5%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F.html">严格模式—阮一峰</a></li>
</ul>
</li>
</ul>
<h4 id="3-1-3-浏览器中加载ES6-Module"><a href="#3-1-3-浏览器中加载ES6-Module" class="headerlink" title="3.1.3 浏览器中加载ES6 Module"></a>3.1.3 浏览器中加载ES6 Module</h4><h5 id="1-加载普通js文件"><a href="#1-加载普通js文件" class="headerlink" title="1. 加载普通js文件"></a>1. 加载普通js文件</h5><p>HTML 网页中，浏览器通过<code>&lt;script&gt;</code>标签加载 JavaScript 脚本。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 页面内嵌的脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span>&gt;</span><span class="language-javascript"> <span class="comment">// code </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 外部脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;application/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span>&gt;</span><span class="language-javascript"> <span class="comment">//code... </span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，由于浏览器脚本的默认语言是 JavaScript，因此<code>type=&quot;application/javascript&quot;</code>可以省略。</p>
<p>默认情况下，浏览器是同步加载 JavaScript 脚本，即渲染引擎遇到<code>&lt;script&gt;</code>标签就会停下来，等到执行完脚本，再继续向下渲染。如果是外部脚本，还必须加入脚本下载的时间。</p>
<p>如果脚本体积很大，下载和执行的时间就会很长，因此造成浏览器堵塞，用户会感觉到浏览器“卡死”了，没有任何响应。这显然是很不好的体验，所以浏览器允许脚本异步加载。</p>
<p>下面就是两种异步加载的语法。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;path/to/myModule.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>&lt;script&gt;</code>标签打开<code>defer</code>或<code>async</code>属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。</p>
<p><code>defer</code>与<code>async</code>的区别是：</p>
<ul>
<li><code>defer</code>要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；</li>
<li><code>async</code>一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。</li>
<li>一句话，<code>defer</code>是“渲染完再执行”，<code>async</code>是“下载完就执行”。</li>
<li>另外，如果有多个<code>defer</code>脚本，会按照它们在页面出现的顺序加载，而多个<code>async</code>脚本是不能保证加载顺序的。</li>
</ul>
<h5 id="2-加载ES6-Module"><a href="#2-加载ES6-Module" class="headerlink" title="2. 加载ES6 Module"></a>2. 加载ES6 Module</h5><p>浏览器内嵌、外链 ES6 模块代码，也使用<code>&lt;script&gt;</code>标签，但是都要加入<code>type=&quot;module&quot;</code>属性。</p>
<p><code>type</code>属性设为<code>module</code>，所以浏览器知道这是一个 ES6 模块。浏览器对于带有<code>type=&quot;module&quot;</code>的<code>&lt;script&gt;</code>，都是异步加载，不会造成堵塞浏览器，即等到整个页面渲染完，再执行模块脚本，等同于打开了<code>&lt;script&gt;</code>标签的<code>defer</code>属性。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 等同于下面代码。如果网页有多个 &lt;script type=&quot;module&quot;&gt;，它们会按照在页面出现的顺序依次执行。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">defer</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">&lt;script&gt;标签的async属性也可以打开：</span></span><br><span class="line"><span class="comment">	这时只要加载完成，渲染引擎就会中断渲染立即执行。执行完成后，再恢复渲染。 </span></span><br><span class="line"><span class="comment">	同样的：一旦使用了此属性，&lt;script type=&quot;module&quot;&gt;就不会按照在页面出现的顺序执行，而是只要该模块加载完成，就执行该模块。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./foo.js&quot;</span> <span class="attr">async</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ES6 模块也允许内嵌在网页中，语法行为与加载外部脚本完全一致。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&quot;./utils.js&quot;</span>;</span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="comment">// other code</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>对于外部的模块脚本（上例是<code>foo.js</code>），有几点需要注意。</p>
<ul>
<li>代码是在模块作用域之中运行，而不是在全局作用域运行。模块内部的顶层变量，外部不可见。</li>
<li>模块脚本自动采用严格模式，不管有没有声明<code>use strict</code>。</li>
<li>模块之中，可以使用<code>import</code>命令加载其他模块（<code>.js</code>后缀不可省略，需要提供绝对 URL 或相对 URL），也可以使用<code>export</code>命令输出对外接口。</li>
<li>模块之中，顶层的<code>this</code>关键字返回<code>undefined</code>，而不是指向<code>window</code>。也就是说，在模块顶层使用<code>this</code>关键字，是无意义的。</li>
<li>同一个模块如果加载多次，将只执行一次。</li>
</ul>
<p>下面是一个示例模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> utils <span class="keyword">from</span> <span class="string">&#x27;https://example.com/js/utils.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x === <span class="variable language_">window</span>.<span class="property">x</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>利用顶层的<code>this</code>等于<code>undefined</code>这个语法点，可以侦测当前代码是否在 ES6 模块之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isNotModuleScript = <span class="variable language_">this</span> !== <span class="literal">undefined</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-1-4-本地浏览的报错"><a href="#3-1-4-本地浏览的报错" class="headerlink" title="3.1.4 本地浏览的报错"></a>3.1.4 本地浏览的报错</h4><p>代码结构如下（个人习惯）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── main.js</span><br><span class="line">└── modules</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure>

<p>index.html中引入两个js文件作为模块：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./modules/foo.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果直接在浏览器中运行代码，会报如下错误：</p>
<img src="/images/webmodule/modulerunerror.jpg" alt="图片" style="zoom:80%;" />

<p>这个在MDN上面有给出解释：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules</a></li>
<li>你需要注意本地测试 — 如果你通过本地加载Html 文件 (比如一个 <code>file://</code> 路径的文件), 你将会遇到 CORS 错误，因为Javascript 模块安全性需要。</li>
<li>你需要通过一个服务器来测试。</li>
</ul>
<p>我这里使用的VSCode，VSCode中有一个插件：Live Server</p>
<ul>
<li>通过插件运行，可以将我们的代码运行在一个本地服务中；</li>
</ul>
<img src="/images/webmodule/liveserver.jpg" alt="图片" style="zoom:80%;" />

<h3 id="3-2-ES6-Module的语法"><a href="#3-2-ES6-Module的语法" class="headerlink" title="3.2 ES6 Module的语法"></a>3.2 ES6 Module的语法</h3><p>模块功能主要由两个命令构成：<code>export</code>和<code>import</code>：</p>
<ul>
<li><code>export</code>命令用于规定模块的对外接口</li>
<li><code>import</code>命令用于输入其他模块提供的功能。</li>
</ul>
<h4 id="3-2-1-模块与CommonJS模块的区别"><a href="#3-2-1-模块与CommonJS模块的区别" class="headerlink" title="3.2.1 模块与CommonJS模块的区别"></a>3.2.1 模块与CommonJS模块的区别</h4><h5 id="1-相同点"><a href="#1-相同点" class="headerlink" title="1. 相同点"></a>1. 相同点</h5><p>与CommonJS的相同点：一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用<code>export</code>关键字输出该变量。</p>
<h5 id="2-导出的不同"><a href="#2-导出的不同" class="headerlink" title="2. 导出的不同"></a>2. 导出的不同</h5><p><strong>CommonJS通过module.exports导出的是一个对象，是<code>module.exports</code>属性浅拷贝后导出：</strong></p>
<ul>
<li>该对象只有在脚本运行完才会生成。</li>
<li>导出的是一个对象意味着可以将这个对象的引用在导入模块中赋值给其他变量；但是最终他们指向的都是同一个对象，那么一个变量修改了对象的属性，所有的地方都会被修改；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">count</span>: <span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">    counter++;</span><br><span class="line">    obj.<span class="property">count</span>++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter,</span><br><span class="line">  <span class="attr">obj</span>: obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入</span></span><br><span class="line"><span class="keyword">var</span> mod = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mod.<span class="property">counter</span>, mod.<span class="property">obj</span>.<span class="property">count</span>); <span class="comment">// 3  3</span></span><br><span class="line">mod.<span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(mod.<span class="property">counter</span>, mod.<span class="property">obj</span>.<span class="property">count</span>); <span class="comment">// 3  4</span></span><br></pre></td></tr></table></figure>

<p><strong>ES Module通过export导出的不是对象，是一个个导出变量/函数/类本身的引用：</strong></p>
<p>说法1：</p>
<ul>
<li>它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。JS 引擎对脚本静态分析的时候，遇到模块加载命令<code>import</code>，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。</li>
<li>换句话说，ES6 的<code>import</code>有点像 Unix 系统的“符号连接”，原始值变了，<code>import</code>加载的值也会跟着变。(由于 ES6 输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错)</li>
<li>所以，<code>import</code>命令叫做“连接” binding 其实更合适。</li>
</ul>
<p>说法2：</p>
<ul>
<li>export在导出一个变量时，js引擎会解析这个语法，并且创建<strong>模块环境记录</strong>（module environment record）；</li>
<li><strong>模块环境记录</strong>会和变量进行 <code>绑定</code>（binding），并且这个绑定是实时的；</li>
<li>而在导入的地方，我们是可以实时的获取到绑定的最新值的；</li>
</ul>
<p><strong>export和import绑定的过程：</strong></p>
<img src="/images/webmodule/bindingProcedure.jpg" alt="图片" style="zoom:70%;" />

<p>还是举上面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> counter = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">incCounter</span>(<span class="params"></span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; counter, incCounter &#125; <span class="keyword">from</span> <span class="string">&#x27;./lib&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 3</span></span><br><span class="line"><span class="title function_">incCounter</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(counter); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p>上面代码说明，ES6 模块输入的变量<code>counter</code>是活的，完全反应其所在模块<code>lib.js</code>内部的变化。</p>
<h5 id="3-导入的不同"><a href="#3-导入的不同" class="headerlink" title="3. 导入的不同"></a>3. 导入的不同</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS模块</span></span><br><span class="line"><span class="keyword">let</span> &#123; stat, exists, readfile &#125; = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> _fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> stat = _fs.<span class="property">stat</span>;</span><br><span class="line"><span class="keyword">let</span> exists = _fs.<span class="property">exists</span>;</span><br><span class="line"><span class="keyword">let</span> readfile = _fs.<span class="property">readfile</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码实质会整体加载<code>fs</code>模块（即加载<code>fs</code>的所有方法），生成一个对象（<code>_fs</code>），然后再从这个对象上面读取 3 个方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; stat, exists, readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码实质只是从<code>fs</code>模块加载 3 个方法，其他方法不加载。</p>
<h4 id="3-2-2-export"><a href="#3-2-2-export" class="headerlink" title="3.2.2 export"></a>3.2.2 export</h4><p>export关键字将一个模块中的变量、函数、类等导出；</p>
<h5 id="1-export-lt-decl-gt"><a href="#1-export-lt-decl-gt" class="headerlink" title="1. export &lt;decl&gt;"></a>1. <code>export &lt;decl&gt;</code></h5><p>方式一：分别导出。在<strong>语句声明</strong>的前面直接加上export关键字：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> message = <span class="string">&quot;my name is why&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// export需要指定对外暴露的接口，所以不能直接输出一个值</span></span><br><span class="line"><span class="comment">// export 40; //error</span></span><br></pre></td></tr></table></figure>

<h5 id="2-export"><a href="#2-export" class="headerlink" title="2. export {}"></a>2. <code>export &#123;&#125;</code></h5><p>方式二：统一导出。将所有需要导出的标识符，放到export后面的 <code>&#123;&#125;</code>中。它与上一种写法是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些数据。</p>
<ul>
<li>注意：这里的 <code>&#123;&#125;</code>里面不是ES6的对象字面量的增强写法，<code>&#123;&#125;</code>也不是表示一个对象的；</li>
<li>所以：<code>export &#123;name: name&#125;</code>，是错误的写法；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;coderwhy&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHello</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name,</span><br><span class="line">  age,</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-export-lt-gt-as-lt-gt"><a href="#3-export-lt-gt-as-lt-gt" class="headerlink" title="3. export {&lt;&gt; as &lt;&gt;}"></a>3. <code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code></h5><p>方式三：通常情况下，<code>export</code>输出的变量就是本来的名字，但是可以使用<code>as</code>关键字在导出时给<code>标识符</code>起一个别名：<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">  name <span class="keyword">as</span> fName,</span><br><span class="line">  age <span class="keyword">as</span> fAge,</span><br><span class="line">  sayHello <span class="keyword">as</span> fSayHello1,</span><br><span class="line">  sayHello <span class="keyword">as</span> fSayHello2, <span class="comment">// 重命名后，sayHello可以用不同的名字输出两次。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-export导出的是标识符的地址"><a href="#4-export导出的是标识符的地址" class="headerlink" title="4. export导出的是标识符的地址"></a>4. export导出的是标识符的地址</h5><p><code>export</code>语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&#x27;bar&#x27;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> foo = <span class="string">&#x27;baz&#x27;</span>, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>

<p>上面代码输出变量<code>foo</code>，值为<code>bar</code>，500 毫秒之后变成<code>baz</code>。</p>
<p>这一点与 CommonJS 规范完全不同。CommonJS 模块输出的是值的缓存，不存在动态更新。</p>
<h5 id="5-export导出同一个实例"><a href="#5-export导出同一个实例" class="headerlink" title="5. export导出同一个实例"></a>5. export导出同一个实例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">C</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sum</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> c = <span class="keyword">new</span> <span class="title function_">C</span>();</span><br></pre></td></tr></table></figure>

<p>不同的模块中，加载这个模块，得到的都是同一个实例。对c修改，其他模块导入的数据也会改变</p>
<h5 id="6-export书写位置"><a href="#6-export书写位置" class="headerlink" title="6. export书写位置"></a>6. export书写位置</h5><p><code>export</code>命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，<code>import</code>命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">default</span> <span class="string">&#x27;bar&#x27;</span> <span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>()</span><br></pre></td></tr></table></figure>

<h5 id="7-export书写次数"><a href="#7-export书写次数" class="headerlink" title="7. export书写次数"></a>7. export书写次数</h5><p>一个模块中：<code>export &lt;decl&gt;</code>、<code>export &#123;&#125;</code>、<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code>都是可以出现<code>0-n</code>次的</p>
<h4 id="3-2-3-import"><a href="#3-2-3-import" class="headerlink" title="3.2.3 import"></a>3.2.3 import</h4><p>import关键字负责从另外一个模块中导入内容。</p>
<p><strong><code>import</code>语句会执行所加载的模块。如果同一个模块被加载多次，那么模块里的代码只执行一次。</strong></p>
<p><strong>导入内容的方式也有多种：</strong></p>
<h5 id="1-import-from-39-39"><a href="#1-import-from-39-39" class="headerlink" title="1. import {} from &#39;&#39;"></a>1. <code>import &#123;&#125; from &#39;&#39;</code></h5><p>方式一：选择导入。<code>import &#123;标识符列表&#125; from &#39;模块&#39;</code>；</p>
<p>注意：</p>
<ul>
<li>大括号里面的变量名，必须与被导入模块对外接口的名称相同。</li>
<li>这里的<code>&#123;&#125;</code>也不是一个对象，里面只是存放导入的标识符列表内容；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, age, sayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age);</span><br><span class="line"><span class="title function_">sayHello</span>(<span class="string">&quot;Kobe&quot;</span>);</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，虽然<code>name</code>和<code>age</code>在两个语句中加载，但是它们对应的是同一个<code>foo.js</code>模块。也就是说，<code>import</code>语句是 Singleton 模式。</p>
<h5 id="1-import-39-39-的含义"><a href="#1-import-39-39-的含义" class="headerlink" title="1. import &#39;&#39;的含义"></a>1. <code>import &#39;&#39;</code>的含义</h5><p><code>import</code>语句会执行所加载的模块，因此可以有下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>; </span><br></pre></td></tr></table></figure>

<p>上面代码仅仅执行<code>lodash</code>模块，但是不导入任何值。</p>
<p>同样的，如果多次重复执行同一句<code>import</code>语句，那么只会执行一次，而不会执行多次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;lodash&#x27;</span>; <span class="comment">// 代码加载了两次`lodash`，但是只会执行一次。</span></span><br></pre></td></tr></table></figure>

<h5 id="2-import-lt-gt-as-lt-gt-from-39-39"><a href="#2-import-lt-gt-as-lt-gt-from-39-39" class="headerlink" title="2.  import {&lt;&gt; as &lt;&gt;} from &#39;&#39;"></a>2.  <code>import &#123;&lt;&gt; as &lt;&gt;&#125; from &#39;&#39;</code></h5><p>方式二：导入时给标识符起别名： <code>import &#123;&lt;&gt; as &lt;&gt;&#125; from &#39;&#39;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> wName, age <span class="keyword">as</span> wAge, sayHello <span class="keyword">as</span> wSayHello &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="3-import-as-lt-gt-from-39-39"><a href="#3-import-as-lt-gt-from-39-39" class="headerlink" title="3.  import * as &lt;&gt; from &#39;&#39;"></a>3.  <code>import * as &lt;&gt; from &#39;&#39;</code></h5><p>方式三：整体导入。将模块功能放到一个模块功能对象(a module object)上，用<code>*</code>指定： <code>import * as &lt;&gt; from &#39;&#39;</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">name</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">age</span>);</span><br><span class="line">foo.<span class="title function_">sayHello</span>(<span class="string">&quot;Kobe&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.n = &quot;add&quot;; // Type Error: object is not extensible</span></span><br><span class="line"><span class="comment">// foo.f = function () &#123;&#125;; </span></span><br></pre></td></tr></table></figure>

<p>注意，模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变。上面的写法是不允许的。</p>
<h5 id="4-import导入为只读"><a href="#4-import导入为只读" class="headerlink" title="4. import导入为只读"></a>4. import导入为只读</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line">name = <span class="string">&quot;mod&quot;</span>; <span class="comment">// Syntax Error : &#x27;name&#x27; is read-only;</span></span><br></pre></td></tr></table></figure>

<p><code>name</code>是只读的。但是，如果<code>name</code>是一个对象，改写其属性是允许的，并且其他模块也可以读到改写后的值。不过，这种写法很难查错，建议凡是输入的变量，都当作完全只读，不要轻易改变它的属性。</p>
<h5 id="5-import-from后的路径"><a href="#5-import-from后的路径" class="headerlink" title="5. import from后的路径"></a>5. import from后的路径</h5><p><code>import</code>后面的<code>from</code>指定模块文件的位置，可以是相对路径，也可以是绝对路径，<font color=red>后缀名不能省略</font>。</p>
<p>如果不带有路径，只是一个模块名，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; myMethod &#125; <span class="keyword">from</span> <span class="string">&#x27;util&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>util</code>是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。</p>
<h5 id="6-import命令的提升"><a href="#6-import命令的提升" class="headerlink" title="6. import命令的提升"></a>6. import命令的提升</h5><p>注意，<code>import</code>命令具有提升效果，会提升到整个模块的头部，首先执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>();</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面的代码不会报错，因为<code>import</code>的执行早于<code>foo</code>的调用。这种行为的本质是，<code>import</code>命令是编译阶段执行的，在代码运行之前。</p>
<p>目前阶段，通过 Babel 转码，CommonJS 模块的<code>require</code>命令和 ES6 模块的<code>import</code>命令，可以写在同一个模块里面，但是最好不要这样做。因为<code>import</code>在静态解析阶段执行，所以它是一个模块之中最早执行的。下面的代码可能不会得到预期结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.symbol&#x27;</span>);</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&#x27;core-js/modules/es6.promise&#x27;</span>);</span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span> <span class="keyword">from</span> <span class="string">&#x27;React&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="7-import中不能使用表达式和变量"><a href="#7-import中不能使用表达式和变量" class="headerlink" title="7. import中不能使用表达式和变量"></a>7. import中不能使用表达式和变量</h5><p>由于<code>import</code>是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="string">&#x27;f&#x27;</span> + <span class="string">&#x27;oo&#x27;</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable language_">module</span> = <span class="string">&#x27;my_module&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="variable language_">module</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">if</span> (x === <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module1&#x27;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">import</span> &#123; foo &#125; <span class="keyword">from</span> <span class="string">&#x27;module2&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面三种写法都会报错，因为它们用到了表达式、变量和<code>if</code>结构。在静态分析阶段，这些语法都是没法得到值的。</p>
<h4 id="3-2-4-export-default"><a href="#3-2-4-export-default" class="headerlink" title="3.2.4 export default"></a>3.2.4 export default</h4><h5 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h5><p>前面我们学习的导出功能都是有名字的导出（named exports）：</p>
<ul>
<li>在导出export时指定了名字；</li>
<li>在导入import时需要知道具体的名字；</li>
</ul>
<p>还有一种导出叫做默认导出（default export）</p>
<ul>
<li>默认导出export时可以不需要指定名字；</li>
<li>在导入时不需要使用 <code>&#123;&#125;</code>，并且可以自己来指定名字；</li>
<li>它也方便我们和现有的CommonJS等规范相互操作；</li>
</ul>
<h5 id="2-导出与导入格式"><a href="#2-导出与导入格式" class="headerlink" title="2. 导出与导入格式"></a>2. 导出与导入格式</h5><p>也是可以导出变量、函数、类的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出格式1</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">sub</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出格式2：用在非匿名函数前</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出格式3：用在函数变量前</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sub</span>(<span class="params"></span>) &#123; <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sub&#x27;</span>); &#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sub;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数名`sub`，在模块外部是无效的。加载的时候，视同匿名函数加载。</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式1：常用及推荐</span></span><br><span class="line"><span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sub</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式2</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="property">default</span>.<span class="title function_">sub</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入格式3</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(m.<span class="title function_">sub</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure>

<h5 id="3-export-default的本质"><a href="#3-export-default的本质" class="headerlink" title="3. export default的本质"></a>3. export default的本质</h5><p>本质上，<code>export default</code>就是输出一个叫做<code>default</code>的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123;add <span class="keyword">as</span> <span class="keyword">default</span>&#125;;  <span class="comment">// 等同于 export default add;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> foo &#125; <span class="keyword">from</span> <span class="string">&#x27;modules&#x27;</span>; <span class="comment">// 等同于 import foo from &#x27;modules&#x27;;</span></span><br></pre></td></tr></table></figure>

<p>正是因为<code>export default</code>命令其实只是输出一个叫做<code>default</code>的变量，所以它后面不能跟变量声明语句。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> a; <span class="comment">// 含义是将变量`a`的值赋给变量`default`。所以，下面的写法会报错。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误</span></span><br><span class="line"><span class="comment">// export default var a = 1;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同样地，因为`export default`命令的本质是将后面的值，赋给`default`变量，所以可以直接将一个值写在`export default`之后。</span></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">42</span>;</span><br><span class="line"><span class="comment">// 报错。报错是因为没有指定对外的接口，而前一句指定对外接口为default。</span></span><br><span class="line"><span class="comment">// export 42; // export后面得跟声明，或者&#123;标识符&#125;</span></span><br></pre></td></tr></table></figure>

<h5 id="4-export-default与export"><a href="#4-export-default与export" class="headerlink" title="4. export default与export"></a>4. export default与export</h5><p>注意：在一个模块中，export default是可以与export同时使用的：</p>
<ul>
<li>export default用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export default</code>命令只能使用一次。</li>
<li>export是没有限制的。<code>export &lt;decl&gt;</code>、<code>export &#123;&#125;</code>、<code>export &#123;&lt;&gt; as &lt;&gt;&#125;</code>都是可以出现<code>0-n</code>次的</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">function</span> <span class="title function_">sub</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 - num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> name = <span class="string">&quot;module1&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入 在一条`import`语句中，同时输入默认接口和其他接口</span></span><br><span class="line"><span class="keyword">import</span> m, &#123;name&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">//m.sub、name</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">// m.default.sub、m.name</span></span><br><span class="line"><span class="keyword">import</span> &#123;<span class="keyword">default</span> <span class="keyword">as</span> m, name&#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>; <span class="comment">// m.sub、name</span></span><br></pre></td></tr></table></figure>

<h4 id="3-2-5-export和import结合"><a href="#3-2-5-export和import结合" class="headerlink" title="3.2.5 export和import结合"></a>3.2.5 export和import结合</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bar.js 导出一个sum函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sum = <span class="keyword">function</span>(<span class="params">num1, num2</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.js做一个中转</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js直接从foo中导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">sum</span>(<span class="number">20</span>, <span class="number">30</span>));</span><br></pre></td></tr></table></figure>

<p>如果从一个模块中导入的内容，我们希望再直接导出出去，这个时候可以使用export和import的结合，写成一行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js 导入，但是只是做一个中转</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口改名</span></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> barSum &#125; <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>; <span class="comment">// 甚至在foo.js中导出时，我们可以变化它的名字</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 整体导入和导出</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;./bar.js&#x27;</span>;</span><br><span class="line">    <span class="comment">// 相当于实现了模块之间的继承。注意，`export *`命令会忽略后面模块的`default`接口。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具名接口改为默认接口的写法如下：</span></span><br><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接口也可以改名为具名接口：</span></span><br><span class="line"><span class="keyword">export</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> es6 &#125; <span class="keyword">from</span> <span class="string">&#x27;./someModule&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES2020 之前，有一种`import`语句，没有对应的复合写法。[ES2020](https://github.com/tc39/proposal-export-ns-from)补上了这个写法。</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line">    <span class="comment">// 等同于</span></span><br><span class="line">    <span class="keyword">import</span> * <span class="keyword">as</span> ns <span class="keyword">from</span> <span class="string">&quot;mod&quot;</span>;</span><br><span class="line">    <span class="keyword">export</span> &#123;ns&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要注意的是，写成一行以后，`sum`实际上并没有被导入当前模块，只是相当于对外转发了这个接口，导致当前模块不能直接使用`sum`。</span></span><br></pre></td></tr></table></figure>

<p>为什么要这样做呢？</p>
<ul>
<li>在开发和封装一个功能库时，通常我们希望将暴露的所有接口放到一个文件中；</li>
<li>这样方便指定统一的接口规范，也方便阅读；</li>
<li>这个时候，我们就可以使用export和import结合使用；</li>
</ul>
<h4 id="3-2-6-import"><a href="#3-2-6-import" class="headerlink" title="3.2.6 import()"></a>3.2.6 import()</h4><h5 id="1-import-的背景"><a href="#1-import-的背景" class="headerlink" title="1. import()的背景"></a>1. import()的背景</h5><p>前面介绍过，<code>import</code>命令会被 JavaScript 引擎静态分析，先于模块内的其他语句执行。所以，<code>import</code>和<code>export</code>命令只能在模块的顶层，是不可以在其放到逻辑代码中（比如在<code>if</code>代码块之中，或在函数之中）的。下面的代码会报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">import</span> sub <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>引擎处理<code>import</code>语句是在编译时，这时不会去分析或执行<code>if</code>语句，所以<code>import</code>语句放在<code>if</code>代码块之中毫无意义，因此会报句法错误，而不是执行时错误。</p>
<p>这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。在语法上，条件加载就不可能实现。如果<code>import</code>命令要取代 Node 的<code>require</code>方法，这就形成了一个障碍。因为<code>require</code>是运行时加载模块，<code>import</code>命令无法取代<code>require</code>的动态加载功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="string">&#x27;./&#x27;</span> + fileName;</span><br><span class="line"><span class="keyword">const</span> myModual = <span class="built_in">require</span>(path); </span><br><span class="line"><span class="comment">// 上面的语句就是动态加载，`require`到底加载哪一个模块，只有运行时才知道。`import`命令做不到这一点。</span></span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-dynamic-import">ES2020提案</a> 引入<code>import()</code>函数，支持动态加载模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">import</span>(specifier)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>import</code>函数的参数<code>specifier</code>，指定所要加载的模块的位置。<code>import</code>命令能够接受什么参数，<code>import()</code>函数就能接受什么参数，两者区别主要是后者为动态加载。</p>
<h5 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h5><p><code>import()</code>返回一个 Promise 对象。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> main = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;main&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">import</span>(<span class="string">`./section-modules/<span class="subst">$&#123;someVariable&#125;</span>.js`</span>)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">module</span> =&gt;</span> &#123;		<span class="comment">// 加载模块成功以后，这个模块会作为一个对象，当作`then`方法的参数.</span></span><br><span class="line"><span class="comment">//.then(&#123;export1, export2&#125; =&gt; &#123;     // 可以使用对象解构赋值的语法，获取输出接口。</span></span><br><span class="line"><span class="comment">//.then(&#123;default: theDefault&#125; =&gt; &#123;  // 如果是default，那么需要解构重命名</span></span><br><span class="line">    </span><br><span class="line">  	<span class="variable language_">module</span>.<span class="title function_">loadPageInto</span>(main); <span class="comment">// module.default来使用默认导出</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    main.<span class="property">textContent</span> = err.<span class="property">message</span>;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想同时加载多个模块，可以采用下面的写法。</span></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">  <span class="title function_">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">  <span class="title function_">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">  <span class="title function_">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">])</span><br><span class="line">.<span class="title function_">then</span>(<span class="function">(<span class="params">[module1, module2, module3]</span>) =&gt;</span> &#123;</span><br><span class="line">   ···</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回值是Promise对象，所以也可以用在async函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> myModule = <span class="keyword">await</span> <span class="title function_">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> &#123;export1, export2&#125; = <span class="keyword">await</span> <span class="title function_">import</span>(<span class="string">&#x27;./myModule.js&#x27;</span>);</span><br><span class="line">  <span class="keyword">const</span> [module1, module2, module3] =</span><br><span class="line">    <span class="keyword">await</span> <span class="title class_">Promise</span>.<span class="title function_">all</span>([</span><br><span class="line">      <span class="title function_">import</span>(<span class="string">&#x27;./module1.js&#x27;</span>),</span><br><span class="line">      <span class="title function_">import</span>(<span class="string">&#x27;./module2.js&#x27;</span>),</span><br><span class="line">      <span class="title function_">import</span>(<span class="string">&#x27;./module3.js&#x27;</span>),</span><br><span class="line">    ]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>();</span><br></pre></td></tr></table></figure>

<p><code>import()</code>函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，就会加载指定的模块。另外，<code>import()</code>函数与所加载的模块没有静态连接关系，这点也是与<code>import</code>语句不相同。<code>import()</code>类似于 Node 的<code>require</code>方法，区别主要是前者是异步加载，后者是同步加载。</p>
<h5 id="3-适用场合"><a href="#3-适用场合" class="headerlink" title="3. 适用场合"></a>3. 适用场合</h5><ul>
<li><p>按需加载。</p>
<p><code>import()</code>可以在需要的时候，再加载某个模块。比如放在<code>click</code>事件的监听函数之中，只有用户点击了按钮，才会加载这个模块。</p>
</li>
<li><p>条件加载</p>
<p><code>import()</code>可以放在<code>if</code>代码块，根据不同的情况，加载不同的模块。</p>
</li>
<li><p>动态的模块路径</p>
<p><code>import()</code>允许模块路径动态生成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">import</span>(<span class="title function_">f</span>()).<span class="title function_">then</span>(...);  <span class="comment">// 根据函数`f`的返回结果，加载不同的模块。</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="3-2-7-应用-公共头文件"><a href="#3-2-7-应用-公共头文件" class="headerlink" title="3.2.7 应用: 公共头文件"></a>3.2.7 应用: 公共头文件</h4><p>介绍<code>const</code>命令的时候说过，<code>const</code>声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），或者说一个值要被多个模块共享，可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(constants.<span class="property">A</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(constants.<span class="property">B</span>); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(A); <span class="comment">// 1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>如果要使用的常量非常多，可以建一个专门的<code>constants</code>目录，将各种常量写在不同的文件里面，保存在该目录下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/db.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = &#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://my.couchdbserver.local:5984&#x27;</span>,</span><br><span class="line">  <span class="attr">admin_username</span>: <span class="string">&#x27;admin&#x27;</span>,</span><br><span class="line">  <span class="attr">admin_password</span>: <span class="string">&#x27;admin password&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// constants/user.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> users = [<span class="string">&#x27;root&#x27;</span>, <span class="string">&#x27;admin&#x27;</span>, <span class="string">&#x27;staff&#x27;</span>, <span class="string">&#x27;ceo&#x27;</span>, <span class="string">&#x27;chief&#x27;</span>, <span class="string">&#x27;moderator&#x27;</span>];</span><br></pre></td></tr></table></figure>

<p>然后，将这些文件输出的常量，合并在<code>index.js</code>里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants/index.js</span></span><br><span class="line"><span class="keyword">export</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">&#x27;./db&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;users&#125; <span class="keyword">from</span> <span class="string">&#x27;./users&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>使用的时候，直接加载<code>index.js</code>就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;db, users&#125; <span class="keyword">from</span> <span class="string">&#x27;./constants/index.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-8-与CommonJS模块化的差异"><a href="#3-2-8-与CommonJS模块化的差异" class="headerlink" title="3.2.8 与CommonJS模块化的差异"></a>3.2.8 与CommonJS模块化的差异</h4><ul>
<li>CommonJS 模块输出的是一个值的拷贝(module.exports的浅拷贝)，ES6 模块输出的是值的引用。</li>
<li>CommonJS 模块是运行时加载，ES6 模块是编译(解析)时加载。<ul>
<li>运行时加载意味着是js引擎在 执行js代码的过程中 加载模块；所以require可以与变量、表达式等运行时代码结合使用</li>
<li>编译时（解析）时加载，意味着import不能和运行时相关的内容放在一起使用：<ul>
<li>比如from后面的路径需要动态获取；</li>
<li>比如不能将import放到if等语句的代码块中；</li>
<li>所以我们有时候也称ES Module是静态解析的，而不是动态或者运行时解析的；</li>
</ul>
</li>
</ul>
</li>
<li>CommonJS 模块的<code>require()</code>是同步加载模块，ES6 模块的<code>import</code>命令是异步加载，有一个独立的模块依赖的解析阶段。<ul>
<li>同步的就意味着一个文件没有加载结束之前，后面的代码都不会执行；</li>
<li>异步的意味着：不会阻塞主线程继续执行；<ul>
<li>JS引擎在遇到<code>import</code>时会去获取这个js文件的过程是异步的</li>
<li>设置了 <code>type=module</code> 的script标签，相当于加上了 <code>async</code> 属性；</li>
<li>如果我们后面有普通的script标签以及对应的代码，那么ES Module对应的js文件和代码不会阻塞它们的执行；</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>CommonJS代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;main代码执行&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> flag = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">if</span> (flag) &#123;</span><br><span class="line">  <span class="comment">// 同步加载foo文件，并且执行一次内部的代码</span></span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;if语句继续执行&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ES Module代码：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;main.js&quot;</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 这个js文件的代码不会被阻塞执行 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="四、CommonJS模块与ES6模块的混编"><a href="#四、CommonJS模块与ES6模块的混编" class="headerlink" title="四、CommonJS模块与ES6模块的混编"></a>四、CommonJS模块与ES6模块的混编</h2><h3 id="4-1-CommonJS模块加载ES6模块"><a href="#4-1-CommonJS模块加载ES6模块" class="headerlink" title="4.1 CommonJS模块加载ES6模块"></a>4.1 CommonJS模块加载ES6模块</h3><p>通常情况下，CommonJS不能加载ES Module</p>
<ul>
<li>因为CommonJS是同步加载的，但是ES Module必须经过静态分析等，无法在这个时候执行JavaScript代码；</li>
<li>但是这个并非绝对的，某些平台在实现的时候可以对代码进行针对性的解析，也可能会支持；</li>
</ul>
<p>可以使用<code>import()</code>这个方法加载</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">import</span>(<span class="string">&#x27;./my-app.mjs&#x27;</span>);</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上面代码可以在 CommonJS 模块中运行。</p>
<p><code>require()</code>不支持 ES6 模块的一个原因是，它是同步加载，而 ES6 模块内部可以使用顶层<code>await</code>命令，导致无法被同步加载。</p>
<h3 id="4-2-ES6模块加载CommonJS模块"><a href="#4-2-ES6模块加载CommonJS模块" class="headerlink" title="4.2 ES6模块加载CommonJS模块"></a>4.2 ES6模块加载CommonJS模块</h3><p>多数情况下，ES Module可以加载CommonJS，但是只能整体加载，不能只加载单一的输出项。</p>
<ul>
<li>ES Module在加载CommonJS时，会将其module.exports导出的内容作为default导出方式来使用；</li>
<li>这个依然需要看具体的实现，比如webpack中是支持的、Node最新的Current（v14.13.1）版本也是支持的；</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.js</span></span><br><span class="line"><span class="keyword">const</span> address = <span class="string">&#x27;foo的address&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> foo <span class="keyword">from</span> <span class="string">&#x27;./modules/foo.js&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">address</span>);</span><br></pre></td></tr></table></figure>

<p>还有一种变通的加载方法，就是使用 Node.js 内置的<code>module.createRequire()</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cjs.cjs</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="string">&#x27;cjs&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// esm.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123; createRequire &#125; <span class="keyword">from</span> <span class="string">&#x27;module&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">require</span> = <span class="title function_">createRequire</span>(<span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">url</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cjs = <span class="built_in">require</span>(<span class="string">&#x27;./cjs.cjs&#x27;</span>);</span><br><span class="line">cjs === <span class="string">&#x27;cjs&#x27;</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，ES6 模块通过<code>module.createRequire()</code>方法可以加载 CommonJS 模块。但是，这种写法等于将 ES6 和 CommonJS 混在一起了，所以不建议使用。</p>
<h3 id="4-3-使模块同时支持两种模块化导入"><a href="#4-3-使模块同时支持两种模块化导入" class="headerlink" title="4.3 使模块同时支持两种模块化导入"></a>4.3 使模块同时支持两种模块化导入</h3><p>一个模块同时要支持 CommonJS 和 ES6 两种格式，也很容易。</p>
<p>如果原始模块是 ES6 格式，那么需要给出一个整体输出接口，比如<code>export default obj</code>，使得 CommonJS 可以用<code>import()</code>进行加载。</p>
<p>如果原始模块是 CommonJS 格式，那么可以加一个包装层。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cjsModule <span class="keyword">from</span> <span class="string">&#x27;../index.js&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> foo = cjsModule.<span class="property">foo</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。</p>
<p>你可以把这个文件的后缀名改为<code>.mjs</code>，或者将它放在一个子目录，再在这个子目录里面放一个单独的<code>package.json</code>文件，指明<code>&#123; type: &quot;module&quot; &#125;</code>。</p>
<p>如果是Node.js中，还有一种做法是在<code>package.json</code>文件的<code>exports</code>字段，指明两种格式模块各自的加载入口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;exports&quot;</span>：&#123;</span><br><span class="line">  <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./index.js&quot;</span>，</span><br><span class="line">  <span class="string">&quot;import&quot;</span>: <span class="string">&quot;./esm/wrapper.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码指定<code>require()</code>和<code>import</code>，加载该模块会自动切换到不一样的入口文件。</p>
<h2 id="五、Node-js开发中的模块化"><a href="#五、Node-js开发中的模块化" class="headerlink" title="五、Node.js开发中的模块化"></a>五、Node.js开发中的模块化</h2><h3 id="5-1-Node中支持-ES6-Module"><a href="#5-1-Node中支持-ES6-Module" class="headerlink" title="5.1 Node中支持 ES6 Module"></a>5.1 Node中支持 ES6 Module</h3><p>JavaScript 现在常用的有两种模块。</p>
<ul>
<li>ES6 模块，简称 ESM；</li>
<li>CommonJS 模块，简称 CJS。</li>
</ul>
<p>CommonJS 模块是 Node.js 专用的，与 ES6 模块不兼容。语法上面，两者最明显的差异是，CommonJS 模块使用<code>require()</code>和<code>module.exports</code>，ES6 模块使用<code>import</code>和<code>export</code>。</p>
<p>从 Node.js v13.2 版本开始，Node.js 已经默认打开了 ES6 模块支持，需要进行以下操作：</p>
<ul>
<li>方式一：文件以 <code>.mjs</code> 结尾，表示使用的是ES Module；</li>
<li>方式二：在package.json中配置字段 <code>type: module</code>，一旦设置了以后，该目录里面的 JS 脚本，就被解释用 ES6 模块。<ul>
<li>如果这时还要使用 CommonJS 模块，那么需要将 CommonJS 脚本的后缀名都改成<code>.cjs</code>。</li>
</ul>
</li>
<li>如果没有<code>type</code>字段，或者<code>type</code>字段为<code>commonjs</code>，则<code>.js</code>脚本会被解释成 CommonJS 模块。</li>
</ul>
<p>在之前的版本（比如v12.19.0）中，也是可以正常运行的，但是会报一个警告：</p>
<img src="/images/webmodule/lstwarning.jpg" alt="图片" style="zoom:80%;" />

<p>Node.js 遇到 ES6 模块，默认启用严格模式，不必在每个模块文件顶部指定<code>&quot;use strict&quot;</code>。</p>
<p>总结为一句话：</p>
<ul>
<li><code>.mjs</code>文件总是以 ES6 模块加载</li>
<li><code>.cjs</code>文件总是以 CommonJS 模块加载</li>
<li><code>.js</code>文件的加载取决于<code>package.json</code>里面<code>type</code>字段的设置。</li>
</ul>
<p>注意，ES6 模块与 CommonJS 模块尽量不要混用。<code>require</code>命令不能加载<code>.mjs</code>文件，会报错，只有<code>import</code>命令才可以加载<code>.mjs</code>文件。反过来，<code>.mjs</code>文件里面也不能使用<code>require</code>命令，必须使用<code>import</code>。</p>
<h3 id="5-2-Node-js包模块的入口文件设置"><a href="#5-2-Node-js包模块的入口文件设置" class="headerlink" title="5.2 Node.js包模块的入口文件设置"></a>5.2 Node.js包模块的入口文件设置</h3><h4 id="5-2-1-package-json-的-main-字段"><a href="#5-2-1-package-json-的-main-字段" class="headerlink" title="5.2.1 package.json 的 main 字段"></a>5.2.1 package.json 的 main 字段</h4><p><code>package.json</code>文件有两个字段可以指定模块的入口文件：<code>main</code>和<code>exports</code>。比较简单的模块，可以只使用<code>main</code>字段，指定模块加载的入口文件。</p>
<h5 id="举例：指定入口文件，格式为ESM"><a href="#举例：指定入口文件，格式为ESM" class="headerlink" title="举例：指定入口文件，格式为ESM"></a>举例：指定入口文件，格式为ESM</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./src/index.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码指定项目的入口脚本为<code>./src/index.js</code>，它的格式为 ES6 模块。如果没有<code>type</code>字段，<code>index.js</code>就会被解释为 CommonJS 模块。</p>
<p>然后，<code>import</code>命令就可以加载这个模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./my-app.mjs</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;es-module-package&#x27;</span>;</span><br><span class="line"><span class="comment">// 实际加载的是 ./node_modules/es-module-package/src/index.js</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，运行该脚本以后，Node.js 就会到<code>./node_modules</code>目录下面，寻找<code>es-module-package</code>模块，然后根据该模块<code>package.json</code>的<code>main</code>字段去执行入口文件。</p>
<p>这时，如果用 CommonJS 模块的<code>require()</code>命令去加载<code>es-module-package</code>模块会报错，因为 CommonJS 模块不能处理<code>export</code>命令。</p>
<h4 id="5-2-2-package-json-的-exports-字段"><a href="#5-2-2-package-json-的-exports-字段" class="headerlink" title="5.2.2 package.json 的 exports 字段"></a>5.2.2 package.json 的 exports 字段</h4><p><code>exports</code>字段的优先级高于<code>main</code>字段。它有多种用法。</p>
<h5 id="1-给脚本或子目录起别名"><a href="#1-给脚本或子目录起别名" class="headerlink" title="1. 给脚本或子目录起别名"></a>1. 给脚本或子目录起别名</h5><p><code>package.json</code>文件的<code>exports</code>字段可以指定脚本或子目录的别名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./node_modules/es-module-package/package.json</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./submodule&quot;</span>: <span class="string">&quot;./src/submodule.js&quot;</span>,  <span class="comment">//给脚本文件 src/submodule.js 起别名</span></span><br><span class="line">    <span class="string">&quot;./features/&quot;</span>: <span class="string">&quot;./src/features/&quot;</span>，<span class="comment">// 给子目录 ./src/features/ 起别名</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过别名加载：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/submodule&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/submodule.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> feature <span class="keyword">from</span> <span class="string">&#x27;es-module-package/features/x.js&#x27;</span>;</span><br><span class="line"><span class="comment">// 加载 ./node_modules/es-module-package/src/features/x.js</span></span><br></pre></td></tr></table></figure>

<p>如果没有指定别名，就不能用“模块+脚本名”这种形式加载脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;es-module-package/private-module.js&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">import</span> submodule <span class="keyword">from</span> <span class="string">&#x27;./node_modules/es-module-package/private-module.js&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h5 id="2-main-的别名"><a href="#2-main-的别名" class="headerlink" title="2. main 的别名."></a>2. main 的别名<code>.</code></h5><p><code>exports</code>字段的别名如果是<code>.</code> 就代表了是模块的主入口，优先级高于<code>main</code>字段，并且可以直接简写成<code>exports</code>字段的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于<code>exports</code>字段只有支持 ES6 的 Node.js 才认识，所以可以用来兼容旧版本的 Node.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;main&quot;</span>: <span class="string">&quot;./main-legacy.cjs&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: <span class="string">&quot;./main-modern.cjs&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，老版本的 Node.js （不支持 ES6 模块）的入口文件是<code>main-legacy.cjs</code>，新版本的 Node.js 的入口文件是<code>main-modern.cjs</code>。</p>
<h5 id="3-条件加载"><a href="#3-条件加载" class="headerlink" title="3. 条件加载"></a>3. 条件加载</h5><p>利用<code>.</code>这个别名，可以为 ES6 模块和 CommonJS 指定不同的入口。目前，这个功能需要在 Node.js 运行的时候，打开<code>--experimental-conditional-exports</code>标志。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;module&quot;</span>,</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;.&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>, <span class="comment">// 别名`.`的`require`条件指定`require()`命令的入口文件（即 CommonJS 的入口）</span></span><br><span class="line">      <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span> <span class="comment">// 别名`.`的`default`条件指定其他情况的入口（即 ES6 的入口）。</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的写法可以简写如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，如果同时还有其他别名，就不能采用简写，否则或报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  <span class="string">&quot;exports&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;./feature&quot;</span>: <span class="string">&quot;./lib/feature.js&quot;</span>,</span><br><span class="line">    <span class="string">&quot;require&quot;</span>: <span class="string">&quot;./main.cjs&quot;</span>,</span><br><span class="line">    <span class="string">&quot;default&quot;</span>: <span class="string">&quot;./main.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-Node-js原生模块完全支持ES6-Module"><a href="#5-3-Node-js原生模块完全支持ES6-Module" class="headerlink" title="5.3 Node.js原生模块完全支持ES6 Module"></a>5.3 Node.js原生模块完全支持ES6 Module</h3><p>Node.js 的内置模块可以整体加载，也可以加载指定的输出项。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 整体加载</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">EventEmitter</span> <span class="keyword">from</span> <span class="string">&#x27;events&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> e = <span class="keyword">new</span> <span class="title class_">EventEmitter</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载指定的输出项</span></span><br><span class="line"><span class="keyword">import</span> &#123; readFile &#125; <span class="keyword">from</span> <span class="string">&#x27;fs&#x27;</span>;</span><br><span class="line"><span class="title function_">readFile</span>(<span class="string">&#x27;./foo.txt&#x27;</span>, <span class="function">(<span class="params">err, source</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(source);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="5-4-加载路径"><a href="#5-4-加载路径" class="headerlink" title="5.4 加载路径"></a>5.4 加载路径</h3><p>ES6 模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。<code>import</code>命令和<code>package.json</code>文件的<code>main</code>字段如果省略脚本的后缀名，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 模块中将报错</span></span><br><span class="line"><span class="keyword">import</span> &#123; something &#125; <span class="keyword">from</span> <span class="string">&#x27;./index&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>为了与浏览器的<code>import</code>加载规则相同，Node.js 的<code>.mjs</code>文件支持 URL 路径。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./foo.mjs?query=1&#x27;</span>; <span class="comment">// 加载 ./foo 传入参数 ?query=1</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，脚本路径带有参数<code>?query=1</code>，Node 会按 URL 规则解读。同一个脚本只要参数不同，就会被加载多次，并且保存成不同的缓存。由于这个原因，只要文件名中含有<code>:</code>、<code>%</code>、<code>#</code>、<code>?</code>等特殊字符，最好对这些字符进行转义。</p>
<p>目前，Node.js 的<code>import</code>命令只支持加载本地模块（<code>file:</code>协议）和<code>data:</code>协议，不支持加载远程模块。另外，脚本路径只支持相对路径，不支持绝对路径（即以<code>/</code>或<code>//</code>开头的路径）。</p>
<h3 id="5-5-内部变量"><a href="#5-5-内部变量" class="headerlink" title="5.5 内部变量"></a>5.5 内部变量</h3><p>ES6 模块应该是通用的，同一个模块不用修改，就可以用在浏览器环境和服务器环境。为了达到这个目标，Node.js 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量。</p>
<p>首先，就是<code>this</code>关键字。ES6 模块之中，顶层的<code>this</code>指向<code>undefined</code>；CommonJS 模块的顶层<code>this</code>指向当前模块，这是两者的一个重大差异。</p>
<p>其次，以下这些顶层变量在 ES6 模块之中都是不存在的。</p>
<ul>
<li><code>arguments</code></li>
<li><code>require</code></li>
<li><code>module</code></li>
<li><code>exports</code></li>
<li><code>__filename</code></li>
<li><code>__dirname</code></li>
</ul>
<h2 id="六、循环加载"><a href="#六、循环加载" class="headerlink" title="六、循环加载"></a>六、循环加载</h2><p>“循环加载”（circular dependency）指的是，<code>a</code>脚本的执行依赖<code>b</code>脚本，而<code>b</code>脚本的执行又依赖<code>a</code>脚本。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;b&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。</p>
<p>但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现<code>a</code>依赖<code>b</code>，<code>b</code>依赖<code>c</code>，<code>c</code>又依赖<code>a</code>这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。</p>
<p>对于 JavaScript 语言来说，目前最常见的两种模块格式 CommonJS 和 ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。</p>
<h3 id="6-1-CommonJS-模块的循环加载"><a href="#6-1-CommonJS-模块的循环加载" class="headerlink" title="6.1 CommonJS 模块的循环加载"></a>6.1 CommonJS 模块的循环加载</h3><p>CommonJS 模块的重要特性是加载时执行，即脚本代码在<code>require</code>的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。</p>
<p>让我们来看，Node <a target="_blank" rel="noopener" href="https://nodejs.org/api/modules.html#modules_cycles">官方文档</a>里面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;   <span class="comment">// 先输出一个`done`变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>); <span class="comment">// 然后加载另一个脚本文件b.js。注意，此时代码就停在这里，等待`b.js`执行完毕，再往下执行。</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 a.js 之中，b.done = %j&#x27;</span>, b.<span class="property">done</span>); <span class="comment">// b.js执行完毕，返回来a.js接着往下执行，直到执行完毕。</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.js 执行完毕&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 执行到这一行，会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。</span></span><br><span class="line"><span class="comment"> 此时：a.js已经执行的部分，只有一行：exports.done = false; 即对于b.js来说，它从a.js只输入一个变量done=false 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>); </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 b.js 之中，a.done = %j&#x27;</span>, a.<span class="property">done</span>);</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">done</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.js 执行完毕&#x27;</span>);</span><br><span class="line"><span class="comment">// b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。</span></span><br></pre></td></tr></table></figure>

<p>我们写一个脚本main.js，验证这个过程。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;./a.js&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&#x27;./b.js&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;在 main.js 之中, a.done=%j, b.done=%j&#x27;</span>, a.<span class="property">done</span>, b.<span class="property">done</span>);</span><br></pre></td></tr></table></figure>

<p>执行<code>main.js</code>，运行结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line"></span><br><span class="line">在 b.js 之中，a.done = <span class="literal">false</span></span><br><span class="line">b.js 执行完毕</span><br><span class="line">在 a.js 之中，b.done = <span class="literal">true</span></span><br><span class="line">a.js 执行完毕</span><br><span class="line">在 main.js 之中, a.done=<span class="literal">true</span>, b.done=<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>上面的代码证明了两件事：</p>
<ol>
<li>在<code>b.js</code>之中，<code>a.js</code>没有执行完毕，只执行了第一行。</li>
<li><code>main.js</code>执行到第二行时，不会再次执行<code>b.js</code>，而是输出缓存的<code>b.js</code>的执行结果，即它的第四行<code>exports.done = true;</code></li>
</ol>
<p>总之，CommonJS 输入的是被输出值的拷贝，不是引用。</p>
<p>另外，<strong>由于 CommonJS 模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>); <span class="comment">// 安全的写法</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;a&#x27;</span>).<span class="property">foo</span>; <span class="comment">// 危险的写法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">good</span> = <span class="keyword">function</span> (<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> a.<span class="title function_">foo</span>(<span class="string">&#x27;good&#x27;</span>, arg); <span class="comment">// 使用的是 a.foo 的最新值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">bad</span> = <span class="keyword">function</span> (<span class="params">arg</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">foo</span>(<span class="string">&#x27;bad&#x27;</span>, arg); <span class="comment">// 使用的是一个部分加载时的值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果发生循环加载，<code>require(&#39;a&#39;).foo</code>的值很可能后面会被改写，改用<code>require(&#39;a&#39;)</code>会更保险一点。</p>
<h3 id="6-2-ES6-模块的循环加载"><a href="#6-2-ES6-模块的循环加载" class="headerlink" title="6.2 ES6 模块的循环加载"></a>6.2 ES6 模块的循环加载</h3><p>ES6 处理“循环加载”与 CommonJS 有本质的不同。ES6 模块是动态引用，如果使用<code>import</code>从一个模块加载变量（即<code>import foo from &#39;foo&#39;</code>），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。</p>
<p>请看下面这个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(bar);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> bar = <span class="string">&#x27;bar&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a.mjs</code>加载<code>b.mjs</code>，<code>b.mjs</code>又加载<code>a.mjs</code>，构成循环加载。执行<code>a.mjs</code>，结果如下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">ReferenceError: foo is not defined</span><br></pre></td></tr></table></figure>

<p>上面代码中，执行<code>a.mjs</code>以后会报错，<code>foo</code>变量未定义，这是为什么？</p>
<p>让我们一行行来看，ES6 循环加载是怎么处理的：</p>
<ul>
<li>首先，执行<code>a.mjs</code>以后，引擎发现它加载了<code>b.mjs</code>，因此会优先执行<code>b.mjs</code>，然后再执行<code>a.mjs</code>。</li>
<li>接着，执行<code>b.mjs</code>的时候，已知它从<code>a.mjs</code>输入了<code>foo</code>接口，这时不会去执行<code>a.mjs</code>，而是认为这个接口已经存在了，继续往下执行。</li>
<li>执行到第三行<code>console.log(foo)</code>的时候，才发现这个接口根本没定义，因此报错。</li>
</ul>
<p>解决这个问题的方法，就是让<code>b.mjs</code>运行的时候，<code>foo</code>已经有定义了。这可以通过将<code>foo</code>写成函数来解决。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;bar&#125; <span class="keyword">from</span> <span class="string">&#x27;./b&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;a.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">bar</span>());</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span> &#125;   <span class="comment">// const foo = () =&gt; &#x27;foo&#x27;; 仍然会执行报错。函数表达式，就不具有提升作用</span></span><br><span class="line"><span class="keyword">export</span> &#123;foo&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.mjs</span></span><br><span class="line"><span class="keyword">import</span> &#123;foo&#125; <span class="keyword">from</span> <span class="string">&#x27;./a&#x27;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;b.mjs&#x27;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo</span>());</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">bar</span>(<span class="params"></span>) &#123; <span class="keyword">return</span> <span class="string">&#x27;bar&#x27;</span> &#125;</span><br><span class="line"><span class="keyword">export</span> &#123;bar&#125;;</span><br></pre></td></tr></table></figure>

<p>这时再执行<code>a.mjs</code>就可以得到预期结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node --experimental-modules a.mjs</span><br><span class="line">b.mjs</span><br><span class="line">foo</span><br><span class="line">a.mjs</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>

<p>这是因为<strong>函数具有提升作用</strong>，在执行<code>import &#123;bar&#125; from &#39;./b&#39;</code>时，函数<code>foo</code>就已经有定义了，所以<code>b.mjs</code>加载的时候不会报错。</p>
<p>这也意味着，<strong>如果把函数<code>foo</code>改写成函数表达式，也会报错。</strong></p>
<h3 id="6-3-代码示例"><a href="#6-3-代码示例" class="headerlink" title="6.3 代码示例"></a>6.3 代码示例</h3><p>我们再来看 ES6 模块加载器<a target="_blank" rel="noopener" href="https://github.com/ModuleLoader/es6-module-loader/blob/master/docs/circular-references-bindings.md">SystemJS</a>给出的一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; odd &#125; <span class="keyword">from</span> <span class="string">&#x27;./odd&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">even</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n === <span class="number">0</span> || <span class="title function_">odd</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; even &#125; <span class="keyword">from</span> <span class="string">&#x27;./even&#x27;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">odd</span>(<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n !== <span class="number">0</span> &amp;&amp; <span class="title function_">even</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>even.js</code>里面的函数<code>even</code>有一个参数<code>n</code>，只要不等于 0，就会减去 1，传入加载的<code>odd()</code>。<code>odd.js</code>也会做类似操作。</p>
<p>运行上面这段代码，结果如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ babel-node</span><br><span class="line">&gt; <span class="keyword">import</span> * <span class="keyword">as</span> m <span class="keyword">from</span> <span class="string">&#x27;./even.js&#x27;</span>;</span><br><span class="line">&gt; m.<span class="title function_">even</span>(<span class="number">10</span>);</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.<span class="property">counter</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line">&gt; m.<span class="title function_">even</span>(<span class="number">20</span>)</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; m.<span class="property">counter</span></span><br><span class="line"><span class="number">17</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，参数<code>n</code>从 10 变为 0 的过程中，<code>even()</code>一共会执行 6 次，所以变量<code>counter</code>等于 6。第二次调用<code>even()</code>时，参数<code>n</code>从 20 变为 0，<code>even()</code>一共会执行 11 次，加上前面的 6 次，所以变量<code>counter</code>等于 17。</p>
<p>这个例子要是改写成 CommonJS，就根本无法执行，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// even.js</span></span><br><span class="line"><span class="keyword">var</span> odd = <span class="built_in">require</span>(<span class="string">&#x27;./odd&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">counter</span> = counter;</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">even</span> = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  counter++;</span><br><span class="line">  <span class="keyword">return</span> n == <span class="number">0</span> || <span class="title function_">odd</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// odd.js</span></span><br><span class="line"><span class="keyword">var</span> even = <span class="built_in">require</span>(<span class="string">&#x27;./even&#x27;</span>).<span class="property">even</span>;</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> n != <span class="number">0</span> &amp;&amp; <span class="title function_">even</span>(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>even.js</code>加载<code>odd.js</code>，而<code>odd.js</code>又去加载<code>even.js</code>，形成“循环加载”。这时，执行引擎就会输出<code>even.js</code>已经执行的部分（不存在任何结果），所以在<code>odd.js</code>之中，变量<code>even</code>等于<code>undefined</code>，等到后面调用<code>even(n - 1)</code>就会报错。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var m = require(<span class="string">&#x27;./even&#x27;</span>);</span><br><span class="line">&gt; m.even(10)</span><br><span class="line">TypeError: even is not a <span class="keyword">function</span></span><br></pre></td></tr></table></figure>

<h2 id="七、了解：AMD和CMD规范"><a href="#七、了解：AMD和CMD规范" class="headerlink" title="七、了解：AMD和CMD规范"></a>七、了解：AMD和CMD规范</h2><h3 id="7-1-CommonJS规范缺点"><a href="#7-1-CommonJS规范缺点" class="headerlink" title="7.1. CommonJS规范缺点"></a>7.1. CommonJS规范缺点</h3><p>CommonJS加载模块是同步的：</p>
<ul>
<li>同步的意味着只有等到对应的模块加载完毕，当前模块中的内容才能被运行；</li>
<li>这个在服务器不会有什么问题，因为服务器加载的js文件都是本地文件，加载速度非常快；</li>
</ul>
<p>如果将它应用于浏览器呢？</p>
<ul>
<li>浏览器加载js文件需要先从服务器将文件下载下来，之后在加载运行；</li>
<li>那么采用同步的就意味着后续的js代码都无法正常运行，即使是一些简单的DOM操作；</li>
</ul>
<p>所以在浏览器中，我们通常不使用CommonJS规范：</p>
<ul>
<li>当然在webpack中使用CommonJS是另外一回事；</li>
<li>因为它会将我们的代码转成浏览器可以直接执行的代码；</li>
</ul>
<p>在早期为了可以在浏览器中使用模块化，通常会采用AMD或CMD：</p>
<ul>
<li>但是目前一方面现代的浏览器已经支持ES Modules，另一方面借助于webpack等工具可以实现对CommonJS或者ES Module代码的转换；</li>
<li>AMD和CMD已经使用非常少了，所以这里我们进行简单的演练；</li>
</ul>
<h3 id="7-2-AMD规范"><a href="#7-2-AMD规范" class="headerlink" title="7.2. AMD规范"></a>7.2. AMD规范</h3><h4 id="7-2-1-AMD与Require-js"><a href="#7-2-1-AMD与Require-js" class="headerlink" title="7.2.1 AMD与Require.js"></a>7.2.1 AMD与Require.js</h4><p>AMD主要是应用于浏览器的一种模块化规范：</p>
<ul>
<li>AMD是Asynchronous Module Definition（异步模块定义）的缩写；</li>
<li>它采用的是异步加载模块；</li>
<li>事实上AMD的规范还要早于CommonJS，但是CommonJS目前依然在被使用，而AMD使用的较少了；</li>
</ul>
<p>我们提到过，规范只是定义代码的应该如何去编写，只有有了具体的实现才能被应用：</p>
<ul>
<li>AMD实现的比较常用的库是require.js和curl.js；</li>
</ul>
<h4 id="7-2-2-Require-js的使用"><a href="#7-2-2-Require-js的使用" class="headerlink" title="7.2.2 Require.js的使用"></a>7.2.2 Require.js的使用</h4><p>第一步：下载require.js</p>
<ul>
<li>下载地址：<a target="_blank" rel="noopener" href="https://github.com/requirejs/requirejs">https://github.com/requirejs/requirejs</a></li>
<li>找到其中的require.js文件； </li>
</ul>
<p>第二步：定义HTML的script标签引入require.js和定义入口文件：</p>
<ul>
<li>data-main属性的作用是在加载完src的文件后会加载执行该文件</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/require.js&quot;</span> <span class="attr">data-main</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第三步：编写如下目录和代码(<strong>个人习惯</strong>)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   └── require.js</span><br><span class="line">└── modules</span><br><span class="line">    ├── bar.js</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure>

<p>index.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="built_in">require</span>.<span class="title function_">config</span>(&#123;</span><br><span class="line">    <span class="attr">baseUrl</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">paths</span>: &#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="string">&#x27;./modules/foo&#x27;</span>,</span><br><span class="line">      <span class="attr">bar</span>: <span class="string">&#x27;./modules/bar&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 开始加载执行foo模块的代码</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;foo&#x27;</span>], <span class="keyword">function</span>(<span class="params">foo</span>) &#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>modules/bar.js</p>
<ul>
<li>如果一个模块不依赖其他，那么直接使用define(function)即可</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&quot;coderwhy&quot;</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">18</span>;</span><br><span class="line">  <span class="keyword">const</span> sayHello = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Hello &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    name,</span><br><span class="line">    age, </span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>modules/foo.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>([<span class="string">&#x27;bar&#x27;</span>], <span class="keyword">function</span>(<span class="params">bar</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">age</span>);</span><br><span class="line">  bar.<span class="title function_">sayHello</span>(<span class="string">&#x27;kobe&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="7-3-CMD规范"><a href="#7-3-CMD规范" class="headerlink" title="7.3 CMD规范"></a>7.3 CMD规范</h3><h4 id="7-3-1-CMD与SeaJS"><a href="#7-3-1-CMD与SeaJS" class="headerlink" title="7.3.1 CMD与SeaJS"></a>7.3.1 CMD与SeaJS</h4><p>CMD规范也是应用于浏览器的一种模块化规范：</p>
<ul>
<li>CMD 是Common Module Definition（通用模块定义）的缩写；</li>
<li>它也采用了异步加载模块，但是它将CommonJS的优点吸收了过来；</li>
<li>但是目前CMD使用也非常少了；</li>
</ul>
<p>CMD也有自己比较优秀的实现方案：</p>
<ul>
<li>SeaJS</li>
</ul>
<h4 id="7-3-2-SeaJS的使用"><a href="#7-3-2-SeaJS的使用" class="headerlink" title="7.3.2 SeaJS的使用"></a>7.3.2 SeaJS的使用</h4><h5 id="1-下载SeaJS"><a href="#1-下载SeaJS" class="headerlink" title="1. 下载SeaJS"></a>1. 下载SeaJS</h5><ul>
<li>下载地址：<a target="_blank" rel="noopener" href="https://github.com/seajs/seajs">https://github.com/seajs/seajs</a></li>
<li>找到dist文件夹下的sea.js</li>
</ul>
<h5 id="2-引入sea-js和启动模块"><a href="#2-引入sea-js和启动模块" class="headerlink" title="2. 引入sea.js和启动模块"></a>2. 引入sea.js和启动模块</h5><ul>
<li><code>seajs</code>是指定主入口文件的，也称为启动模块</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/sea.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span> <span class="comment">&lt;!--在调用 seajs 之前，必须先引入 sea.js 文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  seajs.<span class="title function_">use</span>(<span class="string">&#x27;./index.js&#x27;</span>);  </span></span><br><span class="line"><span class="language-javascript">  <span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">   通过 seajs.use() 函数可以启动模块</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		- (&#x27;模块id&#x27; [,callback])	加载一个模块，并执行回调函数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		- ([&#x27;模块1&#x27;, &#x27;模块2&#x27;] [,callback])	加载多个模块，并执行回调函数</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		- callback 参数是可选的。格式为：function( 模块对象 )&#123; 业务代码 &#125;;</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">		</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">	 - seajs.use 理论上只用于加载启动，不应该出现在 define 中的模块代码里</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">	 - seajs.use 和 DOM ready 事件没有任何关系。要想保证 文档结构加载完毕再执行你的 js 代码，一定要在seajs.use内部通过 window.onload 或者 $(function()&#123;&#125;)</span></span></span><br><span class="line"><span class="comment"><span class="language-javascript">   */</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="3-编写如下目录和代码-个人习惯"><a href="#3-编写如下目录和代码-个人习惯" class="headerlink" title="3. 编写如下目录和代码(个人习惯)"></a>3. 编写如下目录和代码(<strong>个人习惯</strong>)</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── index.html</span><br><span class="line">├── index.js</span><br><span class="line">├── lib</span><br><span class="line">│   └── sea.js</span><br><span class="line">└── modules</span><br><span class="line">    ├── bar.js</span><br><span class="line">    └── foo.js</span><br></pre></td></tr></table></figure>

<h5 id="4-定义模块define"><a href="#4-定义模块define" class="headerlink" title="4. 定义模块define"></a>4. 定义模块define</h5><p>在CMD规范中，一个模块就是一个js文件。</p>
<p>module是一个对象，存储了模块的元信息，具体如下：</p>
<ul>
<li>module.id——模块的ID。</li>
<li>module.dependencies——一个数组，存储了此模块依赖的所有模块的ID列表。</li>
<li>module.exports——与exports指向同一个对象。</li>
<li>module.uri</li>
</ul>
<p>define 是一个全局函数，用来定义模块：<code>define( factory )</code></p>
<ul>
<li>对象<code>&#123;&#125;</code>：这种方式，外部会直接获取到该对象</li>
<li>字符串<code>&quot;&quot;</code>： 同上</li>
<li>函数：<code>define(function(require, exports, module)&#123; 模块代码 &#125;);</code>  为了减少出错，定义函数的时候直接把这三个参数写上</li>
</ul>
<h5 id="5-导出接口exports和module-exports"><a href="#5-导出接口exports和module-exports" class="headerlink" title="5. 导出接口exports和module.exports"></a>5. 导出接口exports和module.exports</h5><ul>
<li>功能：通过给 exports或module.exports动态的挂载变量、函数或对象，外部会获取到该接口</li>
<li>exports 等价于 module.exports。exports能做什么，module.exports就能做什么</li>
<li>可以通过多次给exports 挂载属性向外暴露</li>
<li>不能直接给 exports 赋值</li>
<li>如果想暴露单个变量、函数或对象可以通过直接给 module.exports 赋值 即可</li>
</ul>
<h5 id="6-依赖模块require"><a href="#6-依赖模块require" class="headerlink" title="6. 依赖模块require"></a>6. 依赖模块require</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 模块标识/模块id</span></span><br><span class="line"><span class="comment">    - 模块标识就是一个`字符串`，用来`标识模块`</span></span><br><span class="line"><span class="comment">    - 模块标识 可以不包含后缀名.js</span></span><br><span class="line"><span class="comment">    - 以 ./或 ../ 开头的相对路径模块，相对于 require 所在模块的路径</span></span><br><span class="line"><span class="comment">    - 不以 ./ 或 ../ 开头的顶级标识，会相对于模块的基础路径解析（配置项中的base）</span></span><br><span class="line"><span class="comment">    - 绝对路径如http://127.0.0.1:8080/js/a.js、/js/a.js</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title function_">requeire</span>(<span class="string">&#x27;模块id&#x27;</span>)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1.用于根据一个模块id加载/依赖该模块</span></span><br><span class="line"><span class="comment"> 2.参数必须是一个字符串</span></span><br><span class="line"><span class="comment"> 3.该方法会得到 要加载的模块中的 module.exports 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<ul>
<li>只能在模块环境define中使用，define(factory)的构造方法第一个参数<strong>必须命名为 require</strong></li>
<li>不要重命名require函数或者在任何作用域中给 require 重新赋值</li>
<li>在一个模块系统中，<code>require</code> 加载过的模块会被缓存</li>
<li>默认 <code>require</code> 是同步加载模块的</li>
</ul>
<p><strong>require.async</strong></p>
<p>SeaJS会在html页面打开时通过静态分析一次性记载所有需要的js文件，如果想要某个js文件在用到时才下载，可以使用require.async：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.<span class="title function_">async</span>(<span class="string">&#x27;/path/to/module/file&#x27;</span>, <span class="keyword">function</span>(<span class="params">m</span>) &#123;</span><br><span class="line">    <span class="comment">//code of callback...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这样只有在用到这个模块时，对应的js文件才会被下载，也就实现了JavaScript代码的按需加载。</p>
<h5 id="SeaJS高级配置"><a href="#SeaJS高级配置" class="headerlink" title="SeaJS高级配置"></a>SeaJS高级配置</h5><ul>
<li><strong>alias：别名配置</strong></li>
<li><strong>paths：路径配置</strong></li>
<li>vars：变量配置</li>
<li>map：映射配置</li>
<li>preload：预加载项</li>
<li>debug：调试模式</li>
<li><strong>base：基础路径</strong></li>
<li>charset：文件编码</li>
</ul>
<h5 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h5><p>index.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> foo = <span class="built_in">require</span>(<span class="string">&#x27;./modules/foo&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>bar.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;lilei&#x27;</span>;</span><br><span class="line">  <span class="keyword">const</span> age = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">const</span> sayHello = <span class="keyword">function</span>(<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;你好 &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    name,</span><br><span class="line">    age,</span><br><span class="line">    sayHello</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>foo.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">define</span>(<span class="keyword">function</span>(<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="variable language_">module</span></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> bar = <span class="built_in">require</span>(<span class="string">&#x27;./bar&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(bar.<span class="property">age</span>);</span><br><span class="line">  bar.<span class="title function_">sayHello</span>(<span class="string">&quot;韩梅梅&quot;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="八、参考链接"><a href="#八、参考链接" class="headerlink" title="八、参考链接"></a>八、参考链接</h2><ul>
<li><a target="_blank" rel="noopener" href="https://es6.ruanyifeng.com/#docs/module">Module的语法和加载实现 — 阮一峰</a></li>
<li><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=Mzg5MDAzNzkwNA==&mid=2247484285&idx=1&sn=bc37c00b5c58ff42355b1b01ad9b9c0d&chksm=cfe3f082f8947994b5475d365c4460ac0d4b36d6eec68b5dd7c15fc3a0ef1b88f33b776f3f05&scene=178&cur_album_id=1567316742547226629#rd">彻底掌握前端模块化 — codewhy</a></li>
</ul>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="https://tenloy.github.io">Tenloy</a>
            <p>原文链接：<a href="https://tenloy.github.io/2021/06/06/Web-Module.html">https://tenloy.github.io/2021/06/06/Web-Module.html</a>
            <p>发表日期：2021.06.06 , 11:09 AM</p>
            <p>更新日期：2023.03.30 , 8:10 PM</p>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Crative Commons 4.0 许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2021/06/15/datastruction-overview.html" title= "数据结构与算法概述">
                    <div class="nextTitle">数据结构与算法概述</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2021/05/27/Fiber.html" title= "[转] 最通俗的 React Fiber(时间分片)">
                    <div class="prevTitle">[转] 最通俗的 React Fiber(时间分片)</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:luotengoto@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/Tenloy" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <a href="https://www.jianshu.com/u/8db1bc12db9f" class="iconfont-jian jianshu" target="_blank" title=jianshu></a>
            
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:40vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">一、模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">1.1 什么是模块化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-JavaScript%E8%AE%BE%E8%AE%A1%E7%BC%BA%E9%99%B7"><span class="toc-text">1.2 JavaScript设计缺陷</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E6%B2%A1%E6%9C%89%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84JavaScript"><span class="toc-text">1.3 没有模块化的JavaScript</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88"><span class="toc-text">1.3.1 技术方案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E9%97%AE%E9%A2%98%E4%B8%BE%E4%BE%8B"><span class="toc-text">1.3.2 问题举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-IIFE%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-text">1.3.3 IIFE的缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-JavaScript%E4%B8%AD%E6%A8%A1%E5%9D%97%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-text">1.4 JavaScript中模块化方案</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81CommonJS%E8%A7%84%E8%8C%83"><span class="toc-text">二、CommonJS规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-CommonJS%E5%92%8CNode"><span class="toc-text">2.1 CommonJS和Node</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-Node%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AF%AD%E6%B3%95"><span class="toc-text">2.2 Node模块化语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-1-%E6%A8%A1%E5%9D%97"><span class="toc-text">2.2.1 模块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-2-exports%E5%AF%BC%E5%87%BA"><span class="toc-text">2.2.2 exports导出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-3-module-exports"><span class="toc-text">2.2.3 module.exports</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-4-require"><span class="toc-text">2.2.4 require</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-require%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%8E%9F%E7%90%86"><span class="toc-text">1. require的加载原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-require%E7%9A%84%E6%9F%A5%E6%89%BE%E8%A7%84%E5%88%99"><span class="toc-text">2. require的查找规则</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-require%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F"><span class="toc-text">3. require的加载顺序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-Node%E7%9A%84%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90"><span class="toc-text">2.3 Node的源码解析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81ES6-Module"><span class="toc-text">三、ES6 Module</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E8%AE%A4%E8%AF%86ES6-Module"><span class="toc-text">3.1 认识ES6 Module</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-ES6-Module%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text">3.1.1 ES6 Module的优势</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F"><span class="toc-text">3.1.2 自动启动严格模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E5%8A%A0%E8%BD%BDES6-Module"><span class="toc-text">3.1.3 浏览器中加载ES6 Module</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8A%A0%E8%BD%BD%E6%99%AE%E9%80%9Ajs%E6%96%87%E4%BB%B6"><span class="toc-text">1. 加载普通js文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%8A%A0%E8%BD%BDES6-Module"><span class="toc-text">2. 加载ES6 Module</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-%E6%9C%AC%E5%9C%B0%E6%B5%8F%E8%A7%88%E7%9A%84%E6%8A%A5%E9%94%99"><span class="toc-text">3.1.4 本地浏览的报错</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-ES6-Module%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">3.2 ES6 Module的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-1-%E6%A8%A1%E5%9D%97%E4%B8%8ECommonJS%E6%A8%A1%E5%9D%97%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text">3.2.1 模块与CommonJS模块的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%9B%B8%E5%90%8C%E7%82%B9"><span class="toc-text">1. 相同点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%BC%E5%87%BA%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-text">2. 导出的不同</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%AF%BC%E5%85%A5%E7%9A%84%E4%B8%8D%E5%90%8C"><span class="toc-text">3. 导入的不同</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-2-export"><span class="toc-text">3.2.2 export</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-export-lt-decl-gt"><span class="toc-text">1. export &lt;decl&gt;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-export"><span class="toc-text">2. export {}</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-export-lt-gt-as-lt-gt"><span class="toc-text">3. export {&lt;&gt; as &lt;&gt;}</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-export%E5%AF%BC%E5%87%BA%E7%9A%84%E6%98%AF%E6%A0%87%E8%AF%86%E7%AC%A6%E7%9A%84%E5%9C%B0%E5%9D%80"><span class="toc-text">4. export导出的是标识符的地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-export%E5%AF%BC%E5%87%BA%E5%90%8C%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-text">5. export导出同一个实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-export%E4%B9%A6%E5%86%99%E4%BD%8D%E7%BD%AE"><span class="toc-text">6. export书写位置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-export%E4%B9%A6%E5%86%99%E6%AC%A1%E6%95%B0"><span class="toc-text">7. export书写次数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-3-import"><span class="toc-text">3.2.3 import</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-import-from-39-39"><span class="toc-text">1. import {} from &#39;&#39;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-import-39-39-%E7%9A%84%E5%90%AB%E4%B9%89"><span class="toc-text">1. import &#39;&#39;的含义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-import-lt-gt-as-lt-gt-from-39-39"><span class="toc-text">2.  import {&lt;&gt; as &lt;&gt;} from &#39;&#39;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-import-as-lt-gt-from-39-39"><span class="toc-text">3.  import * as &lt;&gt; from &#39;&#39;</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-import%E5%AF%BC%E5%85%A5%E4%B8%BA%E5%8F%AA%E8%AF%BB"><span class="toc-text">4. import导入为只读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-import-from%E5%90%8E%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="toc-text">5. import from后的路径</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-import%E5%91%BD%E4%BB%A4%E7%9A%84%E6%8F%90%E5%8D%87"><span class="toc-text">6. import命令的提升</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-import%E4%B8%AD%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%92%8C%E5%8F%98%E9%87%8F"><span class="toc-text">7. import中不能使用表达式和变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-4-export-default"><span class="toc-text">3.2.4 export default</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%AF%BC%E5%87%BA%E4%B8%8E%E5%AF%BC%E5%85%A5%E6%A0%BC%E5%BC%8F"><span class="toc-text">2. 导出与导入格式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-export-default%E7%9A%84%E6%9C%AC%E8%B4%A8"><span class="toc-text">3. export default的本质</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-export-default%E4%B8%8Eexport"><span class="toc-text">4. export default与export</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-5-export%E5%92%8Cimport%E7%BB%93%E5%90%88"><span class="toc-text">3.2.5 export和import结合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-6-import"><span class="toc-text">3.2.6 import()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-import-%E7%9A%84%E8%83%8C%E6%99%AF"><span class="toc-text">1. import()的背景</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AF%AD%E6%B3%95"><span class="toc-text">2. 语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E9%80%82%E7%94%A8%E5%9C%BA%E5%90%88"><span class="toc-text">3. 适用场合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-7-%E5%BA%94%E7%94%A8-%E5%85%AC%E5%85%B1%E5%A4%B4%E6%96%87%E4%BB%B6"><span class="toc-text">3.2.7 应用: 公共头文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-8-%E4%B8%8ECommonJS%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%B7%AE%E5%BC%82"><span class="toc-text">3.2.8 与CommonJS模块化的差异</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81CommonJS%E6%A8%A1%E5%9D%97%E4%B8%8EES6%E6%A8%A1%E5%9D%97%E7%9A%84%E6%B7%B7%E7%BC%96"><span class="toc-text">四、CommonJS模块与ES6模块的混编</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-CommonJS%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BDES6%E6%A8%A1%E5%9D%97"><span class="toc-text">4.1 CommonJS模块加载ES6模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-ES6%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BDCommonJS%E6%A8%A1%E5%9D%97"><span class="toc-text">4.2 ES6模块加载CommonJS模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E4%BD%BF%E6%A8%A1%E5%9D%97%E5%90%8C%E6%97%B6%E6%94%AF%E6%8C%81%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%9D%97%E5%8C%96%E5%AF%BC%E5%85%A5"><span class="toc-text">4.3 使模块同时支持两种模块化导入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Node-js%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96"><span class="toc-text">五、Node.js开发中的模块化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-Node%E4%B8%AD%E6%94%AF%E6%8C%81-ES6-Module"><span class="toc-text">5.1 Node中支持 ES6 Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-Node-js%E5%8C%85%E6%A8%A1%E5%9D%97%E7%9A%84%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%E8%AE%BE%E7%BD%AE"><span class="toc-text">5.2 Node.js包模块的入口文件设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-1-package-json-%E7%9A%84-main-%E5%AD%97%E6%AE%B5"><span class="toc-text">5.2.1 package.json 的 main 字段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B%EF%BC%9A%E6%8C%87%E5%AE%9A%E5%85%A5%E5%8F%A3%E6%96%87%E4%BB%B6%EF%BC%8C%E6%A0%BC%E5%BC%8F%E4%B8%BAESM"><span class="toc-text">举例：指定入口文件，格式为ESM</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-2-package-json-%E7%9A%84-exports-%E5%AD%97%E6%AE%B5"><span class="toc-text">5.2.2 package.json 的 exports 字段</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%BB%99%E8%84%9A%E6%9C%AC%E6%88%96%E5%AD%90%E7%9B%AE%E5%BD%95%E8%B5%B7%E5%88%AB%E5%90%8D"><span class="toc-text">1. 给脚本或子目录起别名</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-main-%E7%9A%84%E5%88%AB%E5%90%8D"><span class="toc-text">2. main 的别名.</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%9D%A1%E4%BB%B6%E5%8A%A0%E8%BD%BD"><span class="toc-text">3. 条件加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-Node-js%E5%8E%9F%E7%94%9F%E6%A8%A1%E5%9D%97%E5%AE%8C%E5%85%A8%E6%94%AF%E6%8C%81ES6-Module"><span class="toc-text">5.3 Node.js原生模块完全支持ES6 Module</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E5%8A%A0%E8%BD%BD%E8%B7%AF%E5%BE%84"><span class="toc-text">5.4 加载路径</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-text">5.5 内部变量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD"><span class="toc-text">六、循环加载</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-CommonJS-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD"><span class="toc-text">6.1 CommonJS 模块的循环加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-ES6-%E6%A8%A1%E5%9D%97%E7%9A%84%E5%BE%AA%E7%8E%AF%E5%8A%A0%E8%BD%BD"><span class="toc-text">6.2 ES6 模块的循环加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">6.3 代码示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E4%BA%86%E8%A7%A3%EF%BC%9AAMD%E5%92%8CCMD%E8%A7%84%E8%8C%83"><span class="toc-text">七、了解：AMD和CMD规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-CommonJS%E8%A7%84%E8%8C%83%E7%BC%BA%E7%82%B9"><span class="toc-text">7.1. CommonJS规范缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-AMD%E8%A7%84%E8%8C%83"><span class="toc-text">7.2. AMD规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-AMD%E4%B8%8ERequire-js"><span class="toc-text">7.2.1 AMD与Require.js</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-Require-js%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.2.2 Require.js的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-CMD%E8%A7%84%E8%8C%83"><span class="toc-text">7.3 CMD规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-1-CMD%E4%B8%8ESeaJS"><span class="toc-text">7.3.1 CMD与SeaJS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-2-SeaJS%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text">7.3.2 SeaJS的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%8B%E8%BD%BDSeaJS"><span class="toc-text">1. 下载SeaJS</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%BC%95%E5%85%A5sea-js%E5%92%8C%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">2. 引入sea.js和启动模块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%BC%96%E5%86%99%E5%A6%82%E4%B8%8B%E7%9B%AE%E5%BD%95%E5%92%8C%E4%BB%A3%E7%A0%81-%E4%B8%AA%E4%BA%BA%E4%B9%A0%E6%83%AF"><span class="toc-text">3. 编写如下目录和代码(个人习惯)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%AE%9A%E4%B9%89%E6%A8%A1%E5%9D%97define"><span class="toc-text">4. 定义模块define</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%AF%BC%E5%87%BA%E6%8E%A5%E5%8F%A3exports%E5%92%8Cmodule-exports"><span class="toc-text">5. 导出接口exports和module.exports</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E4%BE%9D%E8%B5%96%E6%A8%A1%E5%9D%97require"><span class="toc-text">6. 依赖模块require</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#SeaJS%E9%AB%98%E7%BA%A7%E9%85%8D%E7%BD%AE"><span class="toc-text">SeaJS高级配置</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B"><span class="toc-text">代码示例</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">八、参考链接</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    
    
    
    
        <span class="sidebar-category-name" data-categories="数据结构与算法"><span class="iconfont-archer">&#xe60a;</span>数据结构与算法</span>
    
        <span class="sidebar-category-name" data-categories="计算机组成原理"><span class="iconfont-archer">&#xe60a;</span>计算机组成原理</span>
    
        <span class="sidebar-category-name" data-categories="计算机网络"><span class="iconfont-archer">&#xe60a;</span>计算机网络</span>
    
        <span class="sidebar-category-name" data-categories="汇编语言"><span class="iconfont-archer">&#xe60a;</span>汇编语言</span>
    
        <span class="sidebar-category-name" data-categories="数据的存储与传输"><span class="iconfont-archer">&#xe60a;</span>数据的存储与传输</span>
    
        <span class="sidebar-category-name" data-categories="操作系统"><span class="iconfont-archer">&#xe60a;</span>操作系统</span>
    
        <span class="sidebar-category-name" data-categories="互联网标准RFC"><span class="iconfont-archer">&#xe60a;</span>互联网标准RFC</span>
    
        <span class="sidebar-category-name" data-categories="编译链接与装载"><span class="iconfont-archer">&#xe60a;</span>编译链接与装载</span>
    
        <span class="sidebar-category-name" data-categories="iOS"><span class="iconfont-archer">&#xe60a;</span>iOS</span>
    
        <span class="sidebar-category-name" data-categories="架构与设计模式"><span class="iconfont-archer">&#xe60a;</span>架构与设计模式</span>
    
        <span class="sidebar-category-name" data-categories="图形处理与渲染"><span class="iconfont-archer">&#xe60a;</span>图形处理与渲染</span>
    
        <span class="sidebar-category-name" data-categories="软件工程"><span class="iconfont-archer">&#xe60a;</span>软件工程</span>
    
        <span class="sidebar-category-name" data-categories="音视频处理"><span class="iconfont-archer">&#xe60a;</span>音视频处理</span>
    
        <span class="sidebar-category-name" data-categories="DSL"><span class="iconfont-archer">&#xe60a;</span>DSL</span>
    
        <span class="sidebar-category-name" data-categories="Swift"><span class="iconfont-archer">&#xe60a;</span>Swift</span>
    
        <span class="sidebar-category-name" data-categories="Git"><span class="iconfont-archer">&#xe60a;</span>Git</span>
    
        <span class="sidebar-category-name" data-categories="Web"><span class="iconfont-archer">&#xe60a;</span>Web</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 76
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-side-search"> 
                <span class="iconfont-jian search-icon">&#xe7fc;搜索</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2022 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span><a class="archive-post-title" href= "/2022/05/05/sqlite.html" >iOS SQLite的使用与优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href= "/2022/04/28/mmap.html" >内存映射mmap函数的原理与应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/18</span><a class="archive-post-title" href= "/2022/03/18/avfoundation.html" >AVFoundation Programming Guide(译)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span><a class="archive-post-title" href= "/2022/03/17/avframework.html" >iOS音视频库概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2022/02/09/OAuth.html" >[转] OAuth 2.0简述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/18</span><a class="archive-post-title" href= "/2022/01/18/wkwebview-buges.html" >WKWebView使用过程中遇到的坑</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/22</span><a class="archive-post-title" href= "/2021/11/22/bit-calculation.html" >[转] 位运算实现加、减、乘、除运算</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span><a class="archive-post-title" href= "/2021/11/10/git-use.html" >Git的使用总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/21</span><a class="archive-post-title" href= "/2021/10/21/dyld-objc.html" >(七) dyld与Objc—_objc_init、map_images、load_images</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/18</span><a class="archive-post-title" href= "/2021/10/18/compile-dynamic-link.html" >(六) Mach-O 文件的动态链接、库、Dyld(含dlopen)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/14</span><a class="archive-post-title" href= "/2021/10/14/compile-vm-asrl.html" >(五) Mach-O 文件之进程(虚拟)地址空间、ASLR</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span><a class="archive-post-title" href= "/2021/10/10/compile-load.html" >(四) Mach-O 文件的装载</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/08</span><a class="archive-post-title" href= "/2021/10/08/compile-static-link.html" >(三) Mach-O 文件的静态链接</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/06</span><a class="archive-post-title" href= "/2021/10/06/compile-macho.html" >(二) Mach-O 文件结构</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2021/10/05/compile-clang-llvm.html" >(一) Clang/LLVM 介绍、OC 程序的编译过程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/02</span><a class="archive-post-title" href= "/2021/10/02/makefile.html" >[转] Make 命令的使用与NodeJS案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/2021/09/28/architectural-pattern.html" >常见架构模式: MVC、MVP、MVVM、VIPER</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href= "/2021/09/25/design-pattern.html" >常见的设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href= "/2021/09/20/program-thought.html" >常见的编程范式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing-case.html" >图形处理(三) - 图形处理实践案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing.html" >图形处理(二) - 图形与视频处理相关的框架</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2021/09/13/image-encode-decode.html" >图形处理(一) - 图片的加载与编解码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/12</span><a class="archive-post-title" href= "/2021/09/12/iOS-Render.html" >[转] iOS离屏渲染原理及优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2021/09/11/core-animation03.html" >Core-Animation(三) - 渲染流程探究及性能分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/09</span><a class="archive-post-title" href= "/2021/09/09/core-animation02.html" >Core Animation(二) - 隐式动画、CATransaction与CAAction</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/07</span><a class="archive-post-title" href= "/2021/09/07/core-animation01.html" >Core Animation(一) - UIView与CALayer、布局与绘制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span><a class="archive-post-title" href= "/2021/09/05/AFN-Analyse.html" >[转] AFN框架实现解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/04</span><a class="archive-post-title" href= "/2021/09/04/nrl-session.html" >NSURLSession概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2021/09/02/Log.html" >移动端日志库设计</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href= "/2021/08/01/Crash-Monitor.html" >iOS崩溃监控与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2021/07/30/Lag-Monitor.html" >iOS卡顿监控</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/SwiftUI.html" >SwiftUI</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/Swift-Version-History.html" >Swift版本更新API介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/26</span><a class="archive-post-title" href= "/2021/07/26/RunLoop-Reposted-From-ibireme.html" >[转] 深入理解RunLoop—ibireme</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2021/07/25/Protocol-Buffer.html" >Protocol Buffer的基本介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href= "/2021/07/24/base64.html" >Base64编码及iOS中的Base64</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span><a class="archive-post-title" href= "/2021/07/23/chinese-encode.html" >[转] 彻底弄懂常见的7种中文字符编码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/10</span><a class="archive-post-title" href= "/2021/07/10/p-npc-np.html" >P问题、NP问题、NPC、NP-Hard、P=NP?</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href= "/2021/06/30/probability.html" >(六) 概率算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/28</span><a class="archive-post-title" href= "/2021/06/28/branch-bound.html" >(五) 分支限界算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/26</span><a class="archive-post-title" href= "/2021/06/26/back-track.html" >(四) 回溯法(试探算法)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/24</span><a class="archive-post-title" href= "/2021/06/24/greed.html" >(三) 贪心算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/22</span><a class="archive-post-title" href= "/2021/06/22/dynamic-programming.html" >(二) 动态规划算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href= "/2021/06/20/divide-and-conquer.html" >(一) 分治算法及减治、变治算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span><a class="archive-post-title" href= "/2021/06/18/several-programming.html" >穷举、递推、迭代(辗转法)、递归算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/15</span><a class="archive-post-title" href= "/2021/06/15/datastruction-overview.html" >数据结构与算法概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/06</span><a class="archive-post-title" href= "/2021/06/06/Web-Module.html" >前端各种模块化方案总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Fiber.html" >[转] 最通俗的 React Fiber(时间分片)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Coroutine.html" >[转] 什么是协程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href= "/2021/05/19/DSL.html" >[转] 谈谈DSL以及DSL的应用（以CocoaPods 为例）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href= "/2021/05/03/iOS-private-pod.html" >私有Pod库部署</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/29</span><a class="archive-post-title" href= "/2021/04/29/iOS-ComRouter.html" >[转] iOS的组件化方案</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/27</span><a class="archive-post-title" href= "/2021/04/27/iOS-CI.html" >iOS的持续集成</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/26</span><a class="archive-post-title" href= "/2021/04/26/Containers.html" >常见的容器概念：Linux容器、Docker容器、服务器容器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span><a class="archive-post-title" href= "/2021/04/24/Dock-Reprinted-from-RuanYIFeng.html" >[转] Docker入门教程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span><a class="archive-post-title" href= "/2021/04/20/Sync-Async.html" >同步和异步解读及编程中的使用场景</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span><a class="archive-post-title" href= "/2021/04/17/Arm64-Handbook.html" >ARM64指令简易手册</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span><a class="archive-post-title" href= "/2021/04/16/Arm64-Introduce.html" >iOS需要了解的ARM64汇编</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span><a class="archive-post-title" href= "/2021/04/13/Command-Line.html" >CLI Shell、Terminal、脚本(语言)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href= "/2021/04/10/Ins-SysCall-Kernel-Shell.html" >指令、系统调用、库、Shell、APP的层次关系</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span><a class="archive-post-title" href= "/2021/04/08/ISA-Microarch-Soc.html" >指令集、微架构、手机芯片(Soc)及ARM的介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span><a class="archive-post-title" href= "/2021/04/02/Engineering.html" >工程化、动态化、容器化、组件化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2021/04/01/GithubPages-Hexo.html" >使用Hexo+Github Pages搭建个人博客</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/22</span><a class="archive-post-title" href= "/2020/12/22/aes.html" >数据加密 — 对称加密(以AES为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href= "/2020/12/21/aes-standard.html" >[转] AES标准及Rijndael算法解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span><a class="archive-post-title" href= "/2020/12/20/asymmetric.html" >数据加密 — 非对称加密(加签/加密，以RSA为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/09</span><a class="archive-post-title" href= "/2020/12/09/pki.html" >常见的PKI标准(X.509、PKCS)及证书相关介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href= "/2020/10/28/runtime-data-structure.html" >Objc Runtime总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2020/09/11/GCD.html" >Objective-C — 深入浅出GCD常用API</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/06</span><a class="archive-post-title" href= "/2020/09/06/oc-block.html" >Objective-C — Block</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/26</span><a class="archive-post-title" href= "/2020/08/26/AutoreleasePool.html" >AutoreleasePool</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/24</span><a class="archive-post-title" href= "/2020/08/24/oc-memory-manage.html" >Objective-C — 内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href= "/2020/08/01/ui-navigation-bar.html" >[转] 导航栏的架构介绍及使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/15</span><a class="archive-post-title" href= "/2020/07/15/symbol-decl.html" >变量声明、函数声明的作用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2020/07/01/ios-apns.html" >iOS APNS接收逻辑梳理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/2020/06/13/ios-vest.html" >iOS制作马甲总结</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="AutoreleasePool"><span class="iconfont-archer">&#xe606;</span>AutoreleasePool</span>
    
        <span class="sidebar-tag-name" data-tags="GCD"><span class="iconfont-archer">&#xe606;</span>GCD</span>
    
        <span class="sidebar-tag-name" data-tags="hexo"><span class="iconfont-archer">&#xe606;</span>hexo</span>
    
        <span class="sidebar-tag-name" data-tags="ISA"><span class="iconfont-archer">&#xe606;</span>ISA</span>
    
        <span class="sidebar-tag-name" data-tags="Microarch"><span class="iconfont-archer">&#xe606;</span>Microarch</span>
    
        <span class="sidebar-tag-name" data-tags="Soc"><span class="iconfont-archer">&#xe606;</span>Soc</span>
    
        <span class="sidebar-tag-name" data-tags="CLI"><span class="iconfont-archer">&#xe606;</span>CLI</span>
    
        <span class="sidebar-tag-name" data-tags="Shell"><span class="iconfont-archer">&#xe606;</span>Shell</span>
    
        <span class="sidebar-tag-name" data-tags="Docker"><span class="iconfont-archer">&#xe606;</span>Docker</span>
    
        <span class="sidebar-tag-name" data-tags="ARM64"><span class="iconfont-archer">&#xe606;</span>ARM64</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="DSL"><span class="iconfont-archer">&#xe606;</span>DSL</span>
    
        <span class="sidebar-tag-name" data-tags="协程"><span class="iconfont-archer">&#xe606;</span>协程</span>
    
        <span class="sidebar-tag-name" data-tags="Fiber"><span class="iconfont-archer">&#xe606;</span>Fiber</span>
    
        <span class="sidebar-tag-name" data-tags="dp"><span class="iconfont-archer">&#xe606;</span>dp</span>
    
        <span class="sidebar-tag-name" data-tags="RunLoop"><span class="iconfont-archer">&#xe606;</span>RunLoop</span>
    
        <span class="sidebar-tag-name" data-tags="SwiftUI"><span class="iconfont-archer">&#xe606;</span>SwiftUI</span>
    
        <span class="sidebar-tag-name" data-tags="Swift-Syntax"><span class="iconfont-archer">&#xe606;</span>Swift-Syntax</span>
    
        <span class="sidebar-tag-name" data-tags="LagMonitor"><span class="iconfont-archer">&#xe606;</span>LagMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="CrashMonitor"><span class="iconfont-archer">&#xe606;</span>CrashMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="Log"><span class="iconfont-archer">&#xe606;</span>Log</span>
    
        <span class="sidebar-tag-name" data-tags="AFN"><span class="iconfont-archer">&#xe606;</span>AFN</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Tenloy"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


