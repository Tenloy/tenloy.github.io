<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Tenloy">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Tenloy">
    
    <meta name="keywords" content="Tenloy,iOS,Swift">
    
    <meta name="description" content="学习 生活 记录 回忆">
    <meta name="description" content="原文链接 — AFNetworking到底做了什么？，有一些细节修改     作为一个iOS开发，也许你不知道NSUrlRequest、不知道NSUrlConnection、也不知道NSURLSession…（说不下去了…怎么会什么都不知道…）但是你一定知道AFNetworking。 大多数人习惯了只要是请求网络都用AF，但是你真的知道AF做了什么吗？为什么我们不用原生的NSURLSession">
<meta property="og:type" content="article">
<meta property="og:title" content="[转] AFN框架实现解析">
<meta property="og:url" content="https://tenloy.github.io/2021/09/05/AFN-Analyse.html">
<meta property="og:site_name" content="Tenloy&#39;s Blog">
<meta property="og:description" content="原文链接 — AFNetworking到底做了什么？，有一些细节修改     作为一个iOS开发，也许你不知道NSUrlRequest、不知道NSUrlConnection、也不知道NSURLSession…（说不下去了…怎么会什么都不知道…）但是你一定知道AFNetworking。 大多数人习惯了只要是请求网络都用AF，但是你真的知道AF做了什么吗？为什么我们不用原生的NSURLSession">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-01.png">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-02.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-03.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-04.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-05.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-06.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-07.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-08.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-09.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-10.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-11.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/AFN/AFN-12.jpg">
<meta property="article:published_time" content="2021-09-05T00:53:12.000Z">
<meta property="article:modified_time" content="2024-04-07T12:02:59.000Z">
<meta property="article:author" content="Tenloy">
<meta property="article:tag" content="AFN">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tenloy.github.io/images/AFN/AFN-01.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>[转] AFN框架实现解析 · Tenloy&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"Search for Posts","hits_empty":"没有找到任何搜索结果: ${query}","hits_stats":"找到约${hits}条结果（用时${time}ms）"}')

            var algolia = {
                applicationID: 'V0HYXBS9FB',
                apiKey: '6550d5de786935564142097c3e78c380',
                indexName: 'law_blog_index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Tenloy's Blog" type="application/atom+xml">
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Tenloy&#39;s Blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">[转] AFN框架实现解析</a>
            </div>
    </div>
    
    <!-- 将home-link的操作改为应用到header-top-right上 -->
    <div class="header-top-right">
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-search">
                <span class="iconfont-jian tl-search-icon">&#xe7fc;搜索</span>
            </div>
            
        <a class="home-link" href=/>Tenloy's Blog</a>
    </div>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:40vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            [转] AFN框架实现解析
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "AFN">AFN</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">38.5k</span>Reading time: <span class="post-count reading-time">160 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2021/09/05</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/856f0e26279d">原文链接 — AFNetworking到底做了什么？</a>，有一些细节修改</p>
</blockquote>
<img src="/images/AFN/AFN-01.png" alt="img" style="zoom:70%;" />

<ul>
<li>作为一个iOS开发，也许你不知道NSUrlRequest、不知道NSUrlConnection、也不知道NSURLSession…（说不下去了…怎么会什么都不知道…）但是你一定知道AFNetworking。</li>
<li>大多数人习惯了只要是请求网络都用AF，但是你真的知道AF做了什么吗？为什么我们不用原生的NSURLSession而选择AFNetworking?</li>
<li>本文将从源码的角度去分析AF的实际作用。 <strong>或许看完这篇文章，你心里会有一个答案。</strong></li>
</ul>
<h1 id="一、框架结构"><a href="#一、框架结构" class="headerlink" title="一、框架结构"></a>一、框架结构</h1><p>先从最新的AF3.x讲起吧：</p>
<p>首先，我们就一起分析一下该框架的组成。 将AF下载导入工程后，下面是AF代码结构图，相对于2.x变得非常简单了：</p>
<img src="/images/AFN/AFN-02.jpg" alt="img" style="zoom:60%;" />

<p>除去Support Files，可以看到AF分为如下5个功能模块：</p>
<ul>
<li>网络通信模块(AFURLSessionManager、AFHTTPSessionManger)</li>
<li>网络状态监听模块(Reachability)</li>
<li>网络通信安全策略模块(Security)</li>
<li>网络通信信息序列化/反序列化模块(Serialization)</li>
<li>对于iOS UIKit库的扩展(UIKit)</li>
</ul>
<p>这五个模块所对应的类的结构关系图（AF架构图）如下所示：</p>
<ul>
<li><strong>其核心当然是网络通信模块AFURLSessionManager。大家都知道，AF3.x是基于NSURLSession来封装的。所以这个类围绕着NSURLSession做了一系列的封装。而其余的四个模块，均是为了配合网络通信或对已有UIKit的一个扩展工具包。</strong></li>
<li>其中AFHTTPSessionManager是继承于AFURLSessionManager的，我们一般做网络请求都是用这个类，<strong>但是它本身是没有做实事的，只是做了一些简单的封装，把请求逻辑分发给父类AFURLSessionManager或者其它类去做。</strong></li>
</ul>
<img src="/images/AFN/AFN-03.jpg" alt="img" style="zoom:55%;" />

<h1 id="二、AFURL-amp-HTTPSessionManager"><a href="#二、AFURL-amp-HTTPSessionManager" class="headerlink" title="二、AFURL&amp;HTTPSessionManager"></a>二、AFURL&amp;HTTPSessionManager</h1><h2 id="2-1-AFHTTPSessionManager的初始化"><a href="#2-1-AFHTTPSessionManager的初始化" class="headerlink" title="2.1 AFHTTPSessionManager的初始化"></a>2.1 AFHTTPSessionManager的初始化</h2><h3 id="2-1-1-初始化源码"><a href="#2-1-1-初始化源码" class="headerlink" title="2.1.1 初始化源码"></a>2.1.1 初始化源码</h3><p>首先我们简单的写个get请求：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPSessionManager *manager = [[AFHTTPSessionManager alloc]init];</span><br><span class="line"></span><br><span class="line">[manager GET:<span class="string">@&quot;http://localhost&quot;</span> parameters:<span class="literal">nil</span> progress:<span class="literal">nil</span> success:^(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull task, <span class="keyword">id</span>  _Nullable responseObject) &#123;</span><br><span class="line"> </span><br><span class="line">&#125; failure:^(<span class="built_in">NSURLSessionDataTask</span> * _Nullable task, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h4 id="1-AFHTTPSessionManager"><a href="#1-AFHTTPSessionManager" class="headerlink" title="1. AFHTTPSessionManager"></a>1. AFHTTPSessionManager</h4><p>首先我们我们调用了初始化方法生成了一个manager，我们点进去看看初始化做了什么:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)manager &#123;</span><br><span class="line">    <span class="keyword">return</span> [[[<span class="keyword">self</span> <span class="keyword">class</span>] alloc] initWithBaseURL:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:url sessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span> sessionConfiguration:configuration];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化都调用到这个方法中来了</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">           sessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithSessionConfiguration:configuration];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对传过来的BaseUrl进行处理，如果有值且最后不包含/，url加上&quot;/&quot;</span></span><br><span class="line">    <span class="keyword">if</span> ([[url path] length] &gt; <span class="number">0</span> &amp;&amp; ![[url absoluteString] hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.baseURL = url;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>其实初始化方法都调用父类的初始化方法。</strong>父类也就是AF3.x<strong>最最核心的类AFURLSessionManager</strong>。几乎所有的类都是围绕着这个类在处理业务逻辑。</li>
<li>除此之外，方法中把baseURL存了起来，还生成了一个请求序列对象和一个响应序列对象。后面再细说这两个类是干什么用的。</li>
</ul>
<h4 id="2-AFURLSessionManager"><a href="#2-AFURLSessionManager" class="headerlink" title="2. AFURLSessionManager"></a>2. AFURLSessionManager</h4><p>直接来到父类AFURLSessionManager的初始化方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionConfiguration:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)configuration &#123;</span><br><span class="line">  <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!configuration) &#123;</span><br><span class="line">      configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">self</span>.sessionConfiguration = configuration;</span><br><span class="line">  <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">  <span class="comment">// 重点：这个operationQueue就是我们代理回调的queue。这里把代理回调的线程并发数设置为1了。至于这里为什么要这么做，见2.1.2节。</span></span><br><span class="line">  <span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//注意代理，代理的继承，实际上NSURLSession去判断了，你实现了哪个方法会去调用，包括子代理的方法！</span></span><br><span class="line">  <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//各种响应转码</span></span><br><span class="line">  <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//设置默认安全策略</span></span><br><span class="line">  <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !TARGET_OS_WATCH</span></span><br><span class="line">  <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 重点2：这个字典是用来让每一个请求task和我们自定义的AF代理来建立映射用的。</span></span><br><span class="line">    <span class="comment">// 在AFNet中，每一个task都会被匹配一个AFURLSessionManagerTaskDelegate 来做task的delegate事件处理</span></span><br><span class="line">    <span class="comment">// 其实AF对task的代理进行了一个封装，并且转发代理到AF自定义的代理，这是AF比较重要的一部分，接下来我们会具体讲这一块。</span></span><br><span class="line">  <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  设置AFURLSessionManagerTaskDelegate 词典的锁，确保词典在多线程访问时的线程安全</span></span><br><span class="line">  <span class="keyword">self</span>.lock = [[<span class="built_in">NSLock</span> alloc] init];</span><br><span class="line">  <span class="keyword">self</span>.lock.name = AFURLSessionManagerLockName;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 重点3：置空task关联的代理。</span></span><br><span class="line">    <span class="comment">// 作用：这个方法用来异步的获取当前session的所有未完成的task。其实讲道理来说在初始化中调用这个方法应该里面一个task都不会有。我们打断点去看，也确实如此，里面的数组都是空的。</span></span><br><span class="line">    <span class="comment">// 但是想想也知道，AF大神不会把一段没用的代码放在这吧。辗转多处，终于从AF的issue中找到了结论：https://github.com/AFNetworking/AFNetworking/issues/3499。原来这是为了防止后台回来，重新初始化这个session，一些之前的后台请求任务，导致程序的crash。</span></span><br><span class="line">  [<span class="keyword">self</span>.session getTasksWithCompletionHandler:^(<span class="built_in">NSArray</span> *dataTasks, <span class="built_in">NSArray</span> *uploadTasks, <span class="built_in">NSArray</span> *downloadTasks) &#123;        </span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionDataTask</span> *task <span class="keyword">in</span> dataTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForDataTask:task uploadProgress:<span class="literal">nil</span> downloadProgress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionUploadTask</span> *uploadTask <span class="keyword">in</span> uploadTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForUploadTask:uploadTask progress:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">for</span> (<span class="built_in">NSURLSessionDownloadTask</span> *downloadTask <span class="keyword">in</span> downloadTasks) &#123;</span><br><span class="line">        [<span class="keyword">self</span> addDelegateForDownloadTask:downloadTask progress:<span class="literal">nil</span> destination:<span class="literal">nil</span> completionHandler:<span class="literal">nil</span>];</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-AF-maxConcurrentOperationCount设置"><a href="#2-1-2-AF-maxConcurrentOperationCount设置" class="headerlink" title="2.1.2 AF maxConcurrentOperationCount设置"></a>2.1.2 AF maxConcurrentOperationCount设置</h3><p>回到初始化的这行代码上：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.operationQueue.maxConcurrentOperationCount = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>这里先说结论，有些内容是在下面陈述的：</p>
<ul>
<li>首先我们要明确一个概念，<strong>这里的并发数仅仅是回调代理的线程并发数。而不是请求网络的线程并发数。请求网络是由NSURLSession来做的，它内部维护了一个线程池，用来做网络请求</strong>。它调度线程，基于底层的CFSocket去发送请求和接收数据。这些<strong>线程是并发的</strong>。</li>
<li>明确了这个概念之后，我们来梳理一下AF3.x的整个流程和线程的关系：<ul>
<li>我们一开始初始化sessionManager的时候，一般都是在主线程，（当然不排除有些人喜欢在分线程初始化…）</li>
<li>然后我们调用get或者post等去请求数据，接着会进行request拼接，AF代理的字典映射，progress的KVO添加等等，到NSUrlSession的resume之前这些准备工作，仍旧是在主线程中的。</li>
<li>然后我们调用NSUrlSession的resume，接着就跑到NSUrlSession内部去对网络进行数据请求了,在它内部是多线程并发的去请求数据的。</li>
<li>紧接着数据请求完成后，回调回来在我们一开始生成的并发数为1的NSOperationQueue中，这个时候会是多线程串行的回调回来的。（注：不明白的朋友可以看看雷纯峰大神这篇<a target="_blank" rel="noopener" href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS 并发编程之 Operation Queues</a>）</li>
<li>然后我们到返回数据解析那一块，我们自己又创建了并发的多线程，去对这些数据进行了各种类型的解析。</li>
<li>最后我们如果有自定义的completionQueue，则在自定义的queue中回调回来，也就是分线程回调回来，否则就是主队列，主线程中回调结束。</li>
</ul>
</li>
<li>最后我们来解释解释为什么回调Queue要设置并发数为1：个人认为AF这么做有以下两点原因：<ul>
<li>众所周知，AF2.x所有的回调是在一条线程（<em>参考6.7小节</em>），这条线程是AF的常驻线程，而这一条线程正是AF调度request的思想精髓所在，所以第一个目的就是为了和之前版本保持一致。</li>
<li>因为跟代理相关的一些操作AF都使用了NSLock。所以就算Queue的并发数设置为n，因为多线程回调，锁的等待，导致所提升的程序速度也并不明显。<strong>反而多task回调导致的多线程并发，平白浪费了部分性能。</strong><ul>
<li>而设置Queue的并发数为1（注：这里虽然回调Queue的并发数为1，仍然会有不止一条线程，但是因为是串行回调，所以同一时间，只会有一条线程在操作AFURLSessionManager的那些方法）至少回调的事件，是不需要多线程并发的。<strong>回调没有了NSLock的等待时间，所以对时间并没有多大的影响。</strong></li>
</ul>
</li>
<li>注：但是还是会有多线程的操作的，因为设置刚开始调起请求的时候，是在主线程的，而回调则是串行分线程：<font color='red'>response的解析是并发线程执行的</font>（<em>参考2.3.6-1小节</em>）。</li>
</ul>
</li>
</ul>
<p>初始化方法到这就全部完成了。</p>
<h2 id="2-2-AFHTTPSessionManager创建GET-Task"><a href="#2-2-AFHTTPSessionManager创建GET-Task" class="headerlink" title="2.2 AFHTTPSessionManager创建GET Task"></a>2.2 AFHTTPSessionManager创建GET Task</h2><h3 id="2-2-1-源码实现"><a href="#2-2-1-源码实现" class="headerlink" title="2.2.1 源码实现"></a>2.2.1 源码实现</h3><p>接着我们来看看网络请求:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                   parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                     progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> * _Nonnull))downloadProgress</span><br><span class="line">                      success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nonnull, <span class="keyword">id</span> _Nullable))success</span><br><span class="line">                      failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> * _Nullable, <span class="built_in">NSError</span> * _Nonnull))failure</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">//生成一个系统的NSURLSessionDataTask实例</span></span><br><span class="line">    <span class="built_in">NSURLSessionDataTask</span> *dataTask = [<span class="keyword">self</span> dataTaskWithHTTPMethod:<span class="string">@&quot;GET&quot;</span></span><br><span class="line">                                                        URLString:URLString</span><br><span class="line">                                                       parameters:parameters</span><br><span class="line">                                                   uploadProgress:<span class="literal">nil</span></span><br><span class="line">                                                 downloadProgress:downloadProgress</span><br><span class="line">                                                          success:success</span><br><span class="line">                                                          failure:failure];</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//开始网络请求</span></span><br><span class="line">    [dataTask resume];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithHTTPMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                               URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                              parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                          uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgress</span><br><span class="line">                        downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgress</span><br><span class="line">                                 success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="keyword">id</span>))success</span><br><span class="line">                                 failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionDataTask</span> *, <span class="built_in">NSError</span> *))failure</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1. 用self.requestSerializer把各种参数转化为一个我们最终请求网络需要的NSMutableURLRequest实例。</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:method URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:&amp;serializationError];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span>  <span class="comment">// 这里是用来忽略 ?: 带来的警告</span></span></span><br><span class="line">            <span class="comment">// 当解析错误，我们直接调用传进来的 failure 的 Block 失败返回了，这里有一个 self.completionQueue ，这个是我们自定义的，这个是一个GCD的Queue如果设置了那么从这个Queue中回调结果，否则从主队列回调。</span></span><br><span class="line">            <span class="comment">// 实际上这个Queue还是挺有用的，之前还用到过。我们公司有自己的一套数据加解密的解析模式，所以我们回调回来的数据并不想是主线程，我们可以设置这个Queue,在分线程进行解析数据，然后自己再调回到主线程去刷新UI。</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                failure(<span class="literal">nil</span>, serializationError);</span><br><span class="line">            &#125;);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2. 拿到我们最终需要的NSURLSessionDataTask实例，并且在完成的回调里，调用我们传过来的成功和失败的回调。</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                          uploadProgress:uploadProgress</span><br><span class="line">                        downloadProgress:downloadProgress</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                failure(dataTask, error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                success(dataTask, responseObject);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-2-AFURLRequestSerialization创建request"><a href="#2-2-2-AFURLRequestSerialization创建request" class="headerlink" title="2.2.2 AFURLRequestSerialization创建request"></a>2.2.2 AFURLRequestSerialization创建request</h3><p>AFURLRequestSerialization文件中定义了三个请求参数序列化的类：</p>
<ul>
<li>AFHTTPRequestSerializer<ul>
<li>符合 <code>AFURLRequestSerialization</code> 和 <code>AFURLResponseSerialization</code> 协议，提供 query 字符串 / URL form-encoded 参数序列化和默认请求头的具体基础实现，以及响应状态代码和内容类型验证。</li>
<li>鼓励任何处理 HTTP 请求序列化的程序继承 <code>AFHTTPRequestSerializer</code> ，以确保一致的默认行为。</li>
<li>当请求的 Content-Type 是 <code>application/x-www-form-urlencoded</code> 时使用。<font color='red'>默认</font></li>
</ul>
</li>
<li>AFJSONRequestSerializer<ul>
<li>继承自AFHTTPRequestSerializer，使用 <code>NSJSONSerialization</code> 将参数编码为 JSON，将请求的 <code>Content-Type</code> 设置为 <code>application/json</code>。</li>
<li>当请求的 Content-Type 是 <code>application/json</code> 时使用。</li>
</ul>
</li>
<li>AFPropertyListRequestSerializer<ul>
<li>继承自AFHTTPRequestSerializer，使用 <code>NSPropertyListSerializer</code> 将参数编码为 JSON，将请求的 <code>Content-Type</code> 设置为 <code>application/x-plist</code>。</li>
<li>当请求的 Content-Type 是 <code>application/x-plist</code> 时使用。</li>
</ul>
</li>
</ul>
<p>此处主要看的也是 AFHTTPRequestSerializer 序列化类：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableURLRequest</span> *)requestWithMethod:(<span class="built_in">NSString</span> *)method</span><br><span class="line">                                 URLString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                                parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                     error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//断言，debug模式下，如果缺少改参数，crash</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(method);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(URLString);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(url);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url];</span><br><span class="line">    mutableRequest.HTTPMethod = method;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将request的各种观察属性循环遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="comment">//如果该观察属性已经发生了变化</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.mutableObservedChangedKeyPaths containsObject:keyPath]) &#123;</span><br><span class="line">           <span class="comment">//把给自己设置的属性给request设置</span></span><br><span class="line">            [mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将传入的parameters进行编码，并添加到request中</span></span><br><span class="line">    mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲一下这个方法，这个方法做了3件事：</p>
<h4 id="1-设置request请求类型"><a href="#1-设置request请求类型" class="headerlink" title="1. 设置request请求类型"></a>1. 设置request请求类型</h4><p>设置request的请求类型，get、post、put…等</p>
<h4 id="2-添加request配置参数"><a href="#2-添加request配置参数" class="headerlink" title="2. 添加request配置参数"></a>2. 添加request配置参数</h4><p>往request里添加一些参数设置，其中<code>AFHTTPRequestSerializerObservedKeyPaths()</code>是一个c函数，返回一个数组，我们来看看这个函数:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFHTTPRequestSerializerObservedKeyPaths() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSArray</span> *_AFHTTPRequestSerializerObservedKeyPaths = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">// 此处需要observer的keypath为allowsCellularAccess、cachePolicy、HTTPShouldHandleCookies</span></span><br><span class="line">    <span class="comment">// HTTPShouldUsePipelining、networkServiceType、timeoutInterval</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        _AFHTTPRequestSerializerObservedKeyPaths = @[<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(allowsCellularAccess)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(cachePolicy)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldHandleCookies)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(HTTPShouldUsePipelining)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(networkServiceType)), <span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(timeoutInterval))];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">//就是一个数组里装了很多方法的名字,</span></span><br><span class="line">    <span class="keyword">return</span> _AFHTTPRequestSerializerObservedKeyPaths;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实这个函数就是封装了一些属性的名字，这些都是NSURLRequest的属性。</p>
<p>再来看看<code>self.mutableObservedChangedKeyPaths</code>，这个是 AFHTTPRequestSerializer 类的一个属性，在 init 方法中对这个集合进行了初始化，<strong>并对当前类的和NSURLRequest相关的那些属性添加了KVO监听</strong>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableSet</span> *mutableObservedChangedKeyPaths;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">    <span class="comment">// 每次都会重置变化</span></span><br><span class="line">    <span class="keyword">self</span>.mutableObservedChangedKeyPaths = [<span class="built_in">NSMutableSet</span> set];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//给这些key添加观察者为自己，就是request的各种属性，set方法</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *keyPath <span class="keyword">in</span> AFHTTPRequestSerializerObservedKeyPaths()) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="built_in">NSSelectorFromString</span>(keyPath)]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> addObserver:<span class="keyword">self</span> forKeyPath:keyPath options:<span class="built_in">NSKeyValueObservingOptionNew</span> context:AFHTTPRequestSerializerObserverContext];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// KVO触发的方法：</span></span><br><span class="line">-(<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath</span><br><span class="line">                      ofObject:(__unused <span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change</span><br><span class="line">                       context:(<span class="keyword">void</span> *)context</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当观察到这些set方法被调用了，而且不为Null就会添加到集合里，否则移除</span></span><br><span class="line">    <span class="keyword">if</span> (context == AFHTTPRequestSerializerObserverContext) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([change[<span class="built_in">NSKeyValueChangeNewKey</span>] isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths removeObject:keyPath];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="keyword">self</span>.mutableObservedChangedKeyPaths addObject:keyPath];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此我们知道<code>self.mutableObservedChangedKeyPaths</code>其实就是我们自己设置的request属性值的集合。</p>
<p>接下来调用下面的代码，用KVC的方式，把属性值都设置到我们请求的request中去。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[mutableRequest setValue:[<span class="keyword">self</span> valueForKeyPath:keyPath] forKey:keyPath];</span><br></pre></td></tr></table></figure>

<h4 id="3-编码及设置请求参数"><a href="#3-编码及设置请求参数" class="headerlink" title="3. 编码及设置请求参数"></a>3. 编码及设置请求参数</h4><p>把需要传递的参数进行编码，并且设置到request中去：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将传入的parameters进行编码，并添加到request中</span></span><br><span class="line">mutableRequest = [[<span class="keyword">self</span> requestBySerializingRequest:mutableRequest withParameters:parameters error:error] mutableCopy];</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="built_in">NSURLRequest</span> *)requestBySerializingRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                               withParameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                                        error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(request);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *mutableRequest = [request mutableCopy];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从自己的head里去遍历，如果有值则设置给request的head</span></span><br><span class="line">    [<span class="keyword">self</span>.HTTPRequestHeaders enumerateKeysAndObjectsUsingBlock:^(<span class="keyword">id</span> field, <span class="keyword">id</span> value, <span class="built_in">BOOL</span> * __unused stop) &#123;</span><br><span class="line">        <span class="keyword">if</span> (![request valueForHTTPHeaderField:field]) &#123;</span><br><span class="line">            [mutableRequest setValue:value forHTTPHeaderField:field];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//来把各种类型的参数，array dic set转化成字符串，给request</span></span><br><span class="line">    <span class="built_in">NSString</span> *query = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (parameters) &#123;</span><br><span class="line">        <span class="comment">//自定义的解析方式</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.queryStringSerialization) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError;</span><br><span class="line">            query = <span class="keyword">self</span>.queryStringSerialization(request, parameters, &amp;serializationError);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                    *error = serializationError;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认解析方式</span></span><br><span class="line">            <span class="keyword">switch</span> (<span class="keyword">self</span>.queryStringSerializationStyle) &#123;</span><br><span class="line">                <span class="keyword">case</span> AFHTTPRequestQueryStringDefaultStyle:</span><br><span class="line">                    query = AFQueryStringFromParameters(parameters);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最后判断该request中是否包含了GET、HEAD、DELETE（都包含在HTTPMethodsEncodingParametersInURI）。因为这几个method的quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的。</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@&quot;&amp;%@&quot;</span> : <span class="string">@&quot;?%@&quot;</span>, query]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//post put请求</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">        <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">            query = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>]) &#123;</span><br><span class="line">            [mutableRequest setValue:<span class="string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//设置请求体</span></span><br><span class="line">        [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableRequest;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法做了3件事：</p>
<h5 id="1-设置header中的参数"><a href="#1-设置header中的参数" class="headerlink" title="1) 设置header中的参数"></a>1) 设置header中的参数</h5><p>从<code>self.HTTPRequestHeaders</code>中拿到设置的参数，赋值要请求的request里去</p>
<h5 id="2-将请求参数转换为字符串"><a href="#2-将请求参数转换为字符串" class="headerlink" title="2) 将请求参数转换为字符串"></a>2) 将请求参数转换为字符串</h5><p>把请求网络的参数，从array dic set这些容器类型转换为字符串，具体转码方式，我们可以使用自定义的方式，也可以用AF默认的转码方式。自定义的方式没什么好说的，想怎么去解析由你自己来决定。我们可以来看看默认的方式：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> * AFQueryStringFromParameters(<span class="built_in">NSDictionary</span> *parameters) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutablePairs = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//把参数给AFQueryStringPairsFromDictionary，拿到AF的一个类型的数据就一个key，value对象，在URLEncodedStringValue拼接keyValue，一个加到数组里</span></span><br><span class="line">    <span class="keyword">for</span> (AFQueryStringPair *pair <span class="keyword">in</span> AFQueryStringPairsFromDictionary(parameters)) &#123;</span><br><span class="line">        [mutablePairs addObject:[pair URLEncodedStringValue]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拆分数组返回参数字符串</span></span><br><span class="line">    <span class="keyword">return</span> [mutablePairs componentsJoinedByString:<span class="string">@&quot;&amp;&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromDictionary(<span class="built_in">NSDictionary</span> *dictionary) &#123;</span><br><span class="line">    <span class="comment">//往下调用</span></span><br><span class="line">    <span class="keyword">return</span> AFQueryStringPairsFromKeyAndValue(<span class="literal">nil</span>, dictionary);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSArray</span> * AFQueryStringPairsFromKeyAndValue(<span class="built_in">NSString</span> *key, <span class="keyword">id</span> value) &#123;</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *mutableQueryStringComponents = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据需要排列的对象的description来进行升序排列，并且selector使用的是compare:</span></span><br><span class="line">    <span class="comment">// 因为对象的description返回的是NSString，所以此处compare:使用的是NSString的compare函数</span></span><br><span class="line">    <span class="comment">// 即@[@&quot;foo&quot;, @&quot;bar&quot;, @&quot;bae&quot;] ----&gt; @[@&quot;bae&quot;, @&quot;bar&quot;,@&quot;foo&quot;]</span></span><br><span class="line">    <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [<span class="built_in">NSSortDescriptor</span> sortDescriptorWithKey:<span class="string">@&quot;description&quot;</span> ascending:<span class="literal">YES</span> selector:<span class="keyword">@selector</span>(compare:)];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</span></span><br><span class="line">    <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSDictionary</span> *dictionary = value;</span><br><span class="line">        <span class="comment">// Sort dictionary keys to ensure consistent ordering in query string, which is important when deserializing potentially ambiguous sequences, such as an array of dictionaries</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//拿到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedKey <span class="keyword">in</span> [dictionary.allKeys sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            <span class="keyword">id</span> nestedValue = dictionary[nestedKey];</span><br><span class="line">            <span class="keyword">if</span> (nestedValue) &#123;</span><br><span class="line">                [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue((key ? [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@[%@]&quot;</span>, key, nestedKey] : nestedKey), nestedValue)];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *array = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> nestedValue <span class="keyword">in</span> array) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue([<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@[]&quot;</span>, key], nestedValue)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSSet</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSSet</span> *set = value;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> obj <span class="keyword">in</span> [set sortedArrayUsingDescriptors:@[ sortDescriptor ]]) &#123;</span><br><span class="line">            [mutableQueryStringComponents addObjectsFromArray:AFQueryStringPairsFromKeyAndValue(key, obj)];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [mutableQueryStringComponents addObject:[[AFQueryStringPair alloc] initWithField:key value:value]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mutableQueryStringComponents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>转码主要是以上三个函数，配合着注释应该也很好理解：主要是在递归调用<code>AFQueryStringPairsFromKeyAndValue</code>。判断vaLue是什么类型的，然后去递归调用自己，直到解析的是除了array dic set以外的元素，然后把得到的参数数组返回。</p>
<p>其中有个<code>AFQueryStringPair</code>对象，其只有两个属性和两个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> field;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> value;</span><br><span class="line">   </span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithField:(<span class="keyword">id</span>)field value:(<span class="keyword">id</span>)value &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.field = field;</span><br><span class="line">    <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line">   </span><br><span class="line">- (<span class="built_in">NSString</span> *)URLEncodedStringValue &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.value || [<span class="keyword">self</span>.value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@=%@&quot;</span>, AFPercentEscapedStringFromString([<span class="keyword">self</span>.field description]), AFPercentEscapedStringFromString([<span class="keyword">self</span>.value description])];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法很简单，现在我们也很容易理解这整个转码过程了，我们举个例子梳理下，就是以下这3步：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@&#123; </span><br><span class="line">     <span class="string">@&quot;name&quot;</span> : <span class="string">@&quot;bang&quot;</span>, </span><br><span class="line">     <span class="string">@&quot;phone&quot;</span>: @&#123;<span class="string">@&quot;mobile&quot;</span>: <span class="string">@&quot;xx&quot;</span>, <span class="string">@&quot;home&quot;</span>: <span class="string">@&quot;xx&quot;</span>&#125;, </span><br><span class="line">     <span class="string">@&quot;families&quot;</span>: @[<span class="string">@&quot;father&quot;</span>, <span class="string">@&quot;mother&quot;</span>], </span><br><span class="line">     <span class="string">@&quot;nums&quot;</span>: [NSSet setWithObjects:<span class="string">@&quot;1&quot;</span>, <span class="string">@&quot;2&quot;</span>, nil] </span><br><span class="line">&#125; </span><br><span class="line">-&gt; </span><br><span class="line">@[ </span><br><span class="line">     field: <span class="string">@&quot;name&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;bang&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;phone[mobile]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;xx&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;phone[home]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;xx&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;families[]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;father&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;families[]&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;mother&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;nums&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;1&quot;</span>, </span><br><span class="line">     field: <span class="string">@&quot;nums&quot;</span>, <span class="keyword">value</span>: <span class="string">@&quot;2&quot;</span>, </span><br><span class="line">] </span><br><span class="line">-&gt; </span><br><span class="line">name=bang&amp;phone[mobile]=xx&amp;phone[home]=xx&amp;families[]=father&amp;families[]=mother&amp;nums=<span class="number">1</span>&amp;num=<span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>至此，我们原来的容器类型的参数，就这样变成字符串类型了。</p>
<h5 id="3-根据请求类型设置请求参数"><a href="#3-根据请求类型设置请求参数" class="headerlink" title="3) 根据请求类型设置请求参数"></a>3) 根据请求类型设置请求参数</h5><p>紧接着这个方法还根据该request中请求类型，来判断参数字符串应该如何设置到request中去。如果是GET、HEAD、DELETE，则把参数quey是拼接到url后面的。而POST、PUT是把query拼接到http body中的:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span>.HTTPMethodsEncodingParametersInURI containsObject:[[request HTTPMethod] uppercaseString]]) &#123;</span><br><span class="line">    <span class="keyword">if</span> (query &amp;&amp; query.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        mutableRequest.URL = [<span class="built_in">NSURL</span> URLWithString:[[mutableRequest.URL absoluteString] stringByAppendingFormat:mutableRequest.URL.query ? <span class="string">@&quot;&amp;%@&quot;</span> : <span class="string">@&quot;?%@&quot;</span>, query]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//post put请求</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// #2864: an empty string is a valid x-www-form-urlencoded payload</span></span><br><span class="line">    <span class="keyword">if</span> (!query) &#123;</span><br><span class="line">        query = <span class="string">@&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (![mutableRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>]) &#123;</span><br><span class="line">        [mutableRequest setValue:<span class="string">@&quot;application/x-www-form-urlencoded&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Content-Type&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置请求体</span></span><br><span class="line">    [mutableRequest setHTTPBody:[query dataUsingEncoding:<span class="keyword">self</span>.stringEncoding]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此，我们生成了一个request。</p>
<h3 id="2-2-3-AFURLSessionManger父类创建task"><a href="#2-2-3-AFURLSessionManger父类创建task" class="headerlink" title="2.2.3 AFURLSessionManger父类创建task"></a>2.2.3 AFURLSessionManger父类创建task</h3><p>现在弄清楚request的创建流程中，我们跳出当前方法，再回到上层AFHTTPSessionManager类中的 <code>dataTaskWithHTTPMethod:URLString:...</code> 方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2. 拿到我们最终需要的NSURLSessionDataTask实例，并且在完成的回调里，调用我们传过来的成功和失败的回调。</span></span><br><span class="line">__block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">dataTask = [<span class="keyword">self</span> dataTaskWithRequest:request</span><br><span class="line">                      uploadProgress:uploadProgress</span><br><span class="line">                    downloadProgress:downloadProgress</span><br><span class="line">                   completionHandler:^(<span class="built_in">NSURLResponse</span> * __unused response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">            failure(dataTask, error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            success(dataTask, responseObject);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>这是调用了继承自父类的生成task的方法，并且执行了一个成功和失败的回调，我们接着去父类AFURLSessionManger里看（总算到我们的核心类了..）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSURLSessionDataTask</span> *)dataTaskWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                    uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">                  downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                 completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> _Nullable responseObject,  <span class="built_in">NSError</span> * _Nullable error))completionHandler &#123;</span><br><span class="line"></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *dataTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//第一件事，创建NSURLSessionDataTask，里面适配了iOS 8以下taskIdentifiers，函数创建task对象。</span></span><br><span class="line">    <span class="comment">//其实现应该是因为iOS 8.0以下版本中会并发地创建多个task对象，而同步有没有做好，导致taskIdentifiers 不唯一…这边做了一个串行处理</span></span><br><span class="line">    url_session_manager_create_task_safely(^&#123;</span><br><span class="line">        dataTask = [<span class="keyword">self</span>.session dataTaskWithRequest:request];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dataTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到这个方法非常简单，就调用了一个<code>url_session_manager_create_task_safely()</code>函数，传了一个Block进去，Block里就是iOS原生生成dataTask的方法。此外，还调用了一个<code>addDelegateForDataTask</code>的方法。</p>
<h4 id="1-create-task-safely"><a href="#1-create-task-safely" class="headerlink" title="1. create_task_safely()"></a>1. create_task_safely()</h4><p>我们到这先到这个函数里去看看：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> url_session_manager_create_task_safely(dispatch_block_t block) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSFoundationVersionNumber</span> &lt; <span class="built_in">NSFoundationVersionNumber_With_Fixed_5871104061079552_bug</span>) &#123;</span><br><span class="line">        <span class="comment">// Fix of bug</span></span><br><span class="line">        <span class="comment">// Open Radar:http://openradar.appspot.com/radar?id=5871104061079552 (status: Fixed in iOS8)</span></span><br><span class="line">        <span class="comment">// Issue about:https://github.com/AFNetworking/AFNetworking/issues/2093</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">//理解下，第一为什么用sync，因为是想要主线程等在这，等执行完，在返回，因为必须执行完dataTask才有数据，传值才有意义。</span></span><br><span class="line">      <span class="comment">//第二，为什么要用串行队列，因为这块是为了防止ios8以下内部的dataTaskWithRequest是并发创建的，</span></span><br><span class="line">      <span class="comment">//这样会导致taskIdentifiers这个属性值不唯一，因为后续要用taskIdentifiers来作为Key对应delegate。</span></span><br><span class="line">        <span class="built_in">dispatch_sync</span>(url_session_manager_creation_queue(), block);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        block();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_creation_queue() &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_creation_queue;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="comment">//保证了即使是在多线程的环境下，也不会创建其他队列</span></span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        af_url_session_manager_creation_queue = dispatch_queue_create(<span class="string">&quot;com.alamofire.networking.session.manager.creation&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> af_url_session_manager_creation_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法非常简单，关键是理解这么做的目的：为什么我们不直接去调用 <code>dataTask = [self.session dataTaskWithRequest:request];</code> 非要绕这么一圈，我们点进去bug日志里看看，<strong>原来这是为了适配iOS8的以下，创建session的时候，偶发的情况会出现session的属性taskIdentifier这个值不唯一</strong>，而这个taskIdentifier是我们后面来映射delegate的key,所以它必须是唯一的。</p>
<p><strong>具体原因应该是NSURLSession内部去生成task的时候是用多线程并发去执行的。</strong>想通了这一点，我们就很好解决了，我们只需要在iOS8以下<strong>同步串行</strong>的去生成task就可以防止这一问题发生（如果还是不理解同步串行的原因，可以看看注释）。</p>
<p>题外话：很多同学都会抱怨为什么sync我从来用不到，看，有用到的地方了吧，<strong>很多东西不是没用，而只是你想不到怎么用</strong>。</p>
<h4 id="2-addDelegateForDataTask"><a href="#2-addDelegateForDataTask" class="headerlink" title="2. addDelegateForDataTask:"></a>2. addDelegateForDataTask:</h4><p>我们接着看到：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">self</span> addDelegateForDataTask:dataTask uploadProgress:uploadProgressBlock downloadProgress:downloadProgressBlock completionHandler:completionHandler];</span><br></pre></td></tr></table></figure>

<p>一起来看一下主要的调用流程：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">addDelegateForDataTask:uploadProgress:downloadProgress:completionHandler:</span><br><span class="line">	﹂setDelegate:forTask:</span><br><span class="line">		﹂setupProgressForTask:</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">                uploadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *uploadProgress)) uploadProgressBlock</span><br><span class="line">              downloadProgress:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">             completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 生成一个AFURLSessionManagerTaskDelegate，这个其实就是AF的自定义代理。我们请求传来的参数，都赋值给这个AF的代理了。</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 2. AFURLSessionManagerTaskDelegate与AFURLSessionManager建立相互关系。代理把AFURLSessionManager这个类作为属性了，属性是weak声明的，所以不会存在循环引用的问题。</span></span><br><span class="line">    delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">    delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个taskDescriptionForSessionTasks用来发送开始和挂起通知的时候会用到,就是用这个值来Post通知，来两者对应</span></span><br><span class="line">    dataTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. ***** 将AF delegate对象与 dataTask建立关系</span></span><br><span class="line">    [<span class="keyword">self</span> setDelegate:delegate forTask:dataTask];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置AF delegate的上传进度，下载进度块。</span></span><br><span class="line">    delegate.uploadProgressBlock = uploadProgressBlock;</span><br><span class="line">    delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 把AF代理和task建立映射，存在了一个我们事先声明好的字典里。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setDelegate:(AFURLSessionManagerTaskDelegate *)delegate</span><br><span class="line">            forTask:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//断言，如果没有这个参数，debug下crash在这</span></span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(delegate);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加锁保证字典线程安全。要加锁的原因是因为本身我们这个字典属性是mutable的，是线程不安全的。而我们对这些方法的调用，确实是会在复杂的多线程环境中，后面会仔细提到线程问题。</span></span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将AF delegate放入以taskIdentifier标记的词典中（同一个NSURLSession中的taskIdentifier是唯一的）</span></span><br><span class="line">    <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)] = delegate;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">// 为AF delegate 设置task 的progress监听</span></span><br><span class="line">    [delegate setupProgressForTask:task];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//添加task开始和暂停的通知</span></span><br><span class="line">    [<span class="keyword">self</span> addNotificationObserverForTask:task];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 为task设置progress</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)setupProgressForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">    </span><br><span class="line">    __<span class="keyword">weak</span> __typeof__(task) weakTask = task;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 设置 downloadProgress 与 uploadProgress 的一些属性，并且把两者和task的任务状态绑定在了一起。注意这两者都是NSProgress的实例对象，（这里可能又一群小伙伴楞在这了，这是个什么...）简单来说，这就是iOS7引进的一个用来管理进度的类，可以开始，暂停，取消，完整的对应了task的各种状态，当progress进行各种操作的时候，task也会引发对应操作。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//拿到上传下载期望的数据大小</span></span><br><span class="line">    <span class="keyword">self</span>.uploadProgress.totalUnitCount = task.countOfBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">self</span>.downloadProgress.totalUnitCount = task.countOfBytesExpectedToReceive;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将上传与下载进度和 任务绑定在一起，直接cancel suspend resume进度条，可以cancel...任务</span></span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setCancellable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setPausable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.uploadProgress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.uploadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setCancellable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setCancellationHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask cancel];</span><br><span class="line">    &#125;];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setPausable:<span class="literal">YES</span>];</span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress setPausingHandler:^&#123;</span><br><span class="line">        __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">        [strongTask suspend];</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span>.downloadProgress respondsToSelector:<span class="keyword">@selector</span>(setResumingHandler:)]) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.downloadProgress setResumingHandler:^&#123;</span><br><span class="line">            __typeof__(weakTask) strongTask = weakTask;</span><br><span class="line">            [strongTask resume];</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 给task和progress的各个属及添加KVO监听</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//观察task的这些属性</span></span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line">    [task addObserver:<span class="keyword">self</span></span><br><span class="line">           forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))</span><br><span class="line">              options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">              context:<span class="literal">NULL</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//观察progress这两个属性</span></span><br><span class="line">    [<span class="keyword">self</span>.downloadProgress addObserver:<span class="keyword">self</span></span><br><span class="line">                            forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                               options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                               context:<span class="literal">NULL</span>];</span><br><span class="line">    [<span class="keyword">self</span>.uploadProgress addObserver:<span class="keyword">self</span></span><br><span class="line">                          forKeyPath:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(fractionCompleted))</span><br><span class="line">                             options:<span class="built_in">NSKeyValueObservingOptionNew</span></span><br><span class="line">                             context:<span class="literal">NULL</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>KVO 触发的监听方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object change:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是task</span></span><br><span class="line">    <span class="keyword">if</span> ([object isKindOfClass:[<span class="built_in">NSURLSessionTask</span> <span class="keyword">class</span>]] || [object isKindOfClass:[<span class="built_in">NSURLSessionDownloadTask</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="comment">//给进度条赋新值</span></span><br><span class="line">        <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesReceived))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress.completedUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToReceive))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress.totalUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesSent))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgress.completedUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([keyPath isEqualToString:<span class="built_in">NSStringFromSelector</span>(<span class="keyword">@selector</span>(countOfBytesExpectedToSend))]) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgress.totalUnitCount = [change[<span class="built_in">NSKeyValueChangeNewKey</span>] longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//上面的赋新值会触发这两个，调用block回调，用户拿到进度</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.downloadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([object isEqual:<span class="keyword">self</span>.uploadProgress]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.uploadProgressBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.uploadProgressBlock(object);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法非常简单直观，主要就是如果task触发KVO，则给progress进度赋值，因为赋值了，所以会触发progress的KVO，也会调用到这里，然后去执行我们传进来的<code>downloadProgressBlock</code>和<code>uploadProgressBlock</code>。主要的作用就是为了让进度实时的传递。</p>
<p>主要是观摩一下大神的写代码的结构，这个解耦的编程思想，不愧是大神…</p>
<p>还有一点需要注意：我们之前的setProgress和这个KVO监听，都是在我们AF自定义的delegate内的，是<strong>有一个task就会有一个delegate的。所以说我们是每个task都会去监听这些属性，分别在各自的AF代理内。</strong>看到这，可能有些小伙伴会有点乱，没关系。等整个讲完之后我们还会详细的去讲捋一捋manager、task、还有AF自定义代理三者之前的对应关系。</p>
<p>到这里我们整个对task的处理就完成了。</p>
<h2 id="2-3-AFURLSessionManager中Session代理实现及转发"><a href="#2-3-AFURLSessionManager中Session代理实现及转发" class="headerlink" title="2.3 AFURLSessionManager中Session代理实现及转发"></a>2.3 AFURLSessionManager中Session代理实现及转发</h2><h3 id="2-3-1-代理方法概览"><a href="#2-3-1-代理方法概览" class="headerlink" title="2.3.1 代理方法概览"></a>2.3.1 代理方法概览</h3><p>接着task就开始请求网络了，还记得我们初始化方法中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:<span class="keyword">self</span>.sessionConfiguration delegate:<span class="keyword">self</span> delegateQueue:<span class="keyword">self</span>.operationQueue];</span><br></pre></td></tr></table></figure>

<p>我们把AFUrlSessionManager作为了所有的task的delegate。当我们请求网络的时候，下图这些NSUrlSession的代理开始调用了：</p>
<img src="/images/AFN/AFN-04.jpg" alt="img" style="zoom:60%;" />

<p>AFUrlSessionManager一共实现了如上图所示这么一大堆NSUrlSession相关的代理。（小伙伴们的顺序可能不一样，楼主根据代理隶属重新排序了一下）</p>
<p>而只转发了其中3条到下图中AF自定义的delegate中：</p>
<img src="/images/AFN/AFN-05.jpg" alt="img" style="zoom:60%;" />

<p>这就是我们一开始说的，AFUrlSessionManager对这一大堆代理做了一些公共的处理，而转发到AF自定义代理的3条，则负责把每个task对应的数据回调出去。</p>
<p>又有小伙伴问了，我们设置的这个代理不是<code>NSURLSessionDelegate</code>吗？怎么能响应NSURLSession这么多代理呢？我们点到NSURLSession.h中去看看：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionTaskDelegate</span> &lt;<span class="title">NSURLSessionDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDataDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionDownloadDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">NSURLSessionStreamDelegate</span> &lt;<span class="title">NSURLSessionTaskDelegate</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>我们可以看到这些代理都是继承关系，而在<code>NSURLSession</code>实现中，只要设置了这个代理，它会去判断这些所有的代理，是否<code>respondsToSelector</code>这些代理中的方法，如果响应了就会去调用。</p>
<p>而AF还重写了<code>respondsToSelector</code>方法:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)respondsToSelector:(SEL)selector &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//复写了selector的方法，这几个方法是在本类有实现的，但这些代理方法实现中只执行了这些自定义的Block，如果Block都没有赋值，那我们调用代理也没有任何意义。所以返回NO，相当于没有实现！也就不会去回调这些代理。</span></span><br><span class="line">    <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.taskWillPerformHTTPRedirection != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:dataTask:didReceiveResponse:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.dataTaskDidReceiveResponse != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSession:dataTask:willCacheResponse:completionHandler:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.dataTaskWillCacheResponse != nil;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (selector == <span class="meta">@selector(URLSessionDidFinishEventsForBackgroundURLSession:)</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> self.didFinishEventsForBackgroundURLSession != nil;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [[self <span class="class"><span class="keyword">class</span>] <span class="title">instancesRespondToSelector</span>:<span class="type">selector];</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>讲到这，我们顺便看看AFURLSessionManager的一些自定义Block：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidBecomeInvalidBlock sessionDidBecomeInvalid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidReceiveAuthenticationChallengeBlock sessionDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDidFinishEventsForBackgroundURLSessionBlock didFinishEventsForBackgroundURLSession;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskWillPerformHTTPRedirectionBlock taskWillPerformHTTPRedirection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidReceiveAuthenticationChallengeBlock taskDidReceiveAuthenticationChallenge;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskNeedNewBodyStreamBlock taskNeedNewBodyStream;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidSendBodyDataBlock taskDidSendBodyData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionTaskDidCompleteBlock taskDidComplete;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveResponseBlock dataTaskDidReceiveResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidBecomeDownloadTaskBlock dataTaskDidBecomeDownloadTask;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskDidReceiveDataBlock dataTaskDidReceiveData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDataTaskWillCacheResponseBlock dataTaskWillCacheResponse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidFinishDownloadingBlock downloadTaskDidFinishDownloading;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidWriteDataBlock downloadTaskDidWriteData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) AFURLSessionDownloadTaskDidResumeBlock downloadTaskDidResume;</span><br></pre></td></tr></table></figure>

<p>各自对应的还有一堆这样的set方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block &#123;</span><br><span class="line">    <span class="keyword">self</span>.sessionDidBecomeInvalid = block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法都是一样的，就不重复粘贴占篇幅了。主要谈谈这个设计思路</p>
<ul>
<li>作者用@property把这些Block属性在.m文件中声明，然后复写了set方法。</li>
<li>然后在.h中去声明这些set方法：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setSessionDidBecomeInvalidBlock:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLSession</span> *session, <span class="built_in">NSError</span> *error))block;</span><br></pre></td></tr></table></figure>

<p>为什么要绕这么一大圈呢？<strong>原来这是为了我们这些用户使用起来方便，调用set方法去设置这些Block，能很清晰的看到Block的各个参数与返回值。</strong>大神的精髓的编程思想无处不体现…</p>
<p>接下来我们就讲讲这些代理方法做了什么（按照顺序来）：</p>
<h3 id="2-3-2-NSURLSessionDelegate实现"><a href="#2-3-2-NSURLSessionDelegate实现" class="headerlink" title="2.3.2 NSURLSessionDelegate实现"></a>2.3.2 NSURLSessionDelegate实现</h3><h4 id="01-URLSession-didBecomeInvalidWithError"><a href="#01-URLSession-didBecomeInvalidWithError" class="headerlink" title="01. URLSession:didBecomeInvalidWithError"></a>01. URLSession:didBecomeInvalidWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前这个session已经失效时，该代理方法被调用。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 如果你使用finishTasksAndInvalidate函数使该session失效，</span></span><br><span class="line"><span class="comment"> 那么session首先会先完成最后一个task，然后再调用URLSession:didBecomeInvalidWithError:代理方法，</span></span><br><span class="line"><span class="comment"> 如果你调用invalidateAndCancel方法来使session失效，那么该session会立即调用上面的代理方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didBecomeInvalidWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidBecomeInvalid) &#123;</span><br><span class="line">        <span class="keyword">self</span>.sessionDidBecomeInvalid(session, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDidInvalidateNotification object:session];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法调用时机注释写的很清楚，就调用了一下我们自定义的Block,还发了一个失效的通知，至于这个通知有什么用。很抱歉，AF没用它做任何事，只是发了…目的是用户自己可以利用这个通知做什么事吧。</li>
<li>其实AF大部分通知都是如此。当然，还有一部分通知AF还是有自己用到的，包括配合对UIKit的一些扩展来使用，后面我们会有单独篇幅展开讲讲这些UIKit的扩展类的实现。</li>
</ul>
<h4 id="02-URLSession-didReceiveChallenge"><a href="#02-URLSession-didReceiveChallenge" class="headerlink" title="02. URLSession:didReceiveChallenge"></a>02. URLSession:didReceiveChallenge</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、用作https认证的，详细看第四节AFSecurityPolicy</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="03-URLSessionDidFinishEventsForBackgro"><a href="#03-URLSessionDidFinishEventsForBackgro" class="headerlink" title="03. URLSessionDidFinishEventsForBackgro.."></a>03. URLSessionDidFinishEventsForBackgro..</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3、 当session中所有已经入队的消息被发送出去后，会调用该代理方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSessionDidFinishEventsForBackgroundURLSession:(<span class="built_in">NSURLSession</span> *)session &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.didFinishEventsForBackgroundURLSession) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">self</span>.didFinishEventsForBackgroundURLSession(session);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方文档翻译：</p>
<ul>
<li>函数讨论：<ul>
<li>在iOS中，当一个后台传输任务完成或者后台传输时需要证书，而此时你的app正在后台挂起，那么你的app在后台会自动重新启动运行，并且这个app的UIApplicationDelegate会发送一个application:handleEventsForBackgroundURLSession:completionHandler: 消息。该消息包含了对应后台的session的identifier，而且这个消息会导致你的app启动。你的app随后应该先存储completion handler，然后再使用相同的identifier创建一个background configuration，并根据这个background configuration创建一个新的session。这个新创建的session会自动与后台任务重新关联在一起。</li>
<li>当你的app获取了一个URLSessionDidFinishEventsForBackgroundURLSession:消息，这就意味着之前这个session中已经入队的所有消息都转发出去了，这时候再调用先前存取的completion handler是安全的，或者因为内部更新而导致调用completion handler也是安全的。</li>
</ul>
</li>
</ul>
<h3 id="2-3-3-NSURLSessionTaskDelegate实现"><a href="#2-3-3-NSURLSessionTaskDelegate实现" class="headerlink" title="2.3.3 NSURLSessionTaskDelegate实现"></a>2.3.3 NSURLSessionTaskDelegate实现</h3><h4 id="04-URLSession-task-willPerformHTTPRedirection"><a href="#04-URLSession-task-willPerformHTTPRedirection" class="headerlink" title="04. URLSession:task:willPerformHTTPRedirection"></a>04. URLSession:task:willPerformHTTPRedirection</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被服务器重定向的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">willPerformHTTPRedirection:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">        newRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLRequest</span> *redirectRequest = request;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// step1. 看是否有对应的user block 有的话转发出去，通过这4个参数，返回一个NSURLRequest类型参数，request转发、网络重定向.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskWillPerformHTTPRedirection) &#123;</span><br><span class="line">        <span class="comment">//用自己自定义的一个重定向的block实现，返回一个新的request。</span></span><br><span class="line">        redirectRequest = <span class="keyword">self</span>.taskWillPerformHTTPRedirection(session, task, response, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        <span class="comment">// step2. 用request重新请求</span></span><br><span class="line">        completionHandler(redirectRequest);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始我以为这个方法是类似<code>NSURLProtocol</code>，可以在请求时自己主动的去重定向request，后来发现不是，这个方法是在服务器去重定向的时候，才会被调用。为此我写了段简单的PHP测了测：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">defined(<span class="string">&#x27;BASEPATH&#x27;</span>) <span class="keyword">OR</span> <span class="keyword">exit</span>(<span class="string">&#x27;No direct script access allowed&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">CI_Controller</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">index</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        header(<span class="string">&quot;location: http://www.huixionghome.cn/&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>证实确实如此，当我们服务器重定向的时候，代理就被调用了，我们可以去重新定义这个重定向的request。</p>
<p>关于这个代理还有一些需要注意的地方：此方法只会在default session或者ephemeral session中调用，而在background session中，session task会自动重定向。（这里指的模式是我们一开始初始化 session时的模式）。</p>
<h4 id="05-URLSession-task-didReceiveChallenge"><a href="#05-URLSession-task-didReceiveChallenge" class="headerlink" title="05.URLSession:task:didReceiveChallenge"></a>05.URLSession:task:didReceiveChallenge</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//https认证</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.taskDidReceiveAuthenticationChallenge(session, task, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>;</span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>鉴于篇幅，就不去贴官方文档的翻译了，大概总结一下：</p>
<ul>
<li>之前我们也有一个https认证，功能一样，执行的内容也完全一样。</li>
<li>区别在于这个是non-session-level级别的认证，而之前的是session-level级别的。</li>
<li>相对于它，多了一个参数task,然后调用我们自定义的Block会多回传这个task作为参数，这样我们就可以根据每个task去自定义我们需要的https认证方式。</li>
</ul>
<h4 id="06-URLSession-task-needNewBodyStream"><a href="#06-URLSession-task-needNewBodyStream" class="headerlink" title="06. URLSession:task:needNewBodyStream"></a>06. URLSession:task:needNewBodyStream</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当一个session task需要发送一个新的request body stream到服务器端的时候，调用该代理方法。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line"> needNewBodyStream:(<span class="keyword">void</span> (^)(<span class="built_in">NSInputStream</span> *bodyStream))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">NSInputStream</span> *inputStream = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有自定义的taskNeedNewBodyStream,用自定义的，不然用task里原始的stream</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskNeedNewBodyStream) &#123;</span><br><span class="line">        inputStream = <span class="keyword">self</span>.taskNeedNewBodyStream(session, task);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.originalRequest.HTTPBodyStream &amp;&amp; [task.originalRequest.HTTPBodyStream conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">NSCopying</span>)]) </span>&#123;</span><br><span class="line">        inputStream = [task.originalRequest.HTTPBodyStream <span class="keyword">copy</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(inputStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该代理方法会在下面两种情况被调用：</p>
<ol>
<li>如果task是由uploadTaskWithStreamedRequest:创建的，那么提供初始的request body stream时候会调用该代理方法。</li>
<li>因为认证挑战或者其他可恢复的服务器错误，而导致需要客户端重新发送一个含有body stream的request，这时候会调用该代理。</li>
</ol>
<h4 id="07-URLSession-task-didSendBodyData"><a href="#07-URLSession-task-didSendBodyData" class="headerlink" title="07. URLSession:task:didSendBodyData"></a>07. URLSession:task:didSendBodyData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 周期性地通知代理发送到服务器端数据的进度。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">   didSendBodyData:(int64_t)bytesSent</span><br><span class="line">    totalBytesSent:(int64_t)totalBytesSent</span><br><span class="line">totalBytesExpectedToSend:(int64_t)totalBytesExpectedToSend</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 如果totalUnitCount获取失败，就使用HTTP header中的Content-Length作为totalUnitCount</span></span><br><span class="line"></span><br><span class="line">    int64_t totalUnitCount = totalBytesExpectedToSend;</span><br><span class="line">    <span class="keyword">if</span>(totalUnitCount == <span class="built_in">NSURLSessionTransferSizeUnknown</span>) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *contentLength = [task.originalRequest valueForHTTPHeaderField:<span class="string">@&quot;Content-Length&quot;</span>];</span><br><span class="line">        <span class="keyword">if</span>(contentLength) &#123;</span><br><span class="line">            totalUnitCount = (int64_t) [contentLength longLongValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidSendBodyData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidSendBodyData(session, task, bytesSent, totalBytesSent, totalUnitCount);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>就是每次发送数据给服务器，会回调这个方法，通知已经发送了多少，总共要发送多少。</li>
<li>代理方法里也就是仅仅调用了我们自定义的Block而已。</li>
</ul>
<h4 id="08-URLSession-task-didCompleteWithError"><a href="#08-URLSession-task-didCompleteWithError" class="headerlink" title="08. URLSession:task:didCompleteWithError"></a>08. URLSession:task:didCompleteWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> task完成之后的回调，成功和失败都会回调这里</span></span><br><span class="line"><span class="comment"> 函数讨论：</span></span><br><span class="line"><span class="comment">     注意这里的error不会报告服务期端的error，他表示的是客户端这边的error，比如无法解析hostname或者连不上host主机。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;   </span><br><span class="line">    <span class="comment">//根据task去取我们一开始创建绑定的delegate</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegate may be nil when completing a task in the background</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        <span class="comment">//把代理转发给我们绑定的delegate</span></span><br><span class="line">        [delegate URLSession:session task:task didCompleteWithError:error];</span><br><span class="line">        <span class="comment">//转发完移除delegate</span></span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:task];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义Block回调</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.taskDidComplete) &#123;</span><br><span class="line">        <span class="keyword">self</span>.taskDidComplete(session, task, error);</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代理就是task完成了的回调，方法内做了下面这几件事：</p>
<ul>
<li><p>在这里我们拿到了之前和这个task对应绑定的AF的delegate:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (AFURLSessionManagerTaskDelegate *)delegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line"></span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = <span class="literal">nil</span>;</span><br><span class="line">  [<span class="keyword">self</span>.lock lock];</span><br><span class="line">  delegate = <span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier[@(task.taskIdentifier)];</span><br><span class="line">  [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> delegate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>去转发了调用了AF代理的方法。这个等我们下面讲完NSUrlSession的代理之后会详细说。</p>
</li>
<li><p>然后把这个AF的代理和task的绑定解除了，并且移除了相关的progress和通知：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)removeDelegateForTask:(<span class="built_in">NSURLSessionTask</span> *)task &#123;</span><br><span class="line">  <span class="built_in">NSParameterAssert</span>(task);</span><br><span class="line">  <span class="comment">//移除跟AF代理相关的东西</span></span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:task];</span><br><span class="line">  [<span class="keyword">self</span>.lock lock];</span><br><span class="line">  [delegate cleanUpProgressForTask:task];</span><br><span class="line">  [<span class="keyword">self</span> removeNotificationObserverForTask:task];</span><br><span class="line">  [<span class="keyword">self</span>.mutableTaskDelegatesKeyedByTaskIdentifier removeObjectForKey:@(task.taskIdentifier)];</span><br><span class="line">  [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>调用了自定义的Blcok:self.taskDidComplete(session, task, error);</p>
<p>代码还是很简单的，至于这个通知，我们等会再来补充吧。</p>
</li>
</ul>
<h3 id="2-3-4-NSURLSessionDataDelegate实现"><a href="#2-3-4-NSURLSessionDataDelegate实现" class="headerlink" title="2.3.4 NSURLSessionDataDelegate实现"></a>2.3.4 NSURLSessionDataDelegate实现</h3><h4 id="09-URLSession-dataTask-didReceiveResponse"><a href="#09-URLSession-dataTask-didReceiveResponse" class="headerlink" title="09. URLSession:dataTask:didReceiveResponse"></a>09. URLSession:dataTask:didReceiveResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到服务器响应后调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置默认为继续进行</span></span><br><span class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义去设置</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveResponse) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.dataTaskDidReceiveResponse(session, dataTask, response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方文档翻译如下：</p>
<p>函数作用：告诉代理，该data task获取到了服务器端传回的最初始回复（response）。注意其中的completionHandler这个block，通过传入一个类型为NSURLSessionResponseDisposition的变量来决定该传输任务接下来该做什么：</p>
<ul>
<li>NSURLSessionResponseAllow 该task正常进行</li>
<li>NSURLSessionResponseCancel 该task会被取消</li>
<li>NSURLSessionResponseBecomeDownload 会调用URLSession:dataTask:didBecomeDownloadTask:方法来新建一个download task以代替当前的data task</li>
<li>NSURLSessionResponseBecomeStream 转成一个StreamTask</li>
</ul>
<p>函数讨论：</p>
<p>该方法是可选的，除非你必须支持“multipart/x-mixed-replace”类型的content-type。因为如果你的request中包含了这种类型的content-type，服务器会将数据分片传回来，而且每次传回来的数据会覆盖之前的数据。每次返回新的数据时，session都会调用该函数，你应该在这个函数中合理地处理先前的数据，否则会被新数据覆盖。如果你没有提供该方法的实现，那么session将会继续任务，也就是说会覆盖之前的数据。</p>
<p>总结一下：</p>
<ul>
<li>当你把添加content-type的类型为 multipart/x-mixed-replace 那么服务器的数据会分片的传回来。然后这个方法是每次接受到对应片响应的时候会调被调用。你可以去设置上述4种对这个task的处理。</li>
<li>如果我们实现了自定义Block，则调用一下，不然就用默认的NSURLSessionResponseAllow方式。</li>
</ul>
<h4 id="10-URLSession-dataTask-didBecomeDownloadTask"><a href="#10-URLSession-dataTask-didBecomeDownloadTask" class="headerlink" title="10. URLSession:dataTask:didBecomeDownloadTask"></a>10. URLSession:dataTask:didBecomeDownloadTask</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面的代理如果设置为NSURLSessionResponseBecomeDownload，则会触发调用这个方法，作用就是新建一个downloadTask，替换掉当前的dataTask。所以我们在这里做了AF自定义代理的重新绑定操作。</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didBecomeDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//因为转变了task，所以要对task做一个重新绑定</span></span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [<span class="keyword">self</span> removeDelegateForTask:dataTask];</span><br><span class="line">        [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行自定义Block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidBecomeDownloadTask) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidBecomeDownloadTask(session, dataTask, downloadTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>按照顺序来，其实还有个AF没有去实现的代理：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AF没实现的代理</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">didBecomeStreamTask:(<span class="built_in">NSURLSessionStreamTask</span> *)streamTask;</span><br></pre></td></tr></table></figure>

<p>这个也是之前的那个代理，设置为NSURLSessionResponseBecomeStream则会调用到这个代理里来。会新生成一个NSURLSessionStreamTask来替换掉之前的dataTask。</p>
<h4 id="11-URLSession-dataTask-didReceiveData"><a href="#11-URLSession-dataTask-didReceiveData" class="headerlink" title="11. URLSession:dataTask:didReceiveData"></a>11. URLSession:dataTask:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当我们获取到数据就会调用，会被反复调用，请求到的数据就在这被拼装完整</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:dataTask];</span><br><span class="line">    [delegate URLSession:session dataTask:dataTask didReceiveData:data];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskDidReceiveData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.dataTaskDidReceiveData(session, dataTask, data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法和上面didCompleteWithError算是NSUrlSession的代理中最重要的两个方法了。</p>
<p>我们转发了这个方法到AF的代理中去，所以数据的拼接都是在AF的代理中进行的。这也是情理中的，毕竟每个响应数据都是对应各个task，各个AF代理的。在AFURLSessionManager都只是做一些公共的处理。</p>
<h4 id="12-URLSession-dataTask-willCacheResponse"><a href="#12-URLSession-dataTask-willCacheResponse" class="headerlink" title="12. URLSession:dataTask:willCacheResponse"></a>12. URLSession:dataTask:willCacheResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*当task接收到所有期望的数据后，session会调用此代理方法。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line"> willCacheResponse:(<span class="built_in">NSCachedURLResponse</span> *)proposedResponse</span><br><span class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSCachedURLResponse</span> *cachedResponse))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSCachedURLResponse</span> *cachedResponse = proposedResponse;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTaskWillCacheResponse) &#123;</span><br><span class="line">        cachedResponse = <span class="keyword">self</span>.dataTaskWillCacheResponse(session, dataTask, proposedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(cachedResponse);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方文档翻译如下：</p>
<ul>
<li>函数作用：<ul>
<li>询问data task或上传任务（upload task）是否缓存response。</li>
</ul>
</li>
<li>函数讨论：<ul>
<li>当task接收到所有期望的数据后，session会调用此代理方法。如果你没有实现该方法，那么就会使用创建session时使用的configuration对象决定缓存策略。这个代理方法最初的目的是为了阻止缓存特定的URLs或者修改NSCacheURLResponse对象相关的userInfo字典。</li>
<li>该方法只会当request决定缓存response时候调用。作为准则，responses只会当以下条件都成立的时候返回缓存：<ul>
<li>该request是HTTP或HTTPS URL的请求（或者你自定义的网络协议，并且确保该协议支持缓存）</li>
<li>确保request请求是成功的（返回的status code为200-299）</li>
<li>返回的response是来自服务器端的，而非缓存中本身就有的</li>
<li>提供的NSURLRequest对象的缓存策略要允许进行缓存</li>
<li>服务器返回的response中与缓存相关的header要允许缓存</li>
<li>该response的大小不能比提供的缓存空间大太多（比如你提供了一个磁盘缓存，那么response大小一定不能比磁盘缓存空间还要大5%）</li>
</ul>
</li>
</ul>
</li>
<li>总结一下就是一个用来缓存response的方法，方法中调用了我们自定义的Block，自定义一个response用来缓存。</li>
</ul>
<h3 id="2-3-5-NSURLSessionDownloadDelegate实现"><a href="#2-3-5-NSURLSessionDownloadDelegate实现" class="headerlink" title="2.3.5 NSURLSessionDownloadDelegate实现"></a>2.3.5 NSURLSessionDownloadDelegate实现</h3><h4 id="13-URLSession-downloadTask-didFinishDown…"><a href="#13-URLSession-downloadTask-didFinishDown…" class="headerlink" title="13. URLSession:downloadTask:didFinishDown…"></a>13. URLSession:downloadTask:didFinishDown…</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下载完成的时候调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    AFURLSessionManagerTaskDelegate *delegate = [<span class="keyword">self</span> delegateForTask:downloadTask];</span><br><span class="line">    <span class="comment">//这个是session的，也就是全局的，后面的个人代理也会做同样的这件事</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用自定义的block拿到文件存储的地址</span></span><br><span class="line">        <span class="built_in">NSURL</span> *fileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line">        <span class="keyword">if</span> (fileURL) &#123;</span><br><span class="line">            delegate.downloadFileURL = fileURL;</span><br><span class="line">            <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">            <span class="comment">//从临时的下载路径移动至我们需要的路径</span></span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:fileURL error:&amp;error];</span><br><span class="line">            <span class="comment">//如果移动出错</span></span><br><span class="line">            <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:error.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//转发代理</span></span><br><span class="line">    <span class="keyword">if</span> (delegate) &#123;</span><br><span class="line">        [delegate URLSession:session downloadTask:downloadTask didFinishDownloadingToURL:location];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法和之前的两个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)taskdidCompleteWithError:(<span class="built_in">NSError</span> *)error;</span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data;</span><br></pre></td></tr></table></figure>

<p>总共就这3个方法，被转调到AF自定义delegate中。</p>
<p>方法做了什么看注释应该很简单，就不赘述了。</p>
<h4 id="14-URLSession-downloadTask-didWriteData"><a href="#14-URLSession-downloadTask-didWriteData" class="headerlink" title="14. URLSession:downloadTask:didWriteData"></a>14. URLSession:downloadTask:didWriteData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//周期性地通知下载进度调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">      didWriteData:(int64_t)bytesWritten</span><br><span class="line"> totalBytesWritten:(int64_t)totalBytesWritten</span><br><span class="line">totalBytesExpectedToWrite:(int64_t)totalBytesExpectedToWrite</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidWriteData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidWriteData(session, downloadTask, bytesWritten, totalBytesWritten, totalBytesExpectedToWrite);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单说一下这几个参数:</p>
<ul>
<li>bytesWritten表示自上次调用该方法后，接收到的数据字节数</li>
<li>totalBytesWritten表示目前已经接收到的数据字节数</li>
<li>totalBytesExpectedToWrite表示期望收到的文件总字节数，是由Content-Length header提供。如果没有提供，默认是NSURLSessionTransferSizeUnknown。</li>
</ul>
<h4 id="15-URLSession-downloadTask-didResumeAtOffset"><a href="#15-URLSession-downloadTask-didResumeAtOffset" class="headerlink" title="15. URLSession:downloadTask:didResumeAtOffset"></a>15. URLSession:downloadTask:didResumeAtOffset</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当下载被取消或者失败后重新恢复下载时调用</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line"> didResumeAtOffset:(int64_t)fileOffset</span><br><span class="line">expectedTotalBytes:(int64_t)expectedTotalBytes</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//交给自定义的Block去调用</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidResume) &#123;</span><br><span class="line">        <span class="keyword">self</span>.downloadTaskDidResume(session, downloadTask, fileOffset, expectedTotalBytes);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>官方文档翻译：</p>
<ul>
<li>函数作用：<ul>
<li>告诉代理，下载任务重新开始下载了。</li>
</ul>
</li>
<li>函数讨论：<ul>
<li>如果一个正在下载任务被取消或者失败了，你可以请求一个resumeData对象（比如在userInfo字典中通过NSURLSessionDownloadTaskResumeData这个键来获取到resumeData）并使用它来提供足够的信息以重新开始下载任务。<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 取消任务</span></span><br><span class="line">[<span class="keyword">self</span>.downloadTask cancelByProducingResumeData:^(<span class="built_in">NSData</span> * _Nullable resumeData) &#123;</span><br><span class="line">    [resumeData writeToFile:<span class="string">@&quot;本地路径&quot;</span> atomically:<span class="literal">YES</span>];</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">// 任务失败 error的userinfo属性可通过NSURLSessionDownloadTaskResumeData key来取resumeData</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">      <span class="keyword">if</span> ([error.userInfo objectForKey:<span class="built_in">NSURLSessionDownloadTaskResumeData</span>]) &#123;</span><br><span class="line">          <span class="built_in">NSData</span> *resumeData = [error.userInfo objectForKey:<span class="built_in">NSURLSessionDownloadTaskResumeData</span>];</span><br><span class="line">          <span class="comment">//通过之前保存的resumeData，获取断点的NSURLSessionTask，调用resume恢复下载</span></span><br><span class="line">          <span class="keyword">self</span>.downloadTask = [<span class="keyword">self</span>.backgroundSession downloadTaskWithResumeData: resumeData];</span><br><span class="line">          [<span class="keyword">self</span>.downloadTask resume];</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>随后，你可以使用resumeData作为downloadTaskWithResumeData:或downloadTaskWithResumeData:completionHandler:的参数。当你调用这些方法时，你将开始一个新的下载任务。一旦你继续下载任务，session会调用它的代理方法URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:其中的downloadTask参数表示的就是新的下载任务，这也意味着下载重新开始了。</li>
</ul>
</li>
</ul>
<p>总结一下：</p>
<ul>
<li><strong>其实这个就是用来做断点续传的代理方法。</strong>可以在下载失败的时候，拿到我们失败的拼接的部分resumeData，然后用去调用downloadTaskWithResumeData：就会调用到这个代理方法来了。</li>
<li>其中注意：fileOffset这个参数，如果文件缓存策略或者最后文件更新日期阻止重用已经存在的文件内容，那么该值为0。否则，该值表示当前已经下载data的偏移量。</li>
<li>方法中仅仅调用了downloadTaskDidResume自定义Block。</li>
</ul>
<p>至此NSUrlSesssion的delegate讲完了。大概总结下：</p>
<ul>
<li>每个代理方法对应一个我们自定义的Block,如果Block被赋值了，那么就调用它。</li>
<li>在这些代理方法里，我们做的处理都是相对于这个sessionManager所有的request的。<strong>是公用的处理。</strong></li>
<li>转发了3个代理方法到AF的deleagate中去了，AF中的deleagate是需要对应每个task去<strong>私有化处理的</strong>。</li>
</ul>
<h3 id="2-3-6-转发到AFURLSxxMxxTaskDelegate的方法"><a href="#2-3-6-转发到AFURLSxxMxxTaskDelegate的方法" class="headerlink" title="2.3.6 转发到AFURLSxxMxxTaskDelegate的方法"></a>2.3.6 转发到AFURLSxxMxxTaskDelegate的方法</h3><p>接下来我们来看从 AFURLSessionManager 中转发到 AFURLSessionManagerTaskDelegate 的deleagate，一共3个方法：</p>
<h4 id="1-URLSession-task-didCompleteWithError"><a href="#1-URLSession-task-didCompleteWithError" class="headerlink" title="1. URLSession:task:didCompleteWithError"></a>1. URLSession:task:didCompleteWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AF实现的代理！被从urlsession那转发到这</span></span><br><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">              task:(<span class="built_in">NSURLSessionTask</span> *)task</span><br><span class="line">didCompleteWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1）强引用self.manager，防止被提前释放；因为self.manager声明为weak,类似Block</span></span><br><span class="line"></span><br><span class="line">    __<span class="keyword">strong</span> AFURLSessionManager *manager = <span class="keyword">self</span>.manager;</span><br><span class="line"></span><br><span class="line">    __block <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用来存储一些相关信息，来发送通知用的</span></span><br><span class="line">    __block <span class="built_in">NSMutableDictionary</span> *userInfo = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">    <span class="comment">//存储responseSerializer响应解析对象</span></span><br><span class="line">    userInfo[AFNetworkingTaskDidCompleteResponseSerializerKey] = manager.responseSerializer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Performance Improvement from #2672</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意这行代码的用法，感觉写的很Nice...把请求到的数据data传出去，然后就不要这个值了释放内存</span></span><br><span class="line">    <span class="built_in">NSData</span> *data = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.mutableData) &#123;</span><br><span class="line">        data = [<span class="keyword">self</span>.mutableData <span class="keyword">copy</span>];</span><br><span class="line">        <span class="comment">//We no longer need the reference, so nil it out to gain back some memory.</span></span><br><span class="line">        <span class="keyword">self</span>.mutableData = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//继续给userinfo填数据</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteAssetPathKey] = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (data) &#123;</span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteResponseDataKey] = data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//错误处理</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line"></span><br><span class="line">        userInfo[AFNetworkingTaskDidCompleteErrorKey] = error;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//可以自己自定义完成组 和自定义完成queue,完成回调</span></span><br><span class="line">        dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                <span class="keyword">self</span>.completionHandler(task.response, responseObject, error);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//主线程中发送完成通知</span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//url_session_manager_processing_queue AF的并行队列</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(url_session_manager_processing_queue(), ^&#123;</span><br><span class="line">            <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//解析数据</span></span><br><span class="line">            responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果是下载文件，那么responseObject为下载的路径</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">                responseObject = <span class="keyword">self</span>.downloadFileURL;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//写入userInfo</span></span><br><span class="line">            <span class="keyword">if</span> (responseObject) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteSerializedResponseKey] = responseObject;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//如果解析错误</span></span><br><span class="line">            <span class="keyword">if</span> (serializationError) &#123;</span><br><span class="line">                userInfo[AFNetworkingTaskDidCompleteErrorKey] = serializationError;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//回调结果</span></span><br><span class="line">            dispatch_group_async(manager.completionGroup ?: url_session_manager_completion_group(), manager.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.completionHandler) &#123;</span><br><span class="line">                    <span class="keyword">self</span>.completionHandler(task.response, responseObject, serializationError);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法是NSURLSession任务完成的代理方法中，主动调用过来的。配合注释，应该代码很容易读，这个方法大概做了以下几件事：</p>
<ol>
<li><p>生成了一个存储这个task相关信息的字典：userInfo，这个字典是用来作为发送任务完成的通知的参数。</p>
</li>
<li><p>判断了参数error的值，来区分请求成功还是失败。</p>
</li>
<li><p>如果成功则在一个AF的并行queue中，去做数据解析等后续操作：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> url_session_manager_processing_queue() &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_queue_t</span> af_url_session_manager_processing_queue;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      af_url_session_manager_processing_queue = dispatch_queue_create(<span class="string">&quot;com.alamofire.networking.session.manager.processing&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> af_url_session_manager_processing_queue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意AF的优化的点：<font color='red'>虽然代理回调是串行的(参考2.1.2小节 maxConcurrentOperationCount属性)。但是数据解析这种费时操作，确是用并行线程来做的。</font></p>
</li>
<li><p>然后根据我们一开始设置的responseSerializer来解析data。如果解析成功，调用成功的回调，否则调用失败的回调。我们重点来看看返回数据解析这行：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">responseObject = [manager.responseSerializer responseObjectForResponse:task.response data:data error:&amp;serializationError];</span><br></pre></td></tr></table></figure>

<p>我们点进去看看：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                         data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                        error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error <span class="built_in">NS_SWIFT_NOTHROW</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>原来就是这么一个协议方法，各种类型的responseSerializer类，都是遵守这个协议方法，实现了一个把我们请求到的data转换为我们需要的类型的数据的方法。至于各种类型的responseSerializer如何解析数据，我们到代理讲完再来补充。</p>
</li>
<li><p>这边还做了一个判断，如果自定义了GCD完成组completionGroup和完成队列的话completionQueue，会在加入这个组和在队列中回调Block。否则默认的是AF的创建的组：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> dispatch_group_t url_session_manager_completion_group() &#123;</span><br><span class="line">  <span class="keyword">static</span> dispatch_group_t af_url_session_manager_completion_group;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">  <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">      af_url_session_manager_completion_group = dispatch_group_create();</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> af_url_session_manager_completion_group;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和主队列回调。<strong>AF没有用这个GCD组做任何处理，只是提供这个接口，让我们有需求的自行调用处理。</strong>如果有对多个任务完成度的监听，可以自行处理。<br>而队列的话，如果你不需要回调主线程，可以自己设置一个回调队列。</p>
</li>
<li><p>回到主线程，发送了任务完成的通知：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">              [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingTaskDidCompleteNotification object:task userInfo:userInfo];</span><br><span class="line">          &#125;);</span><br></pre></td></tr></table></figure>

<p>这个通知这回AF有用到了，在我们对UIKit的扩展中，用到了这个通知。</p>
</li>
</ol>
<h4 id="2-URLSession-dataTask-didReceiveData"><a href="#2-URLSession-dataTask-didReceiveData" class="headerlink" title="2. URLSession:dataTask:didReceiveData"></a>2. URLSession:dataTask:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(__unused <span class="built_in">NSURLSession</span> *)session</span><br><span class="line">          dataTask:(__unused <span class="built_in">NSURLSessionDataTask</span> *)dataTask</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拼接数据</span></span><br><span class="line">    [<span class="keyword">self</span>.mutableData appendData:data];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样被NSUrlSession代理转发到这里，拼接了需要回调的数据。</p>
<h4 id="3-URLSession-downloadTask-didFinishDownload…"><a href="#3-URLSession-downloadTask-didFinishDownload…" class="headerlink" title="3. URLSession:downloadTask:didFinishDownload…"></a>3. URLSession:downloadTask:didFinishDownload…</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">      downloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">didFinishDownloadingToURL:(<span class="built_in">NSURL</span> *)location</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSError</span> *fileManagerError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">self</span>.downloadFileURL = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//AF代理的自定义Block</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadTaskDidFinishDownloading) &#123;</span><br><span class="line">        <span class="comment">//得到自定义下载路径</span></span><br><span class="line">        <span class="keyword">self</span>.downloadFileURL = <span class="keyword">self</span>.downloadTaskDidFinishDownloading(session, downloadTask, location);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadFileURL) &#123;</span><br><span class="line">            <span class="comment">//把下载路径移动到我们自定义的下载路径</span></span><br><span class="line">            [[<span class="built_in">NSFileManager</span> defaultManager] moveItemAtURL:location toURL:<span class="keyword">self</span>.downloadFileURL error:&amp;fileManagerError];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//错误发通知</span></span><br><span class="line">            <span class="keyword">if</span> (fileManagerError) &#123;</span><br><span class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFURLSessionDownloadTaskDidFailToMoveFileNotification object:downloadTask userInfo:fileManagerError.userInfo];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下载成功了被NSUrlSession代理转发到这里，这里有个地方需要注意下：</p>
<ul>
<li><p>之前的NSUrlSession代理和这里都移动了文件到下载路径，而NSUrlSession代理的下载路径是所有request公用的下载路径，一旦设置，所有的request都会下载到之前那个路径。</p>
</li>
<li><p>而这个是对应的每个task的，每个task可以设置各自下载路径,还记得AFHttpManager的download方法么</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[manager downloadTaskWithRequest:resquest progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> * _Nonnull(<span class="built_in">NSURL</span> * _Nonnull targetPath, <span class="built_in">NSURLResponse</span> * _Nonnull response) &#123;</span><br><span class="line">  <span class="keyword">return</span> path;</span><br><span class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="built_in">NSURL</span> * _Nullable filePath, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>这个地方return的path就是对应的这个代理方法里的path，我们调用最终会走到这么一个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addDelegateForDownloadTask:(<span class="built_in">NSURLSessionDownloadTask</span> *)downloadTask</span><br><span class="line">                        progress:(<span class="keyword">void</span> (^)(<span class="built_in">NSProgress</span> *downloadProgress)) downloadProgressBlock</span><br><span class="line">                     destination:(<span class="built_in">NSURL</span> * (^)(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response))destination</span><br><span class="line">               completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">  AFURLSessionManagerTaskDelegate *delegate = [[AFURLSessionManagerTaskDelegate alloc] init];</span><br><span class="line">  delegate.manager = <span class="keyword">self</span>;</span><br><span class="line">  delegate.completionHandler = completionHandler;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回地址的Block</span></span><br><span class="line">  <span class="keyword">if</span> (destination) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//有点绕，就是把一个block赋值给我们代理的downloadTaskDidFinishDownloading，这个Block里的内部返回也是调用Block去获取到的，这里面的参数都是AF代理传过去的。</span></span><br><span class="line">      delegate.downloadTaskDidFinishDownloading = ^<span class="built_in">NSURL</span> * (<span class="built_in">NSURLSession</span> * __unused session, <span class="built_in">NSURLSessionDownloadTask</span> *task, <span class="built_in">NSURL</span> *location) &#123;</span><br><span class="line">          <span class="comment">//把Block返回的地址返回</span></span><br><span class="line">          <span class="keyword">return</span> destination(location, task.response);</span><br><span class="line">      &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  downloadTask.taskDescription = <span class="keyword">self</span>.taskDescriptionForSessionTasks;</span><br><span class="line"></span><br><span class="line">  [<span class="keyword">self</span> setDelegate:delegate forTask:downloadTask];</span><br><span class="line"></span><br><span class="line">  delegate.downloadProgressBlock = downloadProgressBlock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>清楚的可以看到地址被赋值给AF的Block了。</p>
</li>
</ul>
<p>至此AF的代理也讲完了，<strong>数据或错误信息随着AF代理成功失败回调，回到了用户的手中。</strong></p>
<h2 id="2-4-AFURLSessionTaskSwizzling类"><a href="#2-4-AFURLSessionTaskSwizzling类" class="headerlink" title="2.4 _AFURLSessionTaskSwizzling类"></a>2.4 _AFURLSessionTaskSwizzling类</h2><p>在AFURLSessionManager中，有这么一个类：_AFURLSessionTaskSwizzling。这个类大概的作用就是替换掉NSURLSession中的resume和suspend方法。正常处理原有逻辑的同时，多发送一个通知，以下是我们需要替换的新方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//被替换掉的方法，只要有TASK开启或者暂停，都会执行</span></span><br><span class="line">- (<span class="keyword">void</span>)af_resume &#123;</span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@&quot;Does not respond to state&quot;</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_resume];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateRunning</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidResumeNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)af_suspend &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSAssert</span>([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(state)], <span class="string">@&quot;Does not respond to state&quot;</span>);</span><br><span class="line">    <span class="built_in">NSURLSessionTaskState</span> state = [<span class="keyword">self</span> state];</span><br><span class="line">    [<span class="keyword">self</span> af_suspend];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state != <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNSURLSessionTaskDidSuspendNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这块知识是关于OC的Runtime:method swizzling的，如果有不清楚的地方，可以看看这里<a target="_blank" rel="noopener" href="http://www.jianshu.com/p/db6dc23834e3">method swizzling–by冰霜</a>或者自行查阅。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">NSClassFromString</span>(<span class="string">@&quot;NSURLSessionTask&quot;</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1) 首先构建一个NSURLSession对象session，再通过session构建出一个_NSCFLocalDataTask变量</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> ephemeralSessionConfiguration];</span><br><span class="line">        <span class="built_in">NSURLSession</span> * session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:configuration];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> GCC diagnostic ignored <span class="meta-string">&quot;-Wnonnull&quot;</span></span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *localDataTask = [session dataTaskWithURL:<span class="literal">nil</span>];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        <span class="comment">// 2) 获取到af_resume实现的指针</span></span><br><span class="line">        IMP originalAFResumeIMP = method_getImplementation(class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(af_resume)));</span><br><span class="line">        Class currentClass = [localDataTask <span class="keyword">class</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3) 检查当前class是否实现了resume。如果实现了，继续第4步。</span></span><br><span class="line">        <span class="keyword">while</span> (class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume))) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 4) 获取到当前class的父类（superClass）</span></span><br><span class="line">            Class superClass = [currentClass superclass];</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 5) 获取到当前class对于resume实现的指针</span></span><br><span class="line">            IMP classResumeIMP = method_getImplementation(class_getInstanceMethod(currentClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 6) 获取到父类对于resume实现的指针</span></span><br><span class="line">            IMP superclassResumeIMP = method_getImplementation(class_getInstanceMethod(superClass, <span class="keyword">@selector</span>(resume)));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。</span></span><br><span class="line">            <span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp;</span><br><span class="line">                originalAFResumeIMP != classResumeIMP) &#123;</span><br><span class="line">                <span class="comment">//执行交换的函数</span></span><br><span class="line">                [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 8) 设置当前操作的class为其父类class，重复步骤3~8</span></span><br><span class="line">            currentClass = [currentClass superclass];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        [localDataTask cancel];</span><br><span class="line">        [session finishTasksAndInvalidate];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原方法中有大量的英文注释，我把它翻译过来如下：</p>
<ul>
<li><p>iOS 7和iOS 8在NSURLSessionTask实现上有些许不同，这使得下面的代码实现略显trick</p>
<p>关于这个问题，大家做了很多Unit Test，足以证明这个方法是可行的</p>
</li>
<li><p>目前我们所知的：</p>
<ul>
<li>NSURLSessionTasks是一组class的统称，如果你仅仅使用提供的API来获取NSURLSessionTask的class，并不一定返回的是你想要的那个（获取NSURLSessionTask的class目的是为了获取其resume方法）</li>
<li>简单地使用[NSURLSessionTask class]并不起作用。你需要新建一个NSURLSession，并根据创建的session再构建出一个NSURLSessionTask对象才行。</li>
<li>iOS 7上，localDataTask（下面代码构造出的NSURLSessionDataTask类型的变量，为了获取对应Class）的类型是 <strong>NSCFLocalDataTask，</strong>NSCFLocalDataTask继承自<strong>NSCFLocalSessionTask，</strong>NSCFLocalSessionTask继承自__NSCFURLSessionTask。</li>
<li>iOS 8上，localDataTask的类型为<strong>NSCFLocalDataTask，</strong>NSCFLocalDataTask继承自<strong>NSCFLocalSessionTask，</strong>NSCFLocalSessionTask继承自NSURLSessionTask</li>
<li>iOS 7上，<strong>NSCFLocalSessionTask和</strong>NSCFURLSessionTask是仅有的两个实现了resume和suspend方法的类，另外<strong>NSCFLocalSessionTask中的resume和suspend并没有调用其父类（即</strong>NSCFURLSessionTask）方法，这也意味着两个类的方法都需要进行method swizzling。</li>
<li>iOS 8上，NSURLSessionTask是唯一实现了resume和suspend方法的类。这也意味着其是唯一需要进行method swizzling的类</li>
<li>因为NSURLSessionTask并不是在每个iOS版本中都存在，所以把这些放在此处（即load函数中），比如给一个dummy class添加swizzled方法都会变得很方便，管理起来也方便。</li>
</ul>
</li>
<li><p>一些假设前提:</p>
<ul>
<li>目前iOS中resume和suspend的方法实现中并没有调用对应的父类方法。如果日后iOS改变了这种做法，我们还需要重新处理。</li>
<li>没有哪个后台task会重写resume和suspend函数</li>
</ul>
</li>
</ul>
<p>其余的一部分翻译在注释中，对应那一行代码。大概总结下这个注释：</p>
<ul>
<li>其实这是被社区大量讨论的一个bug，之前AF因为这个替换方法，会导致偶发性的crash，如果不要这个swizzle则问题不会再出现，但是这样会导致AF中很多UIKit的扩展都不能正常使用。</li>
<li><strong>原来这是因为iOS7和iOS8的NSURLSessionTask的继承链不同导致的，</strong>而且在iOS7继承链中会有两个类都实现了resume和suspend方法。而且子类没有调用父类的方法，我们则需要对着两个类都进行方法替换。而iOS8只需要对一个类进行替换。</li>
<li>对着注释看，上述方法代码不难理解，用一个while循环，一级一级去获取父类，如果实现了resume方法，则进行替换。</li>
</ul>
<p>但是有几个点大家可能会觉得疑惑的，我们先把这个方法调用的替换的函数一块贴出来。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//其引用的交换的函数：</span></span><br><span class="line">+ (<span class="keyword">void</span>)swizzleResumeAndSuspendMethodForClass:(Class)theClass &#123;</span><br><span class="line">    Method afResumeMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    Method afSuspendMethod = class_getInstanceMethod(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_resume), afResumeMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(resume), <span class="keyword">@selector</span>(af_resume));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (af_addMethod(theClass, <span class="keyword">@selector</span>(af_suspend), afSuspendMethod)) &#123;</span><br><span class="line">        af_swizzleSelector(theClass, <span class="keyword">@selector</span>(suspend), <span class="keyword">@selector</span>(af_suspend));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> af_swizzleSelector(Class theClass, SEL originalSelector, SEL swizzledSelector) &#123;</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(theClass, originalSelector);</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod(theClass, swizzledSelector);</span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="built_in">BOOL</span> af_addMethod(Class theClass, SEL selector, Method method) &#123;</span><br><span class="line">    <span class="keyword">return</span> class_addMethod(theClass, selector,  method_getImplementation(method),  method_getTypeEncoding(method));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为有小伙伴问到过，所以我们来分析分析大家可能会觉得疑惑的地方：</p>
<ol>
<li><p>首先可以注意class_getInstanceMethod这个方法，它会获取到当前类继承链逐级往上，第一个实现的该方法。所以说它获取到的方法不能确定是当前类还是父类的。而且这里也没有用dispatch_once_t来保证一个方法只交换一次，那万一这是父类的方法，当前类换一次，父类又换一次，不是等于没交换么？…请注意这行判断：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 7) 如果当前class对于resume的实现和父类不一样（类似iOS7上的情况），并且当前class的resume实现和af_resume不一样，才进行method swizzling。</span></span><br><span class="line"><span class="keyword">if</span> (classResumeIMP != superclassResumeIMP &amp;&amp; originalAFResumeIMP != classResumeIMP) &#123; </span><br><span class="line">      <span class="comment">//执行交换的函数</span></span><br><span class="line">     [<span class="keyword">self</span> swizzleResumeAndSuspendMethodForClass:currentClass]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个条件就杜绝了这种情况的发生，只有当前类实现了这个方法，才可能进入这个if块。</p>
</li>
<li><p>那iOS7两个类都交换了af_resume，那岂不是父类换到子类方法了?…只能说又是没仔细看代码的…注意AF是去向当前类添加af_resume方法，然后去交换当前类的af_resume。所以说根本不会出现这种情况…</p>
</li>
</ol>
<h1 id="三、AFURLResponseSerialization"><a href="#三、AFURLResponseSerialization" class="headerlink" title="三、AFURLResponseSerialization"></a>三、AFURLResponseSerialization</h1><p>接下来我们来补充之前AFURLResponseSerialization这一块是如何解析数据的：</p>
<img src="/images/AFN/AFN-06.jpg" alt="img" style="zoom:70%;" />

<p>如图所示，AF用来解析数据的一共上述这些方法。第一个实际是一个协议方法，协议方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AFURLResponseSerialization</span> &lt;<span class="title">NSObject</span>, <span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)responseObjectForResponse:(<span class="keyword">nullable</span> <span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> * _Nullable __autoreleasing *)error;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>而后面6个类都是遵守这个协议方法，去做数据解析。<strong>这地方可以再次感受一下AF的设计模式</strong>……，接下来我们就来主要看看这些类对这个协议方法的实现：</p>
<h2 id="3-1-AFHTTPResponseSerializer"><a href="#3-1-AFHTTPResponseSerializer" class="headerlink" title="3.1 AFHTTPResponseSerializer"></a>3.1 AFHTTPResponseSerializer</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    [<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error];</span><br><span class="line">    <span class="keyword">return</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>方法调用了一个另外的方法之后，就把data返回来了，我们继续往里看这个方法：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断是不是可接受类型和可接受code，不是则填充error</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response</span><br><span class="line">                    data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                   error:(<span class="built_in">NSError</span> * __autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//response是否合法标识</span></span><br><span class="line">  <span class="built_in">BOOL</span> responseIsValid = <span class="literal">YES</span>;</span><br><span class="line">  <span class="comment">//验证的error</span></span><br><span class="line">  <span class="built_in">NSError</span> *validationError = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果存在且是NSHTTPURLResponse</span></span><br><span class="line">  <span class="keyword">if</span> (response &amp;&amp; [response isKindOfClass:[<span class="built_in">NSHTTPURLResponse</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要判断自己能接受的数据类型和response的数据类型是否匹配，</span></span><br><span class="line">    <span class="comment">//如果有接受数据类型，如果不匹配response，而且响应类型不为空，数据长度不为0</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableContentTypes &amp;&amp; ![<span class="keyword">self</span>.acceptableContentTypes containsObject:[response MIMEType]] &amp;&amp;</span><br><span class="line">        !([response MIMEType] == <span class="literal">nil</span> &amp;&amp; [data length] == <span class="number">0</span>)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进入If块说明解析数据肯定是失败的，这时候要把解析错误信息放到error里。</span></span><br><span class="line">        <span class="comment">//如果数据长度大于0，而且有响应url</span></span><br><span class="line">        <span class="keyword">if</span> ([data length] &gt; <span class="number">0</span> &amp;&amp; [response URL]) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//错误信息字典，填充一些错误信息</span></span><br><span class="line">            <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">                <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@&quot;Request failed: unacceptable content-type: %@&quot;</span>, <span class="string">@&quot;AFNetworking&quot;</span>, <span class="literal">nil</span>), [response MIMEType]],</span><br><span class="line">                <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">                AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">            &#125; mutableCopy];</span><br><span class="line">          </span><br><span class="line">            <span class="keyword">if</span> (data) &#123;</span><br><span class="line">                mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成错误</span></span><br><span class="line">            validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorCannotDecodeContentData</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回标识</span></span><br><span class="line">        responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断自己可接受的状态吗</span></span><br><span class="line">    <span class="comment">//如果和response的状态码不匹配，则进入if块</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.acceptableStatusCodes &amp;&amp; ![<span class="keyword">self</span>.acceptableStatusCodes containsIndex:(<span class="built_in">NSUInteger</span>)response.statusCode] &amp;&amp; [response URL]) &#123;</span><br><span class="line">        <span class="comment">//填写错误信息字典</span></span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [@&#123;</span><br><span class="line">             <span class="built_in">NSLocalizedDescriptionKey</span>: [<span class="built_in">NSString</span> stringWithFormat:<span class="built_in">NSLocalizedStringFromTable</span>(<span class="string">@&quot;Request failed: %@ (%ld)&quot;</span>, <span class="string">@&quot;AFNetworking&quot;</span>, <span class="literal">nil</span>), [<span class="built_in">NSHTTPURLResponse</span> localizedStringForStatusCode:response.statusCode], (<span class="keyword">long</span>)response.statusCode],</span><br><span class="line">             <span class="built_in">NSURLErrorFailingURLErrorKey</span>:[response URL],</span><br><span class="line">             AFNetworkingOperationFailingURLResponseErrorKey: response,</span><br><span class="line">        &#125; mutableCopy];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (data) &#123;</span><br><span class="line">            mutableUserInfo[AFNetworkingOperationFailingURLResponseDataErrorKey] = data;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成错误</span></span><br><span class="line">        validationError = AFErrorWithUnderlyingError([<span class="built_in">NSError</span> errorWithDomain:AFURLResponseSerializationErrorDomain code:<span class="built_in">NSURLErrorBadServerResponse</span> userInfo:mutableUserInfo], validationError);</span><br><span class="line">        <span class="comment">//返回标识</span></span><br><span class="line">        responseIsValid = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//给我们传过来的错误指针赋值</span></span><br><span class="line">  <span class="keyword">if</span> (error &amp;&amp; !responseIsValid) &#123;</span><br><span class="line">      *error = validationError;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//返回是否错误标识</span></span><br><span class="line">  <span class="keyword">return</span> responseIsValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>看注释应该很容易明白这个方法有什么作用。简单来说，<strong>这个方法就是来判断返回数据与咱们使用的解析器是否匹配，需要解析的状态码是否匹配。</strong>如果错误，则填充错误信息，并且返回NO，否则返回YES，错误信息为nil。</li>
<li>其中里面出现了两个属性值，一个acceptableContentTypes，一个acceptableStatusCodes，两者在初始化的时候有给默认值，我们也可以去自定义，但是如果给acceptableContentTypes定义了不匹配的类型，那么数据仍旧会解析错误。</li>
<li>而AFHTTPResponseSerializer仅仅是调用验证方法，然后就返回了data。</li>
</ul>
<h2 id="3-2-AFJSONResponseSerializer"><a href="#3-2-AFJSONResponseSerializer" class="headerlink" title="3.2 AFJSONResponseSerializer"></a>3.2 AFJSONResponseSerializer</h2><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObjectForResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">                           data:(<span class="built_in">NSData</span> *)data</span><br><span class="line">                          error:(<span class="built_in">NSError</span> *__autoreleasing *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//先判断是不是可接受类型和可接受code</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> validateResponse:(<span class="built_in">NSHTTPURLResponse</span> *)response data:data error:error]) &#123;</span><br><span class="line">        <span class="comment">//error为空，或者有错误，去函数里判断。</span></span><br><span class="line">        <span class="keyword">if</span> (!error || AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain)) &#123;</span><br><span class="line">            <span class="comment">//返回空</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">id</span> responseObject = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">NSError</span> *serializationError = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">// Workaround for behavior of Rails to return a single space for `head :ok` (a workaround for a bug in Safari), which is not interpreted as valid input by NSJSONSerialization.</span></span><br><span class="line">    <span class="comment">// See https://github.com/rails/rails/issues/1742</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有空格</span></span><br><span class="line">    <span class="built_in">BOOL</span> isSpace = [data isEqualToData:[<span class="built_in">NSData</span> dataWithBytes:<span class="string">&quot; &quot;</span> length:<span class="number">1</span>]];</span><br><span class="line">    <span class="comment">//没空格去json解析</span></span><br><span class="line">    <span class="keyword">if</span> (data.length &gt; <span class="number">0</span> &amp;&amp; !isSpace) &#123;</span><br><span class="line">        responseObject = [<span class="built_in">NSJSONSerialization</span> JSONObjectWithData:data options:<span class="keyword">self</span>.readingOptions error:&amp;serializationError];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是否需要移除Null值</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.removesKeysWithNullValues &amp;&amp; responseObject) &#123;</span><br><span class="line">        responseObject = AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿着json解析的error去填充错误信息</span></span><br><span class="line">    <span class="keyword">if</span> (error) &#123;</span><br><span class="line">        *error = AFErrorWithUnderlyingError(serializationError, *error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回解析结果</span></span><br><span class="line">    <span class="keyword">return</span> responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注释写的很清楚，大概需要讲一下的是以下几个函数: （之前注释已经写清楚了这些函数的作用）</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line">AFErrorOrUnderlyingErrorHasCodeInDomain(*error, <span class="built_in">NSURLErrorCannotDecodeContentData</span>, AFURLResponseSerializationErrorDomain))</span><br><span class="line"><span class="comment">//2</span></span><br><span class="line">AFJSONObjectByRemovingKeysWithNullValues(responseObject, <span class="keyword">self</span>.readingOptions);</span><br><span class="line"><span class="comment">//3</span></span><br><span class="line">AFErrorWithUnderlyingError(serializationError, *error);</span><br></pre></td></tr></table></figure>

<p>第一个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是不是我们自己之前生成的错误信息，是的话返回YES</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFErrorOrUnderlyingErrorHasCodeInDomain(<span class="built_in">NSError</span> *error, <span class="built_in">NSInteger</span> code, <span class="built_in">NSString</span> *domain) &#123;</span><br><span class="line">    <span class="comment">//判断错误域名和传过来的域名是否一致，错误code是否一致</span></span><br><span class="line">    <span class="keyword">if</span> ([error.domain isEqualToString:domain] &amp;&amp; error.code == code) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果userInfo的NSUnderlyingErrorKey有值，则在判断一次。</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> AFErrorOrUnderlyingErrorHasCodeInDomain(error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>], code, domain);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以注意，我们这里传过去的code和domain两个参数分别为NSURLErrorCannotDecodeContentData、AFURLResponseSerializationErrorDomain，这两个参数是我们之前判断response可接受类型和code时候自己去生成错误的时候填写的。</p>
<p>第二个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">id</span> AFJSONObjectByRemovingKeysWithNullValues(<span class="keyword">id</span> JSONObject, <span class="built_in">NSJSONReadingOptions</span> readingOptions) &#123;</span><br><span class="line">    <span class="comment">//分数组和字典</span></span><br><span class="line">    <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成一个数组，只需要JSONObject.count个，感受到大神写代码的严谨态度了吗...</span></span><br><span class="line">        <span class="built_in">NSMutableArray</span> *mutableArray = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:[(<span class="built_in">NSArray</span> *)JSONObject count]];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> value <span class="keyword">in</span> (<span class="built_in">NSArray</span> *)JSONObject) &#123;</span><br><span class="line">            <span class="comment">//调用自己</span></span><br><span class="line">            [mutableArray addObject:AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions)];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看我们解析类型是mutable还是非muatable,返回mutableArray或者array</span></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableArray : [<span class="built_in">NSArray</span> arrayWithArray:mutableArray];</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([JSONObject isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">        <span class="built_in">NSMutableDictionary</span> *mutableDictionary = [<span class="built_in">NSMutableDictionary</span> dictionaryWithDictionary:JSONObject];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">id</span> &lt;<span class="built_in">NSCopying</span>&gt; key <span class="keyword">in</span> [(<span class="built_in">NSDictionary</span> *)JSONObject allKeys]) &#123;</span><br><span class="line">            <span class="keyword">id</span> value = (<span class="built_in">NSDictionary</span> *)JSONObject[key];</span><br><span class="line">            <span class="comment">//value空则移除</span></span><br><span class="line">            <span class="keyword">if</span> (!value || [value isEqual:[<span class="built_in">NSNull</span> null]]) &#123;</span><br><span class="line">                [mutableDictionary removeObjectForKey:key];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> ([value isKindOfClass:[<span class="built_in">NSArray</span> <span class="keyword">class</span>]] || [value isKindOfClass:[<span class="built_in">NSDictionary</span> <span class="keyword">class</span>]]) &#123;</span><br><span class="line">                <span class="comment">//如果数组还是去调用自己</span></span><br><span class="line">                mutableDictionary[key] = AFJSONObjectByRemovingKeysWithNullValues(value, readingOptions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (readingOptions &amp; <span class="built_in">NSJSONReadingMutableContainers</span>) ? mutableDictionary : [<span class="built_in">NSDictionary</span> dictionaryWithDictionary:mutableDictionary];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JSONObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法主要还是通过递归的形式实现。比较简单。</p>
<p>第三个：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="built_in">NSError</span> * AFErrorWithUnderlyingError(<span class="built_in">NSError</span> *error, <span class="built_in">NSError</span> *underlyingError) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!error) &#123;</span><br><span class="line">        <span class="keyword">return</span> underlyingError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!underlyingError || error.userInfo[<span class="built_in">NSUnderlyingErrorKey</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NSMutableDictionary</span> *mutableUserInfo = [error.userInfo mutableCopy];</span><br><span class="line">    mutableUserInfo[<span class="built_in">NSUnderlyingErrorKey</span>] = underlyingError;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSError</span> alloc] initWithDomain:error.domain code:error.code userInfo:mutableUserInfo];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法主要是把json解析的错误，赋值给我们需要返回给用户的error上。比较简单，小伙伴们自己看看就好。</p>
<p>至此，AFJSONResponseSerializer就讲完了。而我们ResponseSerialize还有一些其他的类型解析，大家可以自行去阅读，代码还是很容易读的，在这里就不浪费篇幅去讲了。</p>
<p>至此我们AF3.X业务层的逻辑，基本上结束了。</p>
<h1 id="四、AFSecurityPolicy"><a href="#四、AFSecurityPolicy" class="headerlink" title="四、AFSecurityPolicy"></a>四、AFSecurityPolicy</h1><p>简单复习一下TLS的连接过程。至于单向认证/双向认证、证书信任链等概念，这里不再赘述了。</p>
<p>AF就是用AFSecurityPolicy这个类来满足我们各种https认证需求。在这之前我们来看看AF实现的 NSURLSessionDelegate 中用来做https认证的代理方法。</p>
<h2 id="4-1-TLS的连接过程简述"><a href="#4-1-TLS的连接过程简述" class="headerlink" title="4.1 TLS的连接过程简述"></a>4.1 TLS的连接过程简述</h2><p>发送HTTPS请求首先要进行SSL/TLS握手，握手过程大致如下：</p>
<ol>
<li>客户端发起握手请求，携带随机数、支持算法列表等参数。</li>
<li>服务端收到请求，选择合适的算法，下发公钥证书和随机数。</li>
<li>客户端对服务端证书进行校验，并发送随机数信息，该信息使用公钥加密。校验内容如下：<ul>
<li>服务器端证书是否过期；</li>
<li>服务器端证书是否被吊销；</li>
<li>服务器端证书是否可信；</li>
<li>服务器端证书域名和客户端请求域名是否一致。因此，只要服务器的证书是可信的且客户端不跳过“证书验证”这个步骤，https 能够防止域名劫持。</li>
</ul>
</li>
<li>服务端通过私钥获取随机数信息。</li>
<li>双方根据以上交互的信息生成session ticket，用作该连接后续数据传输的加密密钥。</li>
</ol>
<p>上述过程中，客户端较多干涉的是第三步，客户端需要验证服务端下发的证书，验证过程有以下两个要点：</p>
<ul>
<li>客户端用本地保存的根证书解开证书链，确认服务端下发的证书是由可信任的机构颁发的。<ul>
<li>AFSecurityPolicy的 <code>pinnedCertificates</code> 属性，可以更加严格的检查服务器下方的证书，只可以是集合中的证书对应CA或子CA签发的，或是集合中的证书本身，才信任该证书。</li>
</ul>
</li>
<li>客户端需要检查证书的domain域和扩展域，看是否包含本次请求的host。<ul>
<li>AFSecurityPolicy的 <code>validatesDomainName</code> 属性，可以避免服务器试图使用一个非本次请求的域名对应的TLS证书来建立连接。</li>
</ul>
</li>
</ul>
<p>如果上述两点都校验通过，就证明当前的服务端是可信任的，否则就是不可信任，应当中断当前连接。</p>
<h2 id="4-2-session-didReceiveChallenge代理方法"><a href="#4-2-session-didReceiveChallenge代理方法" class="headerlink" title="4.2 session:didReceiveChallenge代理方法"></a>4.2 session:didReceiveChallenge代理方法</h2><p>这个方法就是做https认证的。把官方文档对这个方法的描述翻译一下：</p>
<ul>
<li>函数作用：<ul>
<li>web服务器接收到客户端请求时，有时候需要先验证客户端是否为正常用户，再决定是够返回真实数据。这种情况称之为服务端要求客户端接收挑战（NSURLAuthenticationChallenge *challenge）。</li>
<li>接收到挑战后，客户端要根据服务端传来的challenge来生成completionHandler所需的NSURLSessionAuthChallengeDisposition disposition和NSURLCredential *credential。<ul>
<li>disposition是应对这个挑战的认证方式，而credential是客户端应对这个挑战生成的证书。</li>
<li>注意只有challenge中认证方法为NSURLAuthenticationMethodServerTrust的时候，才需要生成挑战证书。</li>
</ul>
</li>
<li>最后调用completionHandler回应服务器端的挑战。</li>
</ul>
</li>
<li>函数讨论：<ul>
<li>该代理方法会在下面两种情况调用：<ul>
<li>当服务器端要求客户端提供证书时或者进行NTLM认证（Windows NT LAN Manager，微软提出的WindowsNT挑战/响应验证机制）时，此方法允许你的app提供正确的挑战证书。</li>
<li>当某个session使用SSL/TLS协议，第一次和服务器端建立连接的时候，服务器会发送给iOS客户端一个证书，此方法允许你的app验证服务期端的证书链（certificate keychain）</li>
</ul>
</li>
<li>注：如果你没有实现该方法，该session会调用其NSURLSessionTaskDelegate的代理方法URLSession:task:didReceiveChallenge:completionHandler: 。</li>
</ul>
</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 1. 首先指定了https为默认的认证方式</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//挑战处理类型为 默认</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengePerformDefaultHandling：默认方式处理。就像这个delegate方法没实现，credential被忽略</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeUseCredential：使用指定的证书(证书可能为nil)</span></span><br><span class="line"><span class="comment">     NSURLSessionAuthChallengeCancelAuthenticationChallenge：取消挑战。整个请求都将被取消，credential被忽略。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. sessionDidReceiveAuthenticationChallenge属性是一个自定义的做认证的Block，判断是否有值。</span></span><br><span class="line">    <span class="comment">// 若有，则调用，会生成一个认证方式，并给 credential 赋值，即我们需要接受认证的证书。</span></span><br><span class="line">    <span class="comment">// 若无，则去执行默认的认证步骤</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge) &#123;</span><br><span class="line">        disposition = <span class="keyword">self</span>.sessionDidReceiveAuthenticationChallenge(session, challenge, &amp;credential);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 3. 判断如果服务端的认证方法要求是 NSURLAuthenticationMethodServerTrust ，则只需要验证服务端证书是否安全（即https的单向认证，这是AF默认处理的认证方式，其他的认证方式，只能由我们自定义Block的实现）</span></span><br><span class="line">        <span class="keyword">if</span> ([challenge.protectionSpace.authenticationMethod isEqualToString:<span class="built_in">NSURLAuthenticationMethodServerTrust</span>]) &#123;</span><br><span class="line">          <span class="comment">/*</span></span><br><span class="line"><span class="comment">            此处服务器要求客户端的接收认证挑战方法是NSURLAuthenticationMethodServerTrust。也就是说服务器端需要客户端返回一个根据认证挑战的保护空间提供的信任（即challenge.protectionSpace.serverTrust）产生的挑战证书。该证书需要使用credentialForTrust:来创建一个NSURLCredential对象。</span></span><br><span class="line"><span class="comment">           */</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 4. 执行AFSecurityPolicy的方法，做一个AF内部的https认证：基于客户端的安全策略来决定是否信任该服务器，不信任的话，也就没必要响应挑战</span></span><br><span class="line">            <span class="keyword">if</span> ([<span class="keyword">self</span>.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]) &#123;</span><br><span class="line">                <span class="comment">// 用服务器返回的一个 serverTrust 去生成了一个认证证书。然后如果有证书，则用证书认证方式，否则还是用默认的验证方式。</span></span><br><span class="line">                <span class="comment">// 注1：这个 serverTrust 是服务器传过来的，里面包含了服务器的证书信息，是用来我们本地客户端去验证该证书是否合法用的，后面会更详细的去讲这个参数）</span></span><br><span class="line">                <span class="comment">// 注2：挑战方式为UseCredential和PerformDefaultHandling都需要新建挑战证书</span></span><br><span class="line">                credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust];</span><br><span class="line">                <span class="comment">// 确定挑战的方式</span></span><br><span class="line">                <span class="keyword">if</span> (credential) &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>; <span class="comment">// 证书挑战</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;  <span class="comment">// 默认挑战</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 返回NO，说明AF内部认证失败，则取消挑战，即取消请求。</span></span><br><span class="line">                disposition = <span class="built_in">NSURLSessionAuthChallengeCancelAuthenticationChallenge</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//默认挑战方式</span></span><br><span class="line">            disposition = <span class="built_in">NSURLSessionAuthChallengePerformDefaultHandling</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 最后调用 completionHandler 传递认证方式和要认证的证书，去做系统根证书验证。</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">        completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总结一下这里 <code>securityPolicy</code> 存在的作用就是，<strong>使得在系统底层自己去验证之前，AF可以先去验证服务端的证书。</strong>如果通不过，则直接越过系统的验证，取消https的网络请求。否则，继续去走系统根证书的验证。</p>
<h2 id="4-3-AFSecurityPolicy内部"><a href="#4-3-AFSecurityPolicy内部" class="headerlink" title="4.3 AFSecurityPolicy内部"></a>4.3 AFSecurityPolicy内部</h2><p>接下来我们看看<code>AFSecurityPolicy</code>内部是如何做https认证的:</p>
<h3 id="4-3-1-五个属性"><a href="#4-3-1-五个属性" class="headerlink" title="4.3.1 五个属性"></a>4.3.1 五个属性</h3><blockquote>
<p>Certificate Pinning，或者有叫作SSL Pinning/TLS Pinning的，都是指的同一个东西，中文翻译成证书锁定，最大的作用就是用来抵御针对CA的攻击。在实际当中，它一般被用来阻止man-in-the-middle（中间人攻击）。</p>
<p>说起中间人攻击，可能不是那么直观，但是这一类工具我们可能经常会用到，如Mac平台的Charles和Windows平台的Fiddler。如果一个应用使用了Certificate Pinning技术，那么你使用前边说的工具是无法直接来调试/监控应用的网络流量的。</p>
<p>当应用通过HTTPS握手连接到Fidder/Charles时，应用会检查请求的response的证书，如果发现与预设的不一致，会拒绝后续的网络请求，从而增加应用与服务器的安全通信。</p>
</blockquote>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AFSSLPinningMode 共提供了3种验证方式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSUInteger</span>, AFSSLPinningMode) &#123;</span><br><span class="line">    <span class="comment">//不验证</span></span><br><span class="line">    AFSSLPinningModeNone,</span><br><span class="line">    <span class="comment">//只验证公钥</span></span><br><span class="line">    AFSSLPinningModePublicKey,</span><br><span class="line">    <span class="comment">//验证证书</span></span><br><span class="line">    AFSSLPinningModeCertificate,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AFSecurityPolicy，一共有4个公有属性：</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFSecurityPolicy</span> : <span class="title">NSObject</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//https验证模式</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) AFSSLPinningMode SSLPinningMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以去匹配服务端证书验证的证书</span></span><br><span class="line"><span class="comment">// if pinning(固定) is enabled, `evaluateServerTrust:forDomain:` will return true if any pinned certificate matches. </span></span><br><span class="line"><span class="comment">// 解读：pinnedCertificates将被设置为锚点证书。假如验证的(一般是服务端的)数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书。</span></span><br><span class="line"><span class="comment">// 现象：AFSecurityPolicy实例是配置到AFHTTPSessionManager实例上的。此时通过AFHTTPSessionManager实例发出的请求地址，如果不是pinnedCertificates证书集合中对应的域名，那请求失败。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nullable</span>) <span class="built_in">NSSet</span> &lt;<span class="built_in">NSData</span> *&gt; *pinnedCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否支持非法的证书（例如自签名证书）</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> allowInvalidCertificates;</span><br><span class="line"></span><br><span class="line"><span class="comment">//是否去验证证书域名是否匹配。AFN中默认是YES，HTTPS中默认也是会做验证的。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  假如证书的域名与你请求的域名不一致，需把该项设置为NO；如设成NO的话，即服务器使用其他可信任机构颁发的证书，也可以建立连接，这个非常危险，建议打开。</span></span><br><span class="line"><span class="comment">  置为NO，主要用于这种情况：客户端请求的是子域名，而证书上的是另外一个域名。因为SSL证书上的域名是独立的，假如证书上注册的域名是www.google.com，那么mail.google.com是无法验证通过的；当然，有钱可以注册通配符的域名*.google.com，但这个还是比较贵的。</span></span><br><span class="line"><span class="comment">  如置为NO，建议自己添加对应域名的校验逻辑。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> validatesDomainName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>如下方式，我们可以创建一个<code>securityPolicy</code>：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFSecurityPolicy *policy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultPolicy &#123;</span><br><span class="line">  AFSecurityPolicy *securityPolicy = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">  securityPolicy.SSLPinningMode = AFSSLPinningModeNone; <span class="comment">// 默认指定了SSLPinningMode模式为AFSSLPinningModeNone</span></span><br><span class="line">  <span class="keyword">return</span> securityPolicy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>AFSecurityPolicy 还有一个私有属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSSet</span> *pinnedPublicKeys;</span><br></pre></td></tr></table></figure>

<p>AF复写了 pinnedCertificates 属性的setter方法，会同时把证书中每个公钥放在了self.pinnedPublicKeys中。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置证书数组</span></span><br><span class="line">- (<span class="keyword">void</span>)setPinnedCertificates:(<span class="built_in">NSSet</span> *)pinnedCertificates &#123;</span><br><span class="line">    </span><br><span class="line">    _pinnedCertificates = pinnedCertificates;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取对应公钥集合</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">        <span class="comment">//创建公钥集合</span></span><br><span class="line">        <span class="built_in">NSMutableSet</span> *mutablePinnedPublicKeys = [<span class="built_in">NSMutableSet</span> setWithCapacity:[<span class="keyword">self</span>.pinnedCertificates count]];</span><br><span class="line">        <span class="comment">//从证书中拿到公钥。</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificate <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">            <span class="keyword">id</span> publicKey = AFPublicKeyForCertificate(certificate);</span><br><span class="line">            <span class="keyword">if</span> (!publicKey) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            [mutablePinnedPublicKeys addObject:publicKey];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = [<span class="built_in">NSSet</span> setWithSet:mutablePinnedPublicKeys];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.pinnedPublicKeys = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-evaluateServerTrust-方法"><a href="#4-3-2-evaluateServerTrust-方法" class="headerlink" title="4.3.2 evaluateServerTrust:方法"></a>4.3.2 evaluateServerTrust:方法</h3><h4 id="1-参数SecTrustRef与源码实现解读"><a href="#1-参数SecTrustRef与源码实现解读" class="headerlink" title="1. 参数SecTrustRef与源码实现解读"></a>1. 参数SecTrustRef与源码实现解读</h4><p>我们接着回到代理https认证的这行代码上：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[self.securityPolicy evaluateServerTrust:challenge.protectionSpace.serverTrust forDomain:challenge.protectionSpace.host]</span><br></pre></td></tr></table></figure>

<p>我们传了两个参数进去，一个是<code>SecTrustRef</code>类型的serverTrust，这是什么呢？我们看到苹果的文档介绍如下：</p>
<blockquote>
<p>CFType used for performing X.509 certificate trust evaluations.  </p>
<p>大概意思是用于执行X.509证书信任评估，再讲简单点，其实就是一个容器，装了服务器端需要验证的证书的基本信息、公钥等等，不仅如此，它还可以装一些评估策略，还有客户端的锚点证书，这个客户端的证书，可以用来和服务端的证书去匹配验证的。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Security.framework 源码 https://opensource.apple.com/tarballs/Security/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">SecTrust</span> &#123;</span></span><br><span class="line">    CFRuntimeBase           _base;</span><br><span class="line">    CFArrayRef              _certificates;  <span class="comment">//证书</span></span><br><span class="line">    CFArrayRef              _anchors;    <span class="comment">// 锚点</span></span><br><span class="line">    CFTypeRef               _policies;   <span class="comment">// 评估信任的策略</span></span><br><span class="line">    CFArrayRef              _responses;</span><br><span class="line">    CFArrayRef              _SCTs;</span><br><span class="line">    CFArrayRef              _trustedLogs;</span><br><span class="line">    CFDateRef               _verifyDate;</span><br><span class="line">    <span class="comment">// 证书链。什么是证书链？百科：证书链由两个环节组成：信任锚（CA证书）环节和已签名证书环节。自我签名的证书仅有一个环节的长度：信任锚环节就是已签名证书本身。简单来说，证书链就是就是根证书，和根据根证书签名派发得到的证书。</span></span><br><span class="line">    CFArrayRef              _chain; </span><br><span class="line">    SecKeyRef               _publicKey;</span><br><span class="line">    CFArrayRef              _details;</span><br><span class="line">    CFDictionaryRef         _info;</span><br><span class="line">    CFArrayRef              _exceptions;</span><br><span class="line"></span><br><span class="line">    SecTrustResultType      _trustResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* If true we don&#x27;t trust any anchors other than the ones in _anchors. */</span></span><br><span class="line">    <span class="keyword">bool</span>                    _anchorsOnly;</span><br><span class="line">    <span class="comment">/* If false we shouldn&#x27;t search keychains for parents or anchors. */</span></span><br><span class="line">    <span class="keyword">bool</span>                    _keychainsAllowed;</span><br><span class="line">    <span class="comment">/* Dispatch queue for thread-safety */</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span>        _trustQueue;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> __<span class="title">SecTrust</span> *<span class="title">SecTrustRef</span>;</span>  <span class="comment">// trust management object(信任管理对象)，包括要验证的证书以及用于评估信任的一个或多个策略</span></span><br></pre></td></tr></table></figure>

<p>这个方法是<code>AFSecurityPolicy</code>最核心的方法，其他的都是为了配合这个方法。这个方法完成了服务端的证书的信任评估。代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 验证服务端是否值得信任</span></span><br><span class="line"><span class="comment"> * serverTrust SecTrustRef </span></span><br><span class="line"><span class="comment"> * domain 服务器域名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)evaluateServerTrust:(SecTrustRef)serverTrust</span><br><span class="line">                  forDomain:(<span class="built_in">NSString</span> *)domain</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 判断矛盾的条件</span></span><br><span class="line">    <span class="comment">//判断有域名，且允许自建证书，需要验证域名，</span></span><br><span class="line">    <span class="comment">//因为要验证域名，所以必须不能是后者两种：AFSSLPinningModeNone或者添加到项目里的证书为0个。</span></span><br><span class="line">    <span class="keyword">if</span> (domain &amp;&amp; <span class="keyword">self</span>.allowInvalidCertificates &amp;&amp; <span class="keyword">self</span>.validatesDomainName &amp;&amp; (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone || [<span class="keyword">self</span>.pinnedCertificates count] == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// https://developer.apple.com/library/mac/documentation/NetworkingInternet/Conceptual/NetworkingTopics/Articles/OverridingSSLChainValidationCorrectly.html</span></span><br><span class="line">        <span class="comment">//  According to the docs, you should only trust your provided certs for evaluation.</span></span><br><span class="line">        <span class="comment">//  Pinned certificates are added to the trust. Without pinned certificates,</span></span><br><span class="line">        <span class="comment">//  there is nothing to evaluate against.</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//  From Apple Docs:</span></span><br><span class="line">        <span class="comment">//    &quot;Do not implicitly trust self-signed certificates as anchors (kSecTrustOptionImplicitAnchors).</span></span><br><span class="line">        <span class="comment">//    Instead, add your own (self-signed) CA certificate to the list of trusted anchors.&quot;</span></span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;In order to validate a domain name for self signed certificates, you MUST use pinning.&quot;</span>);</span><br><span class="line">        <span class="comment">//不受信任，返回</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 为serverTrust设置验证策略</span></span><br><span class="line">    <span class="comment">// 用来装验证策略</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *policies = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">    <span class="comment">//要验证域名</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.validatesDomainName) &#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 如果需要验证domain，那么就使用SecPolicyCreateSSL函数创建验证策略。</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 函数返回用于评估SSL证书链的策略对象。</span></span><br><span class="line"><span class="comment">         * 第一个参数为true表示将创建SSL服务器证书策略</span></span><br><span class="line"><span class="comment">         * 第二个参数传入domain，表示要求证书链上的叶子节点证书中的主机名与此处传入的domain一致</span></span><br><span class="line"><span class="comment">         SecPolicyRef SecPolicyCreateSSL(Boolean server, CFStringRef __nullable hostname)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">// 添加验证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateSSL(<span class="literal">true</span>, (__bridge <span class="built_in">CFStringRef</span>)domain)];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不需要验证domain，就使用默认的BasicX509验证策略</span></span><br><span class="line">        [policies addObject:(__bridge_transfer <span class="keyword">id</span>)SecPolicyCreateBasicX509()];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//serverTrust：X.509服务器的证书信任。</span></span><br><span class="line">    <span class="comment">//为serverTrust设置验证策略，即告诉客户端如何验证serverTrust</span></span><br><span class="line">    SecTrustSetPolicies(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)policies);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 判断模式，如果是AFSSLPinningModeNone，按照下面的逻辑肯定是返回YES，不论是自签还是公信机构的证书。</span></span><br><span class="line">    <span class="comment">//有验证策略了，可以去验证了。如果是AFSSLPinningModeNone，是自签名，直接返回可信任，否则不是自签名的就去系统根证书里去找是否有匹配的证书。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.SSLPinningMode == AFSSLPinningModeNone) &#123;</span><br><span class="line">        <span class="comment">//如果支持自签名，直接返回YES，不允许才去判断第二个条件，判断serverTrust是否有效</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.allowInvalidCertificates || AFServerTrustIsValid(serverTrust);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是AFSSLPinningModeNone，且验证无效AFServerTrustIsValid，而且allowInvalidCertificates不允许自签，返回NO</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust) &amp;&amp; !<span class="keyword">self</span>.allowInvalidCertificates) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断SSLPinningMode</span></span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.SSLPinningMode) &#123;</span><br><span class="line">        <span class="comment">// 理论上，上面那个部分已经解决了self.SSLPinningMode 为 AFSSLPinningModeNone 等情况，所以此处再遇到，就直接返回NO</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeNone:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//4. 如果是AFSSLPinningModeCertificate(验证证书类型)，则从serverTrust中去获取证书链，然后和我们一开始初始化设置的证书集合self.pinnedCertificates去匹配，如果有一对能匹配成功的，就返回YES，否则NO。</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModeCertificate: &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSMutableArray</span> *pinnedCertificates = [<span class="built_in">NSMutableArray</span> array];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//把证书data，用系统api转成 SecCertificateRef 类型的数据，SecCertificateCreateWithData函数对原先的pinnedCertificates做一些处理，保证返回的证书都是DER编码的X.509证书</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *certificateData <span class="keyword">in</span> <span class="keyword">self</span>.pinnedCertificates) &#123;</span><br><span class="line">                [pinnedCertificates addObject:(__bridge_transfer <span class="keyword">id</span>)SecCertificateCreateWithData(<span class="literal">NULL</span>, (__bridge <span class="built_in">CFDataRef</span>)certificateData)];</span><br><span class="line">            &#125;</span><br><span class="line">          </span><br><span class="line">            <span class="comment">// 将pinnedCertificates设置成评估 信任管理对象 时使用的Anchor Certificate（锚点证书，通过SecTrustSetAnchorCertificates设置了参与校验锚点证书之后，假如验证的数字证书是这个锚点证书的子节点，即验证的数字证书是由锚点证书对应CA或子CA签发的，或是该证书本身，则信任该证书）</span></span><br><span class="line">            <span class="comment">// serverTrust是服务器来的验证，有需要被验证的证书。在不调用SecTrustSetAnchorCertificatesOnly()的情况下调用此函数将禁用对锚证书中锚之外的任何锚的信任。</span></span><br><span class="line">            SecTrustSetAnchorCertificates(serverTrust, (__bridge <span class="built_in">CFArrayRef</span>)pinnedCertificates);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 自签在之前是验证通过不了的，在这一步，把我们自己设置的证书加进去之后，就能验证成功了。</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 在设置锚点证书之后，再调用SecTrustEvaluate来验证一下serverTrust的证书是否有效</span></span><br><span class="line">            <span class="keyword">if</span> (!AFServerTrustIsValid(serverTrust)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// obtain the chain after being validated, which *should* contain the pinned certificate in the last position (if it&#x27;s the Root CA)</span></span><br><span class="line">            <span class="comment">// 注意，这个方法和我们之前的锚点证书没关系了，是去从我们需要被验证的服务端证书，去拿证书链。</span></span><br><span class="line">            <span class="comment">// 服务器端的证书链，注意此处返回的证书链顺序是从叶节点到根节点</span></span><br><span class="line">            <span class="built_in">NSArray</span> *serverCertificates = AFCertificateTrustChainForServerTrust(serverTrust);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// reverseObjectEnumerator逆序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">NSData</span> *trustChainCertificate <span class="keyword">in</span> [serverCertificates reverseObjectEnumerator]) &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">//如果我们的证书中，有一个和它证书链中的证书匹配的，就返回YES</span></span><br><span class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.pinnedCertificates containsObject:trustChainCertificate]) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有匹配的</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">// 5. 如果是AFSSLPinningModePublicKey公钥验证，则和第二步一样还是从serverTrust，获取证书链每一个证书的公钥，放到数组中。和我们的self.pinnedPublicKeys，去配对，如果有一个相同的，就返回YES，否则NO。</span></span><br><span class="line">        <span class="comment">//公钥验证 AFSSLPinningModePublicKey模式同样是用证书绑定(SSL Pinning)方式验证，客户端要有服务端的证书拷贝，只是验证时只验证证书里的公钥，不验证证书的有效期等信息。只要公钥是正确的，就能保证通信不会被窃听，因为中间人没有私钥，无法解开通过公钥加密的数据。</span></span><br><span class="line">        <span class="keyword">case</span> AFSSLPinningModePublicKey: &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="built_in">NSUInteger</span> trustedPublicKeyCount = <span class="number">0</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥</span></span><br><span class="line">            <span class="built_in">NSArray</span> *publicKeys = AFPublicKeyTrustChainForServerTrust(serverTrust);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//遍历服务端公钥</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> trustChainPublicKey <span class="keyword">in</span> publicKeys) &#123;</span><br><span class="line">                <span class="comment">//遍历本地公钥</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">id</span> pinnedPublicKey <span class="keyword">in</span> <span class="keyword">self</span>.pinnedPublicKeys) &#123;</span><br><span class="line">                    <span class="comment">//判断如果相同 trustedPublicKeyCount+1</span></span><br><span class="line">                    <span class="keyword">if</span> (AFSecKeyIsEqualToKey((__bridge SecKeyRef)trustChainPublicKey, (__bridge SecKeyRef)pinnedPublicKey)) &#123;</span><br><span class="line">                        trustedPublicKeyCount += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> trustedPublicKeyCount &gt; <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法中关联了一系列的函数，我在这边按照调用顺序一一列出来（有些是系统函数，不在这里列出，会在下文集体描述作用）：</p>
<h4 id="2-调用函数一-AFServerTrustIsValid"><a href="#2-调用函数一-AFServerTrustIsValid" class="headerlink" title="2. 调用函数一: AFServerTrustIsValid"></a>2. 调用函数一: AFServerTrustIsValid</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断serverTrust是否有效</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">BOOL</span> AFServerTrustIsValid(SecTrustRef serverTrust) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认无效</span></span><br><span class="line">    <span class="built_in">BOOL</span> isValid = <span class="literal">NO</span>;</span><br><span class="line">    <span class="comment">//用来装验证结果，枚举</span></span><br><span class="line">    SecTrustResultType result;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">//__Require_noErr_Quiet 用来判断前者是0还是非0，如果0则表示没错，就跳到后面的表达式所在位置去执行，否则表示有错就继续往下执行。</span></span><br><span class="line">  </span><br><span class="line">    <span class="comment">//SecTrustEvaluate系统评估证书的是否可信的函数，去系统根目录找，然后把结果赋值给result。评估结果匹配，返回0，否则出错返回非0</span></span><br><span class="line">    <span class="comment">//do while 0 ,只执行一次，为啥要这样写....</span></span><br><span class="line">    __Require_noErr_Quiet(SecTrustEvaluate(serverTrust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//评估没出错走掉这，只有两种结果能设置为有效，isValid= 1</span></span><br><span class="line">    <span class="comment">//当result为kSecTrustResultUnspecified（此标志表示serverTrust评估成功，此证书也被暗中信任了，但是用户并没有显示地决定信任该证书）。</span></span><br><span class="line">    <span class="comment">//或者当result为kSecTrustResultProceed（此标志表示评估成功，和上面不同的是该评估得到了用户认可），这两者取其一就可以认为对serverTrust评估成功</span></span><br><span class="line">    isValid = (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//out函数块,如果为SecTrustEvaluate，返回非0，则评估出错，则isValid为NO</span></span><br><span class="line">_<span class="keyword">out</span>:</span><br><span class="line">    <span class="keyword">return</span> isValid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法用来验证serverTrust是否有效，其中主要是交由系统API<code>SecTrustEvaluate</code>来验证的，它验证完之后会返回一个<code>SecTrustResultType</code>枚举类型的result，然后我们根据这个result去判断是否证书是否有效。</p>
<p>其中比较有意思的是，它调用了一个系统定义的宏函数<code>__Require_noErr_Quiet</code>，函数定义如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#ifndef __Require_noErr_Quiet</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> __Require_noErr_Quiet(errorCode, exceptionLabel)                      \</span></span><br><span class="line">      <span class="keyword">do</span>                                                                          \</span><br><span class="line">      &#123;                                                                           \</span><br><span class="line">          <span class="keyword">if</span> ( __builtin_expect(<span class="number">0</span> != (errorCode), <span class="number">0</span>) )                            \</span><br><span class="line">          &#123;                                                                       \</span><br><span class="line">              <span class="keyword">goto</span> exceptionLabel;                                                \</span><br><span class="line">          &#125;                                                                       \</span><br><span class="line">      &#125; <span class="keyword">while</span> ( <span class="number">0</span> ) <span class="comment">// 在Linux内核和其它一些著名的C库中都会有许多使用do&#123;...&#125;while(0)的宏定义。作用：使用do&#123;...&#125;while(0)构造后的宏定义不会受到大括号、分号等的影响，总是会按你期望的方式调用运行。</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>这个函数主要作用就是，判断errorCode是否为0，不为0则，程序用<code>goto</code>跳到<code>exceptionLabel</code>位置去执行。这个<code>exceptionLabel</code>就是一个代码位置标识，类似上面的<code>_out</code>。</p>
<h4 id="3-调用函数二、三获取证书链证书或公钥"><a href="#3-调用函数二、三获取证书链证书或公钥" class="headerlink" title="3. 调用函数二、三获取证书链证书或公钥"></a>3. 调用函数二、三获取证书链证书或公钥</h4><p>函数二、三（两个函数类似，所以放在一起）：</p>
<ul>
<li>获取serverTrust证书链证书。如果 <code>SSLPinningMode</code> 是 <code>AFSSLPinningModeCertificate</code>，就获取证书，进行校验。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取证书链</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFCertificateTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    <span class="comment">//使用SecTrustGetCertificateCount函数获取到serverTrust中需要评估的证书链中的证书数目，并保存到certificateCount中</span></span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="comment">//创建数组</span></span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 使用SecTrustGetCertificateAtIndex函数获取到证书链中的每个证书，并添加到trustChain中，最后返回trustChain</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="built_in">NSData</span> *)SecCertificateCopyData(certificate)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>获取serverTrust证书链公钥。如果 <code>SSLPinningMode</code> 是 <code>AFSSLPinningModePublicKey</code>，就只获取公钥，进行校验。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从serverTrust中取出服务器端传过来的所有可用的证书，并依次得到相应的公钥</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSArray</span> * AFPublicKeyTrustChainForServerTrust(SecTrustRef serverTrust) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 接下来的一小段代码和上面AFCertificateTrustChainForServerTrust函数的作用基本一致，都是为了获取到serverTrust中证书链上的所有证书，并依次遍历，取出公钥。</span></span><br><span class="line">    <span class="comment">//安全策略</span></span><br><span class="line">    SecPolicyRef policy = SecPolicyCreateBasicX509();</span><br><span class="line">    <span class="built_in">CFIndex</span> certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line">    <span class="built_in">NSMutableArray</span> *trustChain = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:(<span class="built_in">NSUInteger</span>)certificateCount];</span><br><span class="line">    <span class="comment">//遍历serverTrust里证书的证书链。</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">CFIndex</span> i = <span class="number">0</span>; i &lt; certificateCount; i++) &#123;</span><br><span class="line">        <span class="comment">//从证书链取证书</span></span><br><span class="line">        SecCertificateRef certificate = SecTrustGetCertificateAtIndex(serverTrust, i);</span><br><span class="line">        <span class="comment">//数组</span></span><br><span class="line">        SecCertificateRef someCertificates[] = &#123;certificate&#125;;</span><br><span class="line">        <span class="comment">//CF数组</span></span><br><span class="line">        <span class="built_in">CFArrayRef</span> certificates = <span class="built_in">CFArrayCreate</span>(<span class="literal">NULL</span>, (<span class="keyword">const</span> <span class="keyword">void</span> **)someCertificates, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustRef trust;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 根据给定的certificates和policy来生成一个trust对象</span></span><br><span class="line">        <span class="comment">// 不成功跳到 _out。</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustCreateWithCertificates(certificates, policy, &amp;trust), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        SecTrustResultType result;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用SecTrustEvaluate来评估上面构建的trust</span></span><br><span class="line">        <span class="comment">// 评估失败跳到 _out</span></span><br><span class="line">        __Require_noErr_Quiet(SecTrustEvaluate(trust, &amp;result), _<span class="keyword">out</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果该trust符合X.509证书格式，那么先使用SecTrustCopyPublicKey获取到trust的公钥，再将此公钥添加到trustChain中</span></span><br><span class="line">        [trustChain addObject:(__bridge_transfer <span class="keyword">id</span>)SecTrustCopyPublicKey(trust)];</span><br><span class="line"></span><br><span class="line">    _<span class="keyword">out</span>:</span><br><span class="line">        <span class="comment">// 释放资源</span></span><br><span class="line">        <span class="keyword">if</span> (trust) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(trust);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (certificates) &#123;</span><br><span class="line">            <span class="built_in">CFRelease</span>(certificates);</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">CFRelease</span>(policy);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回对应的一组公钥</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:trustChain];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个方法功能类似，都是调用了一些系统的API，利用For循环，获取证书链上每一个证书或者公钥。具体内容看源码很好理解。唯一需要注意的是，这个获取的证书排序，是从证书链的叶节点，到根节点的。</p>
<h4 id="4-调用函数四-判断公钥是否相同"><a href="#4-调用函数四-判断公钥是否相同" class="headerlink" title="4. 调用函数四: 判断公钥是否相同"></a>4. 调用函数四: 判断公钥是否相同</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断两个公钥是否相同</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> BOOL <span class="title">AFSecKeyIsEqualToKey</span><span class="params">(SecKeyRef key1, SecKeyRef key2)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_IOS || TARGET_OS_WATCH || TARGET_OS_TV</span></span><br><span class="line">    <span class="comment">//iOS 判断二者地址</span></span><br><span class="line">    <span class="keyword">return</span> [(__bridge id)key1 isEqual:(__bridge id)key2];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">AFSecKeyGetData</span>(key1) isEqual:<span class="built_in">AFSecKeyGetData</span>(key2)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法适配了各种运行环境，做了匹配的判断。</p>
<h4 id="5-验证过程中调用的系统原生函数"><a href="#5-验证过程中调用的系统原生函数" class="headerlink" title="5. 验证过程中调用的系统原生函数"></a>5. 验证过程中调用的系统原生函数</h4><p>接下来列出验证过程中调用过得系统原生函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.创建一个验证SSL的策略，两个参数，第一个参数true则表示验证整个证书链</span></span><br><span class="line"><span class="comment">//第二个参数传入domain，用于判断整个证书链上叶子节点表示的那个domain是否和此处传入domain一致</span></span><br><span class="line">SecPolicyCreateSSL(&lt;#Boolean server#&gt;, &lt;#CFStringRef  _Nullable hostname#&gt;)</span><br><span class="line">SecPolicyCreateBasicX509();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.默认的BasicX509验证策略,不验证域名。</span></span><br><span class="line">SecPolicyCreateBasicX509();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.为serverTrust设置验证策略，即告诉客户端如何验证serverTrust</span></span><br><span class="line">SecTrustSetPolicies(&lt;#SecTrustRef  _Nonnull trust#&gt;, &lt;#CFTypeRef  _Nonnull policies#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.验证serverTrust,并且把验证结果返回给第二参数 result</span></span><br><span class="line">SecTrustEvaluate(&lt;#SecTrustRef  _Nonnull trust#&gt;, &lt;#SecTrustResultType * _Nullable result#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.判断前者errorCode是否为0，为0则跳到exceptionLabel处执行代码</span></span><br><span class="line">__Require_noErr(&lt;#errorCode#&gt;, &lt;#exceptionLabel#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//6.根据证书data,去创建SecCertificateRef类型的数据。</span></span><br><span class="line">SecCertificateCreateWithData(&lt;#CFAllocatorRef  _Nullable allocator#&gt;, &lt;#CFDataRef  _Nonnull data#&gt;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7.给serverTrust设置锚点证书，即如果以后再次去验证serverTrust，会从锚点证书去找是否匹配。</span></span><br><span class="line">SecTrustSetAnchorCertificates(serverTrust, (__bridge CFArrayRef)pinnedCertificates);</span><br><span class="line"></span><br><span class="line"><span class="comment">//8.拿到证书链中的证书个数</span></span><br><span class="line">CFIndex certificateCount = SecTrustGetCertificateCount(serverTrust);</span><br><span class="line"></span><br><span class="line"><span class="function">CFIndex <span class="title">SecTrustGetCertificateCount</span><span class="params">(SecTrustRef trust)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!trust) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SecTrustEvaluateIfNecessary(trust);</span><br><span class="line">    __block CFIndex certCount = <span class="number">1</span>;</span><br><span class="line">    dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (trust-&gt;_chain) &#123;</span><br><span class="line">            certCount = CFArrayGetCount(trust-&gt;_chain);  <span class="comment">// SecTrustRef成员_chain</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">	<span class="keyword">return</span> certCount;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9.去取得证书链中对应下标的证书。</span></span><br><span class="line">SecTrustGetCertificateAtIndex(serverTrust, i)</span><br><span class="line">  </span><br><span class="line"><span class="function">SecCertificateRef <span class="title">SecTrustGetCertificateAtIndex</span><span class="params">(SecTrustRef trust,</span></span></span><br><span class="line"><span class="function"><span class="params">    CFIndex ix)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!trust) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    __block SecCertificateRef cert = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (ix == <span class="number">0</span>) &#123;</span><br><span class="line">        dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">            cert = (SecCertificateRef)CFArrayGetValueAtIndex(trust-&gt;_certificates, <span class="number">0</span>);  <span class="comment">// SecTrustRef成员_certificates</span></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> cert;</span><br><span class="line">    &#125;</span><br><span class="line">    SecTrustEvaluateIfNecessary(trust);</span><br><span class="line">    dispatch_sync(trust-&gt;_trustQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (trust-&gt;_chain) &#123;</span><br><span class="line">            cert = (SecCertificateRef)CFArrayGetValueAtIndex(trust-&gt;_chain, ix);  <span class="comment">// SecTrustRef成员_chain</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> cert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//10.根据证书获取公钥。</span></span><br><span class="line">SecTrustCopyPublicKey(trust)</span><br></pre></td></tr></table></figure>

<p>其功能如注释，大家可以对比着源码，去加以理解~</p>
<h2 id="4-4-关于HTTPS-开发者需要做什么"><a href="#4-4-关于HTTPS-开发者需要做什么" class="headerlink" title="4.4 关于HTTPS, 开发者需要做什么"></a>4.4 关于HTTPS, 开发者需要做什么</h2><p>可能看到这，又有些小伙伴迷糊了，讲了这么多，<strong>那如果做https请求，真正需要我们自己做的到底是什么呢？</strong></p>
<h3 id="4-4-1-如果只想访问能通"><a href="#4-4-1-如果只想访问能通" class="headerlink" title="4.4.1 如果只想访问能通"></a>4.4.1 如果只想访问能通</h3><p>分为以下两种情况：</p>
<ol>
<li>如果你用的是付费的公信机构颁发的证书，标准的https，<strong>那么无论你用的是AF还是NSUrlSession,什么都不用做，代理方法也不用实现。</strong>你的网络请求就能正常完成。</li>
<li>如果你用的是自签名的证书:</li>
</ol>
<ul>
<li>首先你需要在plist文件中，设置可以返回不安全的请求（关闭该域名的ATS）。</li>
<li>其次，如果是<code>NSUrlSesion</code>，那么需要在代理方法实现如下（其实就是AF的相对于自签证书的实现的简化版）</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</span><br><span class="line">didReceiveChallenge:(<span class="built_in">NSURLAuthenticationChallenge</span> *)challenge</span><br><span class="line">  completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionAuthChallengeDisposition</span> disposition, <span class="built_in">NSURLCredential</span> *credential))completionHandler</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSURLCredential</span> *credential = <span class="literal">nil</span>;</span><br><span class="line"></span><br><span class="line">    credential = [<span class="built_in">NSURLCredential</span> credentialForTrust:challenge.protectionSpace.serverTrust]; </span><br><span class="line">    <span class="comment">// 确定挑战的方式</span></span><br><span class="line">    <span class="keyword">if</span> (credential) &#123; </span><br><span class="line">        <span class="comment">// 证书挑战 则跑到这里</span></span><br><span class="line">        disposition = <span class="built_in">NSURLSessionAuthChallengeUseCredential</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//完成挑战</span></span><br><span class="line">    <span class="keyword">if</span> (completionHandler) &#123;</span><br><span class="line">       	completionHandler(disposition, credential);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果是AF，你则需要设置policy：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//允许自签名证书，必须的</span></span><br><span class="line">policy.allowInvalidCertificates = <span class="literal">YES</span>;</span><br><span class="line"><span class="comment">//是否验证域名的CN字段</span></span><br><span class="line"><span class="comment">//不是必须的，但是如果写YES，则必须导入证书。</span></span><br><span class="line">policy.validatesDomainName = <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2-如果想验证服务器来源"><a href="#4-4-2-如果想验证服务器来源" class="headerlink" title="4.4.2 如果想验证服务器来源"></a>4.4.2 如果想验证服务器来源</h3><p>当然还可以根据需求，你可以去验证证书或者公钥，这一步的目的是实现：要求数据必须来自指定的服务器。</p>
<ul>
<li>如果是自签证书，需要把自签的服务端证书，或者自签的CA根证书导入到项目中。</li>
<li>如果是付费的公信机构颁发的证书，那也要把证书导入到项目中。</li>
</ul>
<img src="/images/AFN/AFN-07.jpg" alt="img" style="zoom:83%;" />

<p>并且如下设置证书：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *certFilePath = [[<span class="built_in">NSBundle</span> mainBundle] pathForResource:<span class="string">@&quot;AFUse_server.cer&quot;</span> ofType:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSData</span> *certData = [<span class="built_in">NSData</span> dataWithContentsOfFile:certFilePath];</span><br><span class="line"><span class="built_in">NSSet</span> *certSet = [<span class="built_in">NSSet</span> setWithObjects:certData,certData, <span class="literal">nil</span>]; </span><br><span class="line">policy.pinnedCertificates = certSet;</span><br></pre></td></tr></table></figure>

<p>这样你就可以使用AF的不同<code>AFSSLPinningMode</code>去验证了。</p>
<p>这一步实现了防中间人攻击劫持，比如如果用 Charles 代理抓包，那么客户端中的请求 https 认证是无法通过的，<font color='red'><strong>报错：已取消。</strong></font>（一般AF中证书错误的code码是 -999，报错信息是已取消）。</p>
<h2 id="4-5-总结-AF之于https到底做了什么"><a href="#4-5-总结-AF之于https到底做了什么" class="headerlink" title="4.5 总结: AF之于https到底做了什么"></a>4.5 总结: AF之于https到底做了什么</h2><p>最后总结一下，AF之于https到底做了什么：</p>
<ul>
<li><strong>AF可以让你在系统验证证书之前，就去自主验证。</strong>然后如果自己验证不正确，直接取消网络请求。否则验证通过则继续进行系统验证。</li>
<li>讲到这，顺便提一下，系统验证的流程：首先是去系统的根证书找，看是否有能匹配服务端的证书，如果匹配，则验证成功，返回https的安全数据。</li>
<li>如果不匹配则去判断ATS是否关闭，如果关闭，则返回https不安全连接的数据。如果开启ATS，则拒绝这个请求，请求失败。</li>
</ul>
<p>总之一句话：<strong>AF的验证方式不是必须的，但是对有特殊验证需求的用户确是必要的</strong>。</p>
<p>写在结尾：</p>
<ul>
<li>看完之后，有些小伙伴可能还是会比较迷惑，建议还是不清楚的小伙伴，可以自己生成一个自签名的证书或者用百度地址等做请求，然后设置<code>AFSecurityPolicy</code>不同参数，打断点，一步步的看AF是如何去调用函数作证书验证的。相信这样能加深你的理解。</li>
<li>最后关于自签名证书的问题，等2017年1月1日，也没多久了…一个月不到。除非有特殊原因说明，否则已经无法审核通过了。详细的可以看看这篇文章：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/36ddc5b009a7">iOS 10 适配 ATS（app支持https通过App Store审核）</a>。</li>
<li>苹果官网最新消息：原定于2017.1.1强制的https被延期了，具体延期到什么时候不确定，得等官方通知：</li>
</ul>
<h1 id="五、UIKit扩展与缓存实现"><a href="#五、UIKit扩展与缓存实现" class="headerlink" title="五、UIKit扩展与缓存实现"></a>五、UIKit扩展与缓存实现</h1><p>我们来看看AF对<code>UIkit</code>的扩展:</p>
<img src="/images/AFN/AFN-08.jpg" alt="img" style="zoom:67%;" />

<p>一共如上这个多类，下面我们开始着重讲其中两个UIKit的扩展：</p>
<ul>
<li>一个是我们网络请求时状态栏的小菊花。</li>
<li>一个是我们几乎都用到过请求网络图片的如下一行方法：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url ;</span><br></pre></td></tr></table></figure>

<h2 id="5-1-AFNetworkActivityIndicatorManager"><a href="#5-1-AFNetworkActivityIndicatorManager" class="headerlink" title="5.1 AFNetworkActivityIndicatorManager"></a>5.1 AFNetworkActivityIndicatorManager</h2><p>这个类的作用相当简单，就是当网络请求的时候，状态栏上的小菊花就会开始转:</p>
<img src="/images/AFN/AFN-09.jpg" alt="img" style="zoom:100%;" />

<p>需要的代码也很简单，只需在你需要它的位置中（比如AppDelegate）导入类，并加一行代码即可：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;AFNetworkActivityIndicatorManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">[[AFNetworkActivityIndicatorManager sharedManager] setEnabled:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<p>接下来我们来讲讲这个类的实现：</p>
<ul>
<li>这个类的实现也非常简单，还记得我们之前讲的AF对<code>NSURLSessionTask</code>中做了一个<strong>Method Swizzling</strong>吗？大意是把它的<code>resume</code>和<code>suspend</code>方法做了一个替换，在原有实现的基础上添加了一个通知的发送。</li>
<li>这个类就是基于这两个通知和task完成的通知来实现的。</li>
</ul>
<h3 id="5-1-1-初始化方法"><a href="#5-1-1-初始化方法" class="headerlink" title="5.1.1 初始化方法"></a>5.1.1 初始化方法</h3><p>首先我们来看看它的初始化方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFNetworkActivityManagerState) &#123;</span><br><span class="line">    <span class="comment">//没有请求</span></span><br><span class="line">    AFNetworkActivityManagerStateNotActive,</span><br><span class="line">    <span class="comment">//请求延迟开始</span></span><br><span class="line">    AFNetworkActivityManagerStateDelayingStart,</span><br><span class="line">    <span class="comment">//请求进行中</span></span><br><span class="line">    AFNetworkActivityManagerStateActive,</span><br><span class="line">    <span class="comment">//请求延迟结束</span></span><br><span class="line">    AFNetworkActivityManagerStateDelayingEnd</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* state一共如上4种状态，其中两种应该很好理解，而延迟开始和延迟结束怎么理解呢？</span></span><br><span class="line"><span class="comment">      - 原来这是AF对请求菊花显示做的一个优化处理，试问如果一个请求时间很短，那么菊花很可能闪一下就结束了。如果很多请求过来，那么菊花会不停的闪啊闪，这显然并不是我们想要的效果。</span></span><br><span class="line"><span class="comment">      - 所以多了这两个参数：</span></span><br><span class="line"><span class="comment">        1）在一个请求开始的时候，我延迟一会在去转菊花，如果在这延迟时间内，请求结束了，那么我就不需要去转菊花了。</span></span><br><span class="line"><span class="comment">        2）但是一旦转菊花开始，哪怕很短请求就结束了，我们还是会去转一个时间再去结束，这时间就是延迟结束的时间。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> kDefaultAFNetworkActivityManagerActivationDelay = <span class="number">1.0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSTimeInterval</span> <span class="keyword">const</span> kDefaultAFNetworkActivityManagerCompletionDelay = <span class="number">0.17</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFNetworkActivityIndicatorManager</span></span></span><br><span class="line">  </span><br><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager &#123;</span><br><span class="line">    <span class="keyword">static</span> AFNetworkActivityIndicatorManager *_sharedManager = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _sharedManager = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> _sharedManager;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//1. 设置状态为没有request活跃</span></span><br><span class="line">    <span class="keyword">self</span>.currentState = AFNetworkActivityManagerStateNotActive;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">//2. 监听了三个通知，用来监听当前正在进行的网络请求的状态。</span></span><br><span class="line">    <span class="comment">//开始下载通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidStart:) name:AFNetworkingTaskDidResumeNotification object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//挂起通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidFinish:) name:AFNetworkingTaskDidSuspendNotification object:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//完成通知</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestDidFinish:) name:AFNetworkingTaskDidCompleteNotification object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">//3. 设置了我们前面提到的这个转菊花延迟开始和延迟结束的时间，</span></span><br><span class="line">    <span class="comment">//开始延迟</span></span><br><span class="line">    <span class="keyword">self</span>.activationDelay = kDefaultAFNetworkActivityManagerActivationDelay;</span><br><span class="line">    <span class="comment">//结束延迟</span></span><br><span class="line">    <span class="keyword">self</span>.completionDelay = kDefaultAFNetworkActivityManagerCompletionDelay;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-通知触发调用的方法"><a href="#5-1-2-通知触发调用的方法" class="headerlink" title="5.1.2 通知触发调用的方法"></a>5.1.2 通知触发调用的方法</h3><p>接着我们来看看三个通知触发调用的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求开始</span></span><br><span class="line">- (<span class="keyword">void</span>)networkRequestDidStart:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ([AFNetworkRequestFromNotification(notification) URL]) &#123;</span><br><span class="line">        <span class="comment">//增加请求活跃数</span></span><br><span class="line">        [<span class="keyword">self</span> incrementActivityCount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//请求结束</span></span><br><span class="line">- (<span class="keyword">void</span>)networkRequestDidFinish:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    <span class="comment">//AFNetworkRequestFromNotification(notification)返回这个通知的request,用来判断request是否是有效的</span></span><br><span class="line">    <span class="keyword">if</span> ([AFNetworkRequestFromNotification(notification) URL]) &#123;</span><br><span class="line">        <span class="comment">//减少请求活跃数</span></span><br><span class="line">        [<span class="keyword">self</span> decrementActivityCount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法很简单，就是开始的时候增加了请求活跃数，结束则减少。调用了如下两个方法进行加减：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加请求活跃数</span></span><br><span class="line">- (<span class="keyword">void</span>)incrementActivityCount &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//活跃的网络数+1，并手动发送KVO</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        _activityCount++;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程去做</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> updateCurrentStateForNetworkActivityChange];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//减少请求活跃数</span></span><br><span class="line">- (<span class="keyword">void</span>)decrementActivityCount &#123;</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">        _activityCount = MAX(_activityCount - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;activityCount&quot;</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [<span class="keyword">self</span> updateCurrentStateForNetworkActivityChange];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法做了什么应该很容易看明白，这里需要注意的是，<strong>task的几个状态的通知，是会在多线程的环境下发送过来的</strong>。所以这里对活跃数的加减，都用了<code>@synchronized</code>这种方式的锁，进行了线程保护。然后回到主线程调用了<code>updateCurrentStateForNetworkActivityChange</code></p>
<p>我们接着来看看这个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)updateCurrentStateForNetworkActivityChange &#123;</span><br><span class="line">    <span class="comment">//1. 判断了我们一开始设置是否需要菊花的`self.enabled`，如果需要，才执行。</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.enabled) &#123;</span><br><span class="line">        <span class="comment">// 2. 这里主要是根据当前的状态，来判断下一个状态应该是什么。</span></span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">self</span>.currentState) &#123;</span><br><span class="line">            <span class="comment">//不活跃</span></span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateNotActive:</span><br><span class="line">                <span class="comment">//判断活跃数，大于0为YES</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    <span class="comment">//设置状态为延迟开始</span></span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateDelayingStart];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingStart:</span><br><span class="line">                <span class="comment">//No op. Let the delay timer finish out.</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateActive:</span><br><span class="line">                <span class="keyword">if</span> (!<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateDelayingEnd];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingEnd:</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.isNetworkActivityOccurring) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateActive];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中有这么一个属性<code>self.isNetworkActivityOccurring</code>:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断是否活跃</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isNetworkActivityOccurring &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.activityCount &gt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-1-3-重写currentState的setter"><a href="#5-1-3-重写currentState的setter" class="headerlink" title="5.1.3 重写currentState的setter"></a>5.1.3 重写currentState的setter</h3><p>这个类复写了currentState的set方法，每当我们改变这个state，就会触发set方法，而怎么该转菊花也在该方法中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置当前小菊花状态</span></span><br><span class="line">- (<span class="keyword">void</span>)setCurrentState:(AFNetworkActivityManagerState)currentState &#123;</span><br><span class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (_currentState != currentState) &#123;</span><br><span class="line">            <span class="comment">//KVO</span></span><br><span class="line">            [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;currentState&quot;</span>];</span><br><span class="line">            _currentState = currentState;</span><br><span class="line">            <span class="keyword">switch</span> (currentState) &#123;</span><br><span class="line">                <span class="comment">//如果为不活跃</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateNotActive:</span><br><span class="line">                    <span class="comment">//取消两个延迟用的timer</span></span><br><span class="line">                    [<span class="keyword">self</span> cancelActivationDelayTimer];</span><br><span class="line">                    [<span class="keyword">self</span> cancelCompletionDelayTimer];</span><br><span class="line">                    <span class="comment">//设置小菊花不可见</span></span><br><span class="line">                    [<span class="keyword">self</span> setNetworkActivityIndicatorVisible:<span class="literal">NO</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingStart:</span><br><span class="line">                    <span class="comment">//开启一个定时器延迟去转菊花</span></span><br><span class="line">                    [<span class="keyword">self</span> startActivationDelayTimer];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//如果是活跃状态</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateActive:</span><br><span class="line">                    <span class="comment">//取消延迟完成的timer</span></span><br><span class="line">                    [<span class="keyword">self</span> cancelCompletionDelayTimer];</span><br><span class="line">                    <span class="comment">//开始转菊花</span></span><br><span class="line">                    [<span class="keyword">self</span> setNetworkActivityIndicatorVisible:<span class="literal">YES</span>];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//延迟完成状态</span></span><br><span class="line">                <span class="keyword">case</span> AFNetworkActivityManagerStateDelayingEnd:</span><br><span class="line">                    <span class="comment">//开启延迟完成timer</span></span><br><span class="line">                    [<span class="keyword">self</span> startCompletionDelayTimer];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;currentState&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个set方法就是这个类最核心的方法了。它的作用如下：</p>
<ul>
<li>这里根据当前状态，是否需要开始执行一个延迟开始或者延迟完成，又或者是否需要取消这两个延迟。</li>
<li>还判断了，是否需要去转状态栏的菊花，调用了<code>setNetworkActivityIndicatorVisible:</code>方法：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)setNetworkActivityIndicatorVisible:(<span class="built_in">BOOL</span>)networkActivityIndicatorVisible &#123;</span><br><span class="line">    <span class="keyword">if</span> (_networkActivityIndicatorVisible != networkActivityIndicatorVisible) &#123;</span><br><span class="line">        [<span class="keyword">self</span> willChangeValueForKey:<span class="string">@&quot;networkActivityIndicatorVisible&quot;</span>];</span><br><span class="line">        <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</span><br><span class="line">             _networkActivityIndicatorVisible = networkActivityIndicatorVisible;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> didChangeValueForKey:<span class="string">@&quot;networkActivityIndicatorVisible&quot;</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//支持自定义的Block，去自己控制小菊花</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.networkActivityActionBlock) &#123;</span><br><span class="line">            <span class="keyword">self</span>.networkActivityActionBlock(networkActivityIndicatorVisible);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则默认AF根据该Bool，去控制状态栏小菊花是否显示</span></span><br><span class="line">            [[<span class="built_in">UIApplication</span> sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这个方法就是用来控制菊花是否转。并且支持一个自定义的Block,我们可以自己去拿到这个菊花是否应该转的状态值，去做一些自定义的处理。</li>
<li>如果我们没有实现这个Block，则调用下面的方法去转菊花。</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">UIApplication</span> sharedApplication] setNetworkActivityIndicatorVisible:networkActivityIndicatorVisible];</span><br></pre></td></tr></table></figure>

<p>回到state的set方法中，我们除了控制菊花去转，还调用了以下4个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始任务到结束的时间，默认为1秒，如果1秒就结束，那么不转菊花，延迟去开始转</span></span><br><span class="line">- (<span class="keyword">void</span>)startActivationDelayTimer &#123;</span><br><span class="line">    <span class="comment">//只执行一次</span></span><br><span class="line">    <span class="keyword">self</span>.activationDelayTimer = [<span class="built_in">NSTimer</span></span><br><span class="line">                                 timerWithTimeInterval:<span class="keyword">self</span>.activationDelay target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(activationDelayTimerFired) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    <span class="comment">//添加到主线程runloop去触发</span></span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span>.activationDelayTimer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//完成任务到下一个任务开始，默认为0.17秒，如果0.17秒就开始下一个，那么不停  延迟去结束菊花转</span></span><br><span class="line">- (<span class="keyword">void</span>)startCompletionDelayTimer &#123;</span><br><span class="line">    <span class="comment">//先取消之前的</span></span><br><span class="line">    [<span class="keyword">self</span>.completionDelayTimer invalidate];</span><br><span class="line">    <span class="comment">//延迟执行让菊花不在转</span></span><br><span class="line">    <span class="keyword">self</span>.completionDelayTimer = [<span class="built_in">NSTimer</span> timerWithTimeInterval:<span class="keyword">self</span>.completionDelay target:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(completionDelayTimerFired) userInfo:<span class="literal">nil</span> repeats:<span class="literal">NO</span>];</span><br><span class="line">    [[<span class="built_in">NSRunLoop</span> mainRunLoop] addTimer:<span class="keyword">self</span>.completionDelayTimer forMode:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelActivationDelayTimer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.activationDelayTimer invalidate];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)cancelCompletionDelayTimer &#123;</span><br><span class="line">    [<span class="keyword">self</span>.completionDelayTimer invalidate];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这4个方法分别是开始延迟执行一个方法，和结束的时候延迟执行一个方法，和对应这两个方法的取消。其作用，注释应该很容易理解。</p>
<p>我们继续往下看，这两个延迟调用的到底是什么：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)activationDelayTimerFired &#123;</span><br><span class="line">    <span class="comment">//活跃状态，即活跃数大于1才转</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.networkActivityOccurring) &#123;</span><br><span class="line">        [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateActive];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateNotActive];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)completionDelayTimerFired &#123;</span><br><span class="line">    [<span class="keyword">self</span> setCurrentState:AFNetworkActivityManagerStateNotActive];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个开始，一个完成调用，都设置了不同的currentState的值，又回到之前<code>state</code>的<code>set</code>方法中了。</p>
<p>至此这个<code>AFNetworkActivityIndicatorManager</code>类就讲完了，代码还是相当简单明了的。</p>
<h2 id="5-2-UIImageView-AFNetworking"><a href="#5-2-UIImageView-AFNetworking" class="headerlink" title="5.2 UIImageView+AFNetworking"></a>5.2 UIImageView+AFNetworking</h2><p>接下来我们来讲一个我们经常用的方法，这个方法的实现类是：<code>UIImageView+AFNetworking.h</code>。</p>
<p>这是个类目，并且给UIImageView扩展了4个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 给一个UIImageView去异步的请求一张图片，并且可以设置一张占位图。</span></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url;</span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">			 placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholderImage;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置一张图，并且可以拿到成功和失败的回调。</span></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURLRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest</span><br><span class="line">      placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">               success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *image))success</span><br><span class="line">               failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 取消当前的图片设置请求</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask;</span><br></pre></td></tr></table></figure>

<p><code>SDWebImage</code>、<code>YYKit</code>、<code>AF</code>都实现了这么个类目。AF关于这个类目<code>UIImageView+AFNetworking</code>的实现，<strong>依赖于这么两个类：<code>AFImageDownloader</code>，<code>AFAutoPurgingImageCache</code>。</strong></p>
<p>当然<code>AFImageDownloader</code>中，关于图片数据请求的部分，还是使用<code>AFURLSessionManager</code>来实现的。</p>
<h3 id="5-2-1-AFImageDownloader"><a href="#5-2-1-AFImageDownloader" class="headerlink" title="5.2.1 AFImageDownloader"></a>5.2.1 AFImageDownloader</h3><h4 id="1-先看初始化方法"><a href="#1-先看初始化方法" class="headerlink" title="1. 先看初始化方法"></a>1. 先看初始化方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该类为单例，上述方法中，创建了一个 sessionManager, 这个 sessionManager 将用于我们之后的网络请求。从这里我们可以看到，这个类的网络请求都是基于之前AF自己封装的 AFHTTPSessionManager。</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)defaultInstance &#123;</span><br><span class="line">    <span class="keyword">static</span> AFImageDownloader *sharedInstance = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        sharedInstance = [[<span class="keyword">self</span> alloc] init];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> sharedInstance;</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">// 在这里初始化了一系列的对象</span></span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *defaultConfiguration = [<span class="keyword">self</span>.class defaultURLSessionConfiguration];</span><br><span class="line">    AFHTTPSessionManager *sessionManager = [[AFHTTPSessionManager alloc] initWithSessionConfiguration:defaultConfiguration];</span><br><span class="line">    sessionManager.responseSerializer = [AFImageResponseSerializer serializer];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      //这个枚举值代表着，一堆图片下载，执行任务的顺序</span></span><br><span class="line"><span class="comment">      typedef NS_ENUM(NSInteger, AFImageDownloadPrioritization) &#123;</span></span><br><span class="line"><span class="comment">          //先进先出</span></span><br><span class="line"><span class="comment">          AFImageDownloadPrioritizationFIFO,</span></span><br><span class="line"><span class="comment">          //后进先出</span></span><br><span class="line"><span class="comment">          AFImageDownloadPrioritizationLIFO</span></span><br><span class="line"><span class="comment">      &#125;;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionManager:sessionManager</span><br><span class="line">                 downloadPrioritization:AFImageDownloadPrioritizationFIFO <span class="comment">// </span></span><br><span class="line">                 maximumActiveDownloads:<span class="number">4</span></span><br><span class="line">                             imageCache:[[AFAutoPurgingImageCache alloc] init]]; </span><br><span class="line">  		<span class="comment">// AFAutoPurgingImageCache这个类是AF做图片缓存用的。这里我们暂时就这么理解它，讲完当前类，我们再来补充它。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSURLSessionConfiguration</span> *)defaultURLSessionConfiguration &#123;</span><br><span class="line">  </span><br><span class="line">    <span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TODO set the default HTTP headers</span></span><br><span class="line">  </span><br><span class="line">    configuration.HTTPShouldSetCookies = <span class="literal">YES</span>;</span><br><span class="line">    configuration.HTTPShouldUsePipelining = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">    configuration.requestCachePolicy = <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>;</span><br><span class="line">    <span class="comment">//是否允许蜂窝网络，手机网</span></span><br><span class="line">    configuration.allowsCellularAccess = <span class="literal">YES</span>;</span><br><span class="line">    <span class="comment">//默认超时</span></span><br><span class="line">    configuration.timeoutIntervalForRequest = <span class="number">60.0</span>;</span><br><span class="line">    <span class="comment">//设置的图片缓存对象</span></span><br><span class="line">    configuration.URLCache = [AFImageDownloader defaultURLCache];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> configuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面我们看到除了<code>[[AFAutoPurgingImageCache alloc] init]</code>，还创建了一个cache：<code>[AFImageDownloader defaultURLCache]</code> </p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置一个系统缓存，内存缓存为20M，磁盘缓存为150M，</span></span><br><span class="line"><span class="comment">//这个是系统级别维护的缓存。</span></span><br><span class="line"> + (<span class="built_in">NSURLCache</span> *)defaultURLCache &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="built_in">NSURLCache</span> alloc] initWithMemoryCapacity:<span class="number">20</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">                                         diskCapacity:<span class="number">150</span> * <span class="number">1024</span> * <span class="number">1024</span></span><br><span class="line">                                             diskPath:<span class="string">@&quot;com.alamofire.imagedownloader&quot;</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大家看到这可能迷惑了，怎么这么多cache，那AF做图片缓存到底用哪个呢？答案是AF自己控制的图片缓用 <code>AFAutoPurgingImageCache</code>，而 <code>NSUrlRequest</code> 的缓存由它自己内部根据策略去控制，用的是<code>NSURLCache</code>，不归AF处理，只需在configuration中设置上即可。</p>
<ul>
<li>那么看到这有些小伙伴又要问了，为什么不直接用<code>NSURLCache</code>，还要自定义一个<code>AFAutoPurgingImageCache</code>呢？原来是因为<code>NSURLCache</code>的诸多限制，例如只支持get请求等等。而且因为是系统维护的，我们自己的可控度不强，并且如果需要做一些自定义的缓存处理，无法实现。</li>
<li>更多关于<code>NSURLCache</code>的内容，大家可以自行查阅。</li>
</ul>
<p>接着上面的方法调用到这个最终的初始化方法中：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionManager:(AFHTTPSessionManager *)sessionManager</span><br><span class="line">                downloadPrioritization:(AFImageDownloadPrioritization)downloadPrioritization</span><br><span class="line">                maximumActiveDownloads:(<span class="built_in">NSInteger</span>)maximumActiveDownloads</span><br><span class="line">                            imageCache:(<span class="keyword">id</span> &lt;AFImageRequestCache&gt;)imageCache &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        <span class="comment">//持有</span></span><br><span class="line">        <span class="keyword">self</span>.sessionManager = sessionManager;</span><br><span class="line">        <span class="comment">//定义下载任务的顺序，默认FIFO，先进先出-队列模式，还有后进先出-栈模式</span></span><br><span class="line">        <span class="keyword">self</span>.downloadPrioritizaton = downloadPrioritization;</span><br><span class="line">        <span class="comment">//最大的下载数</span></span><br><span class="line">        <span class="keyword">self</span>.maximumActiveDownloads = maximumActiveDownloads;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//自定义的cache</span></span><br><span class="line">        <span class="keyword">self</span>.imageCache = imageCache;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//队列中的任务，待执行的</span></span><br><span class="line">        <span class="keyword">self</span>.queuedMergedTasks = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">        <span class="comment">//合并的任务，所有任务的字典</span></span><br><span class="line">        <span class="keyword">self</span>.mergedTasks = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line">        <span class="comment">//活跃的request数</span></span><br><span class="line">        <span class="keyword">self</span>.activeRequestCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用UUID来拼接名字</span></span><br><span class="line">        <span class="built_in">NSString</span> *name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.imagedownloader.synchronizationqueue-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line">        <span class="comment">//创建一个串行的queue</span></span><br><span class="line">        <span class="keyword">self</span>.synchronizationQueue = dispatch_queue_create([name cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_SERIAL);</span><br><span class="line"></span><br><span class="line">        name = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.imagedownloader.responsequeue-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line">        <span class="comment">//创建并行queue</span></span><br><span class="line">        <span class="keyword">self</span>.responseQueue = dispatch_queue_create([name cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这边初始化了一些属性，这些属性跟着注释看应该很容易明白其作用。主要需要注意的就是，这里创建了两个queue：<strong>一个串行的请求queue，和一个并行的响应queue。</strong></p>
<ul>
<li>这个串行queue,是用来做内部生成task等等一系列业务逻辑的。它保证了我们在这些逻辑处理中的线程安全问题（迷惑的接着往下看）。</li>
<li>这个并行queue，被用来做网络请求完成的数据回调。</li>
</ul>
<h4 id="2-再看创建请求task的方法"><a href="#2-再看创建请求task的方法" class="headerlink" title="2. 再看创建请求task的方法"></a>2. 再看创建请求task的方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">        success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> * , <span class="built_in">NSHTTPURLResponse</span> * , <span class="built_in">UIImage</span> * ))success</span><br><span class="line">        failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> * , <span class="built_in">NSHTTPURLResponse</span> * , <span class="built_in">NSError</span> * ))failure </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> downloadImageForURLRequest:request withReceiptID:[<span class="built_in">NSUUID</span> UUID] </span><br><span class="line">            												success:success failure:failure];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> AFImageDownloadReceipt *)downloadImageForURLRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                                                  withReceiptID:(<span class="keyword">nonnull</span> <span class="built_in">NSUUID</span> *)receiptID</span><br><span class="line">        success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span>  * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</span><br><span class="line">        failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure &#123;</span><br><span class="line">    <span class="comment">//还是类似之前的，同步串行去做下载的事 生成一个task,这些事情都是在当前线程中串行同步做的，所以不用担心线程安全问题。</span></span><br><span class="line">    __block <span class="built_in">NSURLSessionDataTask</span> *task = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//url字符串</span></span><br><span class="line">        <span class="built_in">NSString</span> *URLIdentifier = request.URL.absoluteString;</span><br><span class="line">        <span class="keyword">if</span> (URLIdentifier == <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                <span class="comment">//错误返回，没Url</span></span><br><span class="line">                <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorBadURL</span> userInfo:<span class="literal">nil</span>];</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    failure(request, <span class="literal">nil</span>, error);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果这个任务已经存在，则添加成功失败Block,然后直接返回，即一个url用一个request,可以响应好几个block</span></span><br><span class="line">        <span class="comment">//从自己task字典中根据Url去取AFImageDownloaderMergedTask，里面有task id url等等信息</span></span><br><span class="line">        AFImageDownloaderMergedTask *existingMergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">        <span class="keyword">if</span> (existingMergedTask != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">//里面包含成功和失败Block和UUid</span></span><br><span class="line">            AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID success:success failure:failure];</span><br><span class="line">            <span class="comment">//添加handler</span></span><br><span class="line">            [existingMergedTask addResponseHandler:handler];</span><br><span class="line">            <span class="comment">//给task赋值</span></span><br><span class="line">            task = existingMergedTask.task;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据request的缓存策略，加载缓存</span></span><br><span class="line">        <span class="keyword">switch</span> (request.cachePolicy) &#123;</span><br><span class="line">            <span class="comment">//这3种情况都会去加载缓存</span></span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestUseProtocolCachePolicy</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataElseLoad</span>:</span><br><span class="line">            <span class="keyword">case</span> <span class="built_in">NSURLRequestReturnCacheDataDontLoad</span>: &#123;</span><br><span class="line">                <span class="comment">//从cache中根据request拿数据</span></span><br><span class="line">                <span class="built_in">UIImage</span> *cachedImage = [<span class="keyword">self</span>.imageCache imageforRequest:request withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">                <span class="keyword">if</span> (cachedImage != <span class="literal">nil</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            success(request, <span class="literal">nil</span>, cachedImage);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//走到这说明即没有请求中的request,也没有cache,开始请求</span></span><br><span class="line">        <span class="built_in">NSUUID</span> *mergedTaskIdentifier = [<span class="built_in">NSUUID</span> UUID];</span><br><span class="line">        <span class="comment">//task</span></span><br><span class="line">        <span class="built_in">NSURLSessionDataTask</span> *createdTask;</span><br><span class="line">        __<span class="keyword">weak</span> __typeof__(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//用sessionManager的去请求，注意，只是创建task,还是挂起状态</span></span><br><span class="line">        createdTask = [<span class="keyword">self</span>.sessionManager</span><br><span class="line">                       dataTaskWithRequest:request</span><br><span class="line">                       completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</span><br><span class="line">                           </span><br><span class="line">                           <span class="comment">//在responseQueue中回调数据,初始化为并行queue</span></span><br><span class="line">                           <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.responseQueue, ^&#123;</span><br><span class="line">                               __<span class="keyword">strong</span> __typeof__(weakSelf) strongSelf = weakSelf;</span><br><span class="line">                               </span><br><span class="line">                               <span class="comment">//拿到当前的task</span></span><br><span class="line">                               AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">                               </span><br><span class="line">                               <span class="comment">//如果之前的task数组中，有这个请求的任务task，则从数组中移除</span></span><br><span class="line">                               <span class="keyword">if</span> ([mergedTask.identifier isEqual:mergedTaskIdentifier]) &#123;</span><br><span class="line">                                   <span class="comment">//安全的移除，并返回当前被移除的AF task</span></span><br><span class="line">                                   mergedTask = [strongSelf safelyRemoveMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">                                   <span class="comment">//请求错误</span></span><br><span class="line">                                   <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                                       <span class="comment">//去遍历task所有响应的处理</span></span><br><span class="line">                                       <span class="keyword">for</span> (AFImageDownloaderResponseHandler *handler <span class="keyword">in</span> mergedTask.responseHandlers) &#123;</span><br><span class="line">                                           <span class="comment">//主线程，调用失败的Block</span></span><br><span class="line">                                           <span class="keyword">if</span> (handler.failureBlock) &#123;</span><br><span class="line">                                               <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                   handler.failureBlock(request, (<span class="built_in">NSHTTPURLResponse</span>*)response, error);</span><br><span class="line">                                               &#125;);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                       <span class="comment">//成功根据request,往cache里添加</span></span><br><span class="line">                                       [strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">                                       <span class="comment">//调用成功Block</span></span><br><span class="line">                                       <span class="keyword">for</span> (AFImageDownloaderResponseHandler *handler <span class="keyword">in</span> mergedTask.responseHandlers) &#123;</span><br><span class="line">                                           <span class="keyword">if</span> (handler.successBlock) &#123;</span><br><span class="line">                                               <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                                                   handler.successBlock(request, (<span class="built_in">NSHTTPURLResponse</span>*)response, responseObject);</span><br><span class="line">                                               &#125;);</span><br><span class="line">                                           &#125;</span><br><span class="line">                                       &#125;</span><br><span class="line">                                       </span><br><span class="line">                                   &#125;</span><br><span class="line">                               &#125;</span><br><span class="line">                               <span class="comment">//减少活跃的任务数</span></span><br><span class="line">                               [strongSelf safelyDecrementActiveTaskCount];</span><br><span class="line">                               [strongSelf safelyStartNextTaskIfNecessary];</span><br><span class="line">                           &#125;);</span><br><span class="line">                       &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4) Store the response handler for use when the request completes</span></span><br><span class="line">        <span class="comment">//创建handler</span></span><br><span class="line">        AFImageDownloaderResponseHandler *handler = [[AFImageDownloaderResponseHandler alloc] initWithUUID:receiptID</span><br><span class="line">                                                                                                   success:success</span><br><span class="line">                                                                                                   failure:failure];</span><br><span class="line">        <span class="comment">//创建task</span></span><br><span class="line">        AFImageDownloaderMergedTask *mergedTask = [[AFImageDownloaderMergedTask alloc]</span><br><span class="line">                                                   initWithURLIdentifier:URLIdentifier</span><br><span class="line">                                                   identifier:mergedTaskIdentifier</span><br><span class="line">                                                   task:createdTask];</span><br><span class="line">        <span class="comment">//添加handler</span></span><br><span class="line">        [mergedTask addResponseHandler:handler];</span><br><span class="line">        <span class="comment">//往当前任务字典里添加任务</span></span><br><span class="line">        <span class="keyword">self</span>.mergedTasks[URLIdentifier] = mergedTask;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 5) Either start the request or enqueue it depending on the current active request count</span></span><br><span class="line">        <span class="comment">//如果小于，则开始任务下载resume</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">            [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            </span><br><span class="line">            [<span class="keyword">self</span> enqueueMergedTask:mergedTask];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到最终生成的task</span></span><br><span class="line">        task = mergedTask.task;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (task) &#123;</span><br><span class="line">        <span class="comment">//创建一个AFImageDownloadReceipt并返回，里面就多一个receiptID。</span></span><br><span class="line">        <span class="keyword">return</span> [[AFImageDownloadReceipt alloc] initWithReceiptID:receiptID task:task];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就这么一个非常非常长的方法，这个方法执行的内容都是在我们之前创建的串行queue中，同步的执行的，这是因为这个方法绝大多数的操作都是需要线程安全的。可以对着源码和注释来看，我们在这讲下它做了什么：</p>
<h5 id="1-判断url是否为空"><a href="#1-判断url是否为空" class="headerlink" title="1) 判断url是否为空"></a>1) 判断url是否为空</h5><p>首先做了一个url的判断，如果为空则返回失败Block。</p>
<h5 id="2-判断是否是已生成task"><a href="#2-判断是否是已生成task" class="headerlink" title="2) 判断是否是已生成task"></a>2) 判断是否是已生成task</h5><p>判断这个需要请求的url，是不是已经被生成的task中，如果是的话，则多添加一个回调处理就可以。</p>
<h5 id="2-1-AFImageDownloaderResponseHandler"><a href="#2-1-AFImageDownloaderResponseHandler" class="headerlink" title="2-1) AFImageDownloaderResponseHandler"></a>2-1) AFImageDownloaderResponseHandler</h5><p>回调处理对象为<code>AFImageDownloaderResponseHandler</code>。这个类非常简单，总共就如下3个属性：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloaderResponseHandler</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *uuid;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^successBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">UIImage</span>*);</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">void</span> (^failureBlock)(<span class="built_in">NSURLRequest</span>*, <span class="built_in">NSHTTPURLResponse</span>*, <span class="built_in">NSError</span>*);</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloaderResponseHandler</span></span></span><br><span class="line"><span class="comment">//初始化回调对象</span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithUUID:(<span class="built_in">NSUUID</span> *)uuid</span><br><span class="line">                     success:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *responseObject))success</span><br><span class="line">                     failure:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.uuid = uuid;</span><br><span class="line">        <span class="keyword">self</span>.successBlock = success;</span><br><span class="line">        <span class="keyword">self</span>.failureBlock = failure;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当这个task完成的时候，会调用我们添加的回调。</p>
<h5 id="2-2-AFImageDownloaderMergedTask"><a href="#2-2-AFImageDownloaderMergedTask" class="headerlink" title="2-2) AFImageDownloaderMergedTask"></a>2-2) AFImageDownloaderMergedTask</h5><p>关于<code>AFImageDownloaderMergedTask</code>，我们在这里都用的是这种类型的task，其实这个task也很简单：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloaderMergedTask</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *URLIdentifier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *identifier;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableArray</span> &lt;AFImageDownloaderResponseHandler*&gt; *responseHandlers;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloaderMergedTask</span></span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier identifier:(<span class="built_in">NSUUID</span> *)identifier task:(<span class="built_in">NSURLSessionDataTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.URLIdentifier = URLIdentifier;</span><br><span class="line">        <span class="keyword">self</span>.task = task;</span><br><span class="line">        <span class="keyword">self</span>.identifier = identifier;</span><br><span class="line">        <span class="keyword">self</span>.responseHandlers = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//添加任务完成回调</span></span><br><span class="line"> - (<span class="keyword">void</span>)addResponseHandler:(AFImageDownloaderResponseHandler*)handler &#123;</span><br><span class="line">    [<span class="keyword">self</span>.responseHandlers addObject:handler];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//移除任务完成回调</span></span><br><span class="line"> - (<span class="keyword">void</span>)removeResponseHandler:(AFImageDownloaderResponseHandler*)handler &#123;</span><br><span class="line">    [<span class="keyword">self</span>.responseHandlers removeObject:handler];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>其实就是除了<code>NSURLSessionDataTask</code>，多加了几个参数，<code>URLIdentifier</code>和<code>identifier</code>都是用来标识这个task的，responseHandlers是用来存储task完成后的回调的，里面可以存一组，当任务完成时候，里面的回调都会被调用。</p>
<h5 id="3-判断缓存是否存在"><a href="#3-判断缓存是否存在" class="headerlink" title="3. 判断缓存是否存在"></a>3. 判断缓存是否存在</h5><p>接着去根据缓存策略，去加载缓存，如果有缓存，从<code>self.imageCache</code>中返回缓存，否则继续往下走。</p>
<h5 id="4-创建NSURLSessionDataTask并设置完成回调"><a href="#4-创建NSURLSessionDataTask并设置完成回调" class="headerlink" title="4. 创建NSURLSessionDataTask并设置完成回调"></a>4. 创建NSURLSessionDataTask并设置完成回调</h5><p>走到这说明没相同url的task，也没有cache，那么就开始一个新的task，调用的是<code>AFUrlSessionManager</code>里的请求方法生成了一个task（前面已经说过，不赘述）。</p>
<p>同时做了请求完成的处理。注意，这里处理是在我们一开始初始化的并行queue:<code>self.responseQueue</code>中的，这里的响应处理是多线程并发进行的。</p>
<p>完成后：</p>
<ol>
<li>调用如下方法把这个task从全局字典中移除：</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//移除task相关，用同步串行的形式，防止移除中出现重复移除一系列问题</span></span><br><span class="line">- (AFImageDownloaderMergedTask*)safelyRemoveMergedTaskWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier &#123;</span><br><span class="line">    __block AFImageDownloaderMergedTask *mergedTask = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        mergedTask = [<span class="keyword">self</span> removeMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> mergedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>根据task的成功或失败情况，去循环这个task的<code>responseHandlers</code>，分别调用它的成功或者失败的回调。</li>
<li>如果成功，把成功请求到的数据，加到AF自定义的cache中：</li>
</ol>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//成功根据request,往cache里添加</span></span><br><span class="line">[<span class="meta">strongSelf.imageCache addImage:responseObject forRequest:request withAdditionalIdentifier:nil</span>];</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>并且调用下面两个方法，去减少正在请求的任务数，和开启下一个任务：</li>
</ol>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//减少活跃的任务数</span></span><br><span class="line"> - (<span class="keyword">void</span>)safelyDecrementActiveTaskCount &#123;</span><br><span class="line">    <span class="comment">//回到串行queue去-</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.activeRequestCount &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.activeRequestCount -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//如果可以，则开启下一个任务</span></span><br><span class="line"> - (<span class="keyword">void</span>)safelyStartNextTaskIfNecessary &#123;</span><br><span class="line">    <span class="comment">//回到串行queue</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//先判断并行数限制</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">self</span>.queuedMergedTasks.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//获取数组中第一个task</span></span><br><span class="line">                AFImageDownloaderMergedTask *mergedTask = [<span class="keyword">self</span> dequeueMergedTask];</span><br><span class="line">                <span class="comment">//如果状态是挂起状态</span></span><br><span class="line">                <span class="keyword">if</span> (mergedTask.task.state == <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">                    [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，跟我们本类的一些数据相关的操作，<strong>都是在我们一开始的串行queue中同步进行的。</strong></p>
<h5 id="5-创建ResponseHandler和MergedTask"><a href="#5-创建ResponseHandler和MergedTask" class="headerlink" title="5. 创建ResponseHandler和MergedTask"></a>5. 创建ResponseHandler和MergedTask</h5><p>用<code>NSUUID</code>生成的唯一标识，去生成<code>AFImageDownloaderResponseHandler</code>，然后生成一个<code>AFImageDownloaderMergedTask</code>，把之前第5步生成的<code>createdTask</code>和回调都绑定给这个AF自定义可合并回调的task，然后这个task加到全局的task映射字典中，key为url:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.mergedTasks[URLIdentifier] = mergedTask;</span><br></pre></td></tr></table></figure>

<h5 id="6-判断当前并行数是否超限"><a href="#6-判断当前并行数是否超限" class="headerlink" title="6. 判断当前并行数是否超限"></a>6. 判断当前并行数是否超限</h5><p>判断当前正在下载的任务是否超过最大并行数，如果没有则开始下载，否则先加到等待的数组中去:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//如果小于最大并行数，则开始任务下载resume</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> isActiveRequestCountBelowMaximumLimit]) &#123;</span><br><span class="line">    [<span class="keyword">self</span> startMergedTask:mergedTask];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span> enqueueMergedTask:mergedTask];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断并行数限制</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isActiveRequestCountBelowMaximumLimit &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.activeRequestCount &lt; <span class="keyword">self</span>.maximumActiveDownloads;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始下载</span></span><br><span class="line"> - (<span class="keyword">void</span>)startMergedTask:(AFImageDownloaderMergedTask *)mergedTask &#123;</span><br><span class="line">    [mergedTask.task resume];</span><br><span class="line">    <span class="comment">//任务活跃数+1</span></span><br><span class="line">    ++<span class="keyword">self</span>.activeRequestCount;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//把任务先加到数组里</span></span><br><span class="line"> - (<span class="keyword">void</span>)enqueueMergedTask:(AFImageDownloaderMergedTask *)mergedTask &#123;</span><br><span class="line">    <span class="keyword">switch</span> (<span class="keyword">self</span>.downloadPrioritizaton) &#123;</span><br><span class="line">        <span class="comment">//先进先出</span></span><br><span class="line">        <span class="keyword">case</span> AFImageDownloadPrioritizationFIFO:</span><br><span class="line">            [<span class="keyword">self</span>.queuedMergedTasks addObject:mergedTask];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//后进先出</span></span><br><span class="line">        <span class="keyword">case</span> AFImageDownloadPrioritizationLIFO:</span><br><span class="line">            [<span class="keyword">self</span>.queuedMergedTasks insertObject:mergedTask atIndex:<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先判断并行数限制，如果小于最大限制，则开始下载，把当前活跃的request数量+1。</li>
<li>如果暂时不能下载，被加到等待下载的数组中去的话，会根据我们一开始设置的下载策略，是先进先出，还是后进先出，去插入这个下载任务。</li>
</ul>
<h5 id="7-创建AFImageDownloadReceipt"><a href="#7-创建AFImageDownloadReceipt" class="headerlink" title="7. 创建AFImageDownloadReceipt"></a>7. 创建AFImageDownloadReceipt</h5><p>最后判断这个mergeTask是否为空。不为空，我们生成了一个<code>AFImageDownloadReceipt</code>，绑定了一个UUID，否则为空返回nil。这个<code>AFImageDownloadReceipt</code>仅仅是多封装了一个UUID:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFImageDownloadReceipt</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSURLSessionDataTask</span> *task;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSUUID</span> *receiptID;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFImageDownloadReceipt</span></span></span><br><span class="line"> - (<span class="keyword">instancetype</span>)initWithReceiptID:(<span class="built_in">NSUUID</span> *)receiptID task:(<span class="built_in">NSURLSessionDataTask</span> *)task &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.receiptID = receiptID;</span><br><span class="line">        <span class="keyword">self</span>.task = task;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这么封装是为了标识每一个task，我们后面可以根据这个<code>AFImageDownloadReceipt</code>来对task做取消操作。</p>
<h4 id="3-取消task"><a href="#3-取消task" class="headerlink" title="3. 取消task"></a>3. 取消task</h4><p>这个<code>AFImageDownloader</code>中最核心的方法基本就讲完了，还剩下一些方法没讲，像前面讲到的task的取消的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据AFImageDownloadReceipt来取消任务，即对应一个响应回调。</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelTaskForImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//拿到url</span></span><br><span class="line">        <span class="built_in">NSString</span> *URLIdentifier = imageDownloadReceipt.task.originalRequest.URL.absoluteString;</span><br><span class="line">        <span class="comment">//根据url拿到task</span></span><br><span class="line">        AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//快速遍历查找某个下标，如果返回YES，则index为当前下标</span></span><br><span class="line">        <span class="built_in">NSUInteger</span> index = [mergedTask.responseHandlers indexOfObjectPassingTest:^<span class="built_in">BOOL</span>(AFImageDownloaderResponseHandler * _Nonnull handler, __unused <span class="built_in">NSUInteger</span> idx, __unused <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> handler.uuid == imageDownloadReceipt.receiptID;</span><br><span class="line">        &#125;];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index != <span class="built_in">NSNotFound</span>) &#123;</span><br><span class="line">            <span class="comment">//移除响应处理</span></span><br><span class="line">            AFImageDownloaderResponseHandler *handler = mergedTask.responseHandlers[index];</span><br><span class="line">            [mergedTask removeResponseHandler:handler];</span><br><span class="line">            <span class="built_in">NSString</span> *failureReason = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;ImageDownloader cancelled URL request: %@&quot;</span>,imageDownloadReceipt.task.originalRequest.URL.absoluteString];</span><br><span class="line">            <span class="built_in">NSDictionary</span> *userInfo = @&#123;<span class="built_in">NSLocalizedFailureReasonErrorKey</span>:failureReason&#125;;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorCancelled</span> userInfo:userInfo];</span><br><span class="line">            <span class="comment">//并调用失败block，原因为取消</span></span><br><span class="line">            <span class="keyword">if</span> (handler.failureBlock) &#123;</span><br><span class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                    handler.failureBlock(imageDownloadReceipt.task.originalRequest, <span class="literal">nil</span>, error);</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果任务里的响应回调为空或者状态为挂起，则取消task,并且从字典中移除</span></span><br><span class="line">        <span class="keyword">if</span> (mergedTask.responseHandlers.count == <span class="number">0</span> &amp;&amp; mergedTask.task.state == <span class="built_in">NSURLSessionTaskStateSuspended</span>) &#123;</span><br><span class="line">            [mergedTask.task cancel];</span><br><span class="line">            [<span class="keyword">self</span> removeMergedTaskWithURLIdentifier:URLIdentifier];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据URLIdentifier移除task</span></span><br><span class="line">- (AFImageDownloaderMergedTask *)removeMergedTaskWithURLIdentifier:(<span class="built_in">NSString</span> *)URLIdentifier &#123;</span><br><span class="line">    AFImageDownloaderMergedTask *mergedTask = <span class="keyword">self</span>.mergedTasks[URLIdentifier];</span><br><span class="line">    [<span class="keyword">self</span>.mergedTasks removeObjectForKey:URLIdentifier];</span><br><span class="line">    <span class="keyword">return</span> mergedTask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>方法比较简单，大家自己看看就好。至此```AFImageDownloader``这个类讲完了。如果大家看的感觉比较绕，没关系，等到最后我们一起来总结一下，捋一捋。</p>
<h3 id="5-2-2-AFAutoPurgingImageCache"><a href="#5-2-2-AFAutoPurgingImageCache" class="headerlink" title="5.2.2 AFAutoPurgingImageCache"></a>5.2.2 AFAutoPurgingImageCache</h3><p>我们之前讲到<code>AFAutoPurgingImageCache</code>这个类略过去了，现在我们就来补充一下这个类的相关内容：</p>
<p>首先来讲讲这个类的作用，它是AF自定义用来做图片缓存的。</p>
<h4 id="1-下文要用到的AFCachedImage"><a href="#1-下文要用到的AFCachedImage" class="headerlink" title="1. 下文要用到的AFCachedImage"></a>1. 下文要用到的AFCachedImage</h4><p>关于这个<code>AFCachedImage</code>，其实就是Image之外封装了几个关于这个缓存的参数，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AFCachedImage</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">UIImage</span> *image;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> *identifier;  <span class="comment">//url标识</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> totalBytes;   <span class="comment">//总大小</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSDate</span> *lastAccessDate;  <span class="comment">//上次获取时间</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">UInt64</span> currentMemoryUsage; <span class="comment">//这个参数没被用到过</span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">AFCachedImage</span></span></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"> -(<span class="keyword">instancetype</span>)initWithImage:(<span class="built_in">UIImage</span> *)image identifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">self</span> init]) &#123;</span><br><span class="line">        <span class="keyword">self</span>.image = image;</span><br><span class="line">        <span class="keyword">self</span>.identifier = identifier;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">CGSize</span> imageSize = <span class="built_in">CGSizeMake</span>(image.size.width * image.scale, image.size.height * image.scale);</span><br><span class="line">        <span class="built_in">CGFloat</span> bytesPerPixel = <span class="number">4.0</span>;</span><br><span class="line">        <span class="built_in">CGFloat</span> bytesPerSize = imageSize.width * imageSize.height;</span><br><span class="line">        <span class="keyword">self</span>.totalBytes = (<span class="built_in">UInt64</span>)bytesPerPixel * (<span class="built_in">UInt64</span>)bytesPerSize;</span><br><span class="line">        <span class="keyword">self</span>.lastAccessDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//上次获取缓存的时间</span></span><br><span class="line"> - (<span class="built_in">UIImage</span>*)accessImage &#123;</span><br><span class="line">    <span class="keyword">self</span>.lastAccessDate = [<span class="built_in">NSDate</span> date];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-初始化方法"><a href="#2-初始化方法" class="headerlink" title="2. 初始化方法"></a>2. 初始化方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="comment">//默认为内存100M，后者为缓存溢出后保留的内存</span></span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithMemoryCapacity:<span class="number">100</span> * <span class="number">1024</span> * <span class="number">1024</span> preferredMemoryCapacity:<span class="number">60</span> * <span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMemoryCapacity:(<span class="built_in">UInt64</span>)memoryCapacity preferredMemoryCapacity:(<span class="built_in">UInt64</span>)preferredMemoryCapacity &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        </span><br><span class="line">      <span class="comment">//1. 声明了一个默认的内存缓存大小100M，还有一个意思是如果超出100M之后，我们去清除缓存，此时仍要保留的缓存大小60M。（如果还是不理解，可以看后文，源码中会讲到）</span></span><br><span class="line">        <span class="keyword">self</span>.memoryCapacity = memoryCapacity;</span><br><span class="line">        <span class="keyword">self</span>.preferredMemoryUsageAfterPurge = preferredMemoryCapacity;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//2. 创建了一个cache字典，我们所有的缓存数据，都被保存在这个字典中，key为url，value为`AFCachedImage`。</span></span><br><span class="line">        <span class="keyword">self</span>.cachedImages = [[<span class="built_in">NSMutableDictionary</span> alloc] init];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSString</span> *queueName = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;com.alamofire.autopurgingimagecache-%@&quot;</span>, [[<span class="built_in">NSUUID</span> UUID] UUIDString]];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//3. 创建了一个并行queue，这个并行queue，这个类除了初始化以外，所有的方法都是在这个并行queue中调用的。</span></span><br><span class="line">        <span class="keyword">self</span>.synchronizationQueue = dispatch_queue_create([queueName cStringUsingEncoding:<span class="built_in">NSASCIIStringEncoding</span>], DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">      <span class="comment">//4. 添加了一个通知，监听内存警告，当发生内存警告，调用该方法，移除所有的缓存，并且把当前缓存数置为0：</span></span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">         addObserver:<span class="keyword">self</span></span><br><span class="line">         selector:<span class="keyword">@selector</span>(removeAllImages)</span><br><span class="line">         name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span></span><br><span class="line">         object:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除所有图片</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)removeAllImages &#123;</span><br><span class="line">    __block <span class="built_in">BOOL</span> removed = <span class="literal">NO</span>;</span><br><span class="line">    dispatch_barrier_sync(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cachedImages.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            [<span class="keyword">self</span>.cachedImages removeAllObjects];</span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage = <span class="number">0</span>;</span><br><span class="line">            removed = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> removed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意这个类大量的使用了<code>dispatch_barrier_sync</code>与<code>dispatch_barrier_async</code>，小伙伴们如果对这两个方法有任何疑惑，可以看看这篇文章：<a target="_blank" rel="noopener" href="http://blog.csdn.net/u013046795/article/details/47057585">dispatch_barrier_async与dispatch_barrier_sync异同</a>。</p>
<ul>
<li>这里我们可以看到使用了<code>dispatch_barrier_sync</code>，这里没有用锁，但是因为使用了<code>dispatch_barrier_sync</code>，不仅同步了<code>synchronizationQueue</code>队列，而且阻塞了当前线程，所以保证了里面执行代码的线程安全问题。</li>
<li>在这里其实使用锁也可以，但是AF在这的处理却是使用同步的机制来保证线程安全，<strong>或许这跟图片的加载缓存的使用场景，高频次有关系</strong>，在这里使用sync，并不需要在去开辟新的线程，浪费性能，只需要在原有线程，提交到<code>synchronizationQueue</code>队列中，阻塞的执行即可。这样省去大量的开辟线程与使用锁带来的性能消耗。（当然这仅仅是我的一个猜测，有不同意见的朋友欢迎讨论~）<ul>
<li>在这里用了<code>dispatch_barrier_sync</code>，因为<code>synchronizationQueue</code>是个并行queue，所以在这里不会出现死锁的问题。</li>
<li>关于保证线程安全的同时，同步还是异步，与性能方面的考量，可以参考这篇文章：<a target="_blank" rel="noopener" href="http://www.cocoachina.com/industry/20130821/6842.html">Objc的底层并发API</a>。</li>
</ul>
</li>
</ul>
<h4 id="3-核心方法addImage"><a href="#3-核心方法addImage" class="headerlink" title="3. 核心方法addImage:"></a>3. 核心方法addImage:</h4><p>接着我们来看看这个类最核心的一个方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加image到cache里</span></span><br><span class="line">- (<span class="keyword">void</span>)addImage:(<span class="built_in">UIImage</span> *)image withIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">   </span><br><span class="line">    <span class="comment">//用dispatch_barrier_async，来同步这个并行队列</span></span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//生成cache对象</span></span><br><span class="line">        AFCachedImage *cacheImage = [[AFCachedImage alloc] initWithImage:image identifier:identifier];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//去之前cache的字典里取</span></span><br><span class="line">        AFCachedImage *previousCachedImage = <span class="keyword">self</span>.cachedImages[identifier];</span><br><span class="line">        <span class="comment">//如果有被缓存过</span></span><br><span class="line">        <span class="keyword">if</span> (previousCachedImage != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="comment">//当前已经使用的内存大小减去图片的大小</span></span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage -= previousCachedImage.totalBytes;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把新cache的image加上去</span></span><br><span class="line">        <span class="keyword">self</span>.cachedImages[identifier] = cacheImage;</span><br><span class="line">        <span class="comment">//加上内存大小</span></span><br><span class="line">        <span class="keyword">self</span>.currentMemoryUsage += cacheImage.totalBytes;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//做缓存溢出的清除，清除的是早期的缓存</span></span><br><span class="line">    dispatch_barrier_async(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        <span class="comment">//如果使用的内存大于我们设置的内存容量</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.currentMemoryUsage &gt; <span class="keyword">self</span>.memoryCapacity) &#123;</span><br><span class="line">            <span class="comment">//拿到使用内存 - 被清空后首选内存 =  需要被清除的内存</span></span><br><span class="line">            <span class="built_in">UInt64</span> bytesToPurge = <span class="keyword">self</span>.currentMemoryUsage - <span class="keyword">self</span>.preferredMemoryUsageAfterPurge;</span><br><span class="line">            <span class="comment">//拿到所有缓存的数据</span></span><br><span class="line">            <span class="built_in">NSMutableArray</span> &lt;AFCachedImage*&gt; *sortedImages = [<span class="built_in">NSMutableArray</span> arrayWithArray:<span class="keyword">self</span>.cachedImages.allValues];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//根据lastAccessDate排序 升序，越晚的越后面</span></span><br><span class="line">            <span class="built_in">NSSortDescriptor</span> *sortDescriptor = [[<span class="built_in">NSSortDescriptor</span> alloc] initWithKey:<span class="string">@&quot;lastAccessDate&quot;</span></span><br><span class="line">                                                                           ascending:<span class="literal">YES</span>];</span><br><span class="line">            </span><br><span class="line">            [sortedImages sortUsingDescriptors:@[sortDescriptor]];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">UInt64</span> bytesPurged = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//移除早期的cache bytesToPurge大小</span></span><br><span class="line">            <span class="keyword">for</span> (AFCachedImage *cachedImage <span class="keyword">in</span> sortedImages) &#123;</span><br><span class="line">                [<span class="keyword">self</span>.cachedImages removeObjectForKey:cachedImage.identifier];</span><br><span class="line">                bytesPurged += cachedImage.totalBytes;</span><br><span class="line">                <span class="keyword">if</span> (bytesPurged &gt;= bytesToPurge) &#123;</span><br><span class="line">                    <span class="keyword">break</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//减去被清掉的内存</span></span><br><span class="line">            <span class="keyword">self</span>.currentMemoryUsage -= bytesPurged;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看注释应该很容易明白，这个方法做了两件事：</p>
<ol>
<li>设置缓存到字典里，并且把对应的缓存大小设置到当前已缓存的数量属性中。</li>
<li>判断是缓存超出了我们设置的最大缓存100M，如果是的话，则清除掉部分早时间的缓存，清除到缓存小于我们溢出后保留的内存60M以内。</li>
</ol>
<p>当然在这里更需要说一说的是<code>dispatch_barrier_async</code>，这里整个类都没有使用<code>dispatch_async</code>，所以不存在是为了做一个栅栏，来同步上下文的线程。其实它在本类中的作用很简单，就是一个串行执行。</p>
<ul>
<li>讲到这，小伙伴们又疑惑了，既然就是只是为了串行，那为什么我们不用一个串行queue就得了？非得用<code>dispatch_barrier_async</code>干嘛？其实小伙伴要是看的仔细，就明白了，上文我们说过，我们要用<code>dispatch_barrier_sync</code>来保证线程安全。<strong>如果我们使用串行queue,那么线程是极其容易死锁的。</strong></li>
</ul>
<h4 id="4-其他几个方法"><a href="#4-其他几个方法" class="headerlink" title="4. 其他几个方法"></a>4. 其他几个方法</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据id获取图片</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageWithIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    __block <span class="built_in">UIImage</span> *image = <span class="literal">nil</span>;</span><br><span class="line">    <span class="comment">//用同步的方式获取，防止线程安全问题</span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.synchronizationQueue, ^&#123;</span><br><span class="line">        AFCachedImage *cachedImage = <span class="keyword">self</span>.cachedImages[identifier];</span><br><span class="line">        <span class="comment">//并且刷新获取的时间</span></span><br><span class="line">        image = [cachedImage accessImage];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据request和additionalIdentifier添加cache</span></span><br><span class="line">- (<span class="keyword">void</span>)addImage:(<span class="built_in">UIImage</span> *)image forRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    [<span class="keyword">self</span> addImage:image withIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据request和additionalIdentifier移除图片</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)removeImageforRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> removeImageWithIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//根据request和additionalIdentifier获取图片</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageforRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)identifier &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> imageWithIdentifier:[<span class="keyword">self</span> imageCacheKeyFromURLRequest:request withAdditionalIdentifier:identifier]];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成id的方式为Url字符串+additionalIdentifier</span></span><br><span class="line">- (<span class="built_in">NSString</span> *)imageCacheKeyFromURLRequest:(<span class="built_in">NSURLRequest</span> *)request withAdditionalIdentifier:(<span class="built_in">NSString</span> *)additionalIdentifier &#123;</span><br><span class="line">    <span class="built_in">NSString</span> *key = request.URL.absoluteString;</span><br><span class="line">    <span class="keyword">if</span> (additionalIdentifier != <span class="literal">nil</span>) &#123;</span><br><span class="line">        key = [key stringByAppendingString:additionalIdentifier];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个方法都很简单，大家自己看看就好了，就不赘述了。至此<code>AFAutoPurgingImageCache</code>也讲完了，我们还是等到最后再来总结。</p>
<h3 id="5-2-3-UIImageView-AFNetworking"><a href="#5-2-3-UIImageView-AFNetworking" class="headerlink" title="5.2.3 UIImageView+AFNetworking"></a>5.2.3 UIImageView+AFNetworking</h3><p>我们绕了一大圈，总算回到了<code>UIImageView+AFNetworking</code>这个类，现在图片下载的方法，和缓存的方法都有了，实现这个类也是水到渠成的事了。</p>
<h4 id="1-setImageWithURL"><a href="#1-setImageWithURL" class="headerlink" title="1. setImageWithURL:"></a>1. setImageWithURL:</h4><p>我们来看下面我们绝大多数人很熟悉的方法，看看它的实现：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    [<span class="keyword">self</span> setImageWithURL:url placeholderImage:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setImageWithURL:(<span class="built_in">NSURL</span> *)url</span><br><span class="line">       placeholderImage:(<span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//设置head，可接受类型为image</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="built_in">NSMutableURLRequest</span> requestWithURL:url];</span><br><span class="line">    [request addValue:<span class="string">@&quot;image/*&quot;</span> forHTTPHeaderField:<span class="string">@&quot;Accept&quot;</span>];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span> setImageWithURLRequest:request placeholderImage:placeholderImage success:<span class="literal">nil</span> failure:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述方法按顺序往下调用，第二个方法给head的Accept类型设置为Image。接着调用到第三个方法，也是这个类目唯一一个重要的方法：</p>
<h4 id="2-setImageWithURLRequest"><a href="#2-setImageWithURLRequest" class="headerlink" title="2. setImageWithURLRequest:"></a>2. setImageWithURLRequest:</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setImageWithURLRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest</span><br><span class="line">              placeholderImage:(<span class="built_in">UIImage</span> *)placeholderImage</span><br><span class="line">                       success:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> *image))success</span><br><span class="line">                       failure:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLRequest</span> *request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//url为空，则取消</span></span><br><span class="line">    <span class="keyword">if</span> ([urlRequest URL] == <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消task</span></span><br><span class="line">        [<span class="keyword">self</span> cancelImageDownloadTask];</span><br><span class="line">        <span class="comment">//设置为占位图</span></span><br><span class="line">        <span class="keyword">self</span>.image = placeholderImage;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//看看设置的当前的回调的request和需要请求的request是不是为同一个，是的话为重复调用，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isActiveTaskURLEqualToURLRequest:urlRequest])&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//开始请求前，先取消之前的task,即解绑回调</span></span><br><span class="line">    [<span class="keyword">self</span> cancelImageDownloadTask];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拿到downloader</span></span><br><span class="line">    AFImageDownloader *downloader = [[<span class="keyword">self</span> <span class="keyword">class</span>] sharedImageDownloader];</span><br><span class="line">    <span class="comment">//拿到cache</span></span><br><span class="line">    <span class="keyword">id</span> &lt;AFImageRequestCache&gt; imageCache = downloader.imageCache;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Use the image from the image cache if it exists</span></span><br><span class="line">    <span class="built_in">UIImage</span> *cachedImage = [imageCache imageforRequest:urlRequest withAdditionalIdentifier:<span class="literal">nil</span>];</span><br><span class="line">    <span class="comment">//去获取cachedImage</span></span><br><span class="line">    <span class="keyword">if</span> (cachedImage) &#123;</span><br><span class="line">        <span class="comment">//有的话直接设置，并且置空回调</span></span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            success(urlRequest, <span class="literal">nil</span>, cachedImage);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.image = cachedImage;</span><br><span class="line">        &#125;</span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//无缓存，如果有占位图，先设置</span></span><br><span class="line">        <span class="keyword">if</span> (placeholderImage) &#123;</span><br><span class="line">            <span class="keyword">self</span>.image = placeholderImage;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        <span class="built_in">NSUUID</span> *downloadID = [<span class="built_in">NSUUID</span> UUID];</span><br><span class="line">        AFImageDownloadReceipt *receipt;</span><br><span class="line">        <span class="comment">//去下载，并得到一个receipt，可以用来取消回调</span></span><br><span class="line">        receipt = [downloader</span><br><span class="line">                   downloadImageForURLRequest:urlRequest</span><br><span class="line">                   withReceiptID:downloadID</span><br><span class="line">                   success:^(<span class="built_in">NSURLRequest</span> * _Nonnull request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">UIImage</span> * _Nonnull responseObject) &#123;</span><br><span class="line">                       __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">                       <span class="comment">//判断receiptID和downloadID是否相同 成功回调，设置图片</span></span><br><span class="line">                       <span class="keyword">if</span> ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</span><br><span class="line">                           <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                               success(request, response, responseObject);</span><br><span class="line">                           &#125; <span class="keyword">else</span> <span class="keyword">if</span>(responseObject) &#123;</span><br><span class="line">                               strongSelf.image = responseObject;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">//置空回调</span></span><br><span class="line">                           [strongSelf clearActiveDownloadInformation];</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                   &#125;</span><br><span class="line">                   failure:^(<span class="built_in">NSURLRequest</span> * _Nonnull request, <span class="built_in">NSHTTPURLResponse</span> * _Nullable response, <span class="built_in">NSError</span> * _Nonnull error) &#123;</span><br><span class="line">                       __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line">                       <span class="comment">//失败有failuerBlock就回调，</span></span><br><span class="line">                        <span class="keyword">if</span> ([strongSelf.af_activeImageDownloadReceipt.receiptID isEqual:downloadID]) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                                failure(request, response, error);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//置空回调对象</span></span><br><span class="line">                            [strongSelf clearActiveDownloadInformation];</span><br><span class="line">                        &#125;</span><br><span class="line">                   &#125;];</span><br><span class="line">        <span class="comment">//赋值</span></span><br><span class="line">        <span class="keyword">self</span>.af_activeImageDownloadReceipt = receipt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法，细节的地方可以关注注释，这里总结一下做了什么：</p>
<h5 id="1-判断url是否为空-1"><a href="#1-判断url是否为空-1" class="headerlink" title="1) 判断url是否为空"></a>1) 判断url是否为空</h5><p>如果为空则取消task，调用如下方法:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消task</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.af_activeImageDownloadReceipt != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消事件回调响应</span></span><br><span class="line">        [[<span class="keyword">self</span>.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:<span class="keyword">self</span>.af_activeImageDownloadReceipt];</span><br><span class="line">        <span class="comment">//置空</span></span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//置空</span></span><br><span class="line">- (<span class="keyword">void</span>)clearActiveDownloadInformation &#123;</span><br><span class="line">    <span class="keyword">self</span>.af_activeImageDownloadReceipt = <span class="literal">nil</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里注意<code>cancelImageDownloadTask</code>中，调用了<code>self.af_activeImageDownloadReceipt</code>这么一个属性，看看定义的地方：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">UIImageView</span> (<span class="title">_AFNetworking</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readwrite</span>, <span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">setter</span> = af_setActiveImageDownloadReceipt:) AFImageDownloadReceipt *af_activeImageDownloadReceipt;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIImageView</span> (<span class="title">_AFNetworking</span>)</span></span><br><span class="line"><span class="comment">//绑定属性 AFImageDownloadReceipt，就是一个事件响应的接受对象，包含一个task，一个uuid</span></span><br><span class="line"> - (AFImageDownloadReceipt *)af_activeImageDownloadReceipt &#123;</span><br><span class="line">    <span class="keyword">return</span> (AFImageDownloadReceipt *)objc_getAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_activeImageDownloadReceipt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//set</span></span><br><span class="line"> - (<span class="keyword">void</span>)af_setActiveImageDownloadReceipt:(AFImageDownloadReceipt *)imageDownloadReceipt &#123;</span><br><span class="line">    objc_setAssociatedObject(<span class="keyword">self</span>, <span class="keyword">@selector</span>(af_activeImageDownloadReceipt), imageDownloadReceipt, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>我们现在是给<code>UIImageView</code>添加的一个类目，所以我们无法直接添加属性，而是使用的是runtime的方式来生成set和get方法生成了一个<code>AFImageDownloadReceipt</code>类型的属性。看过上文应该知道这个对象里面就一个task和一个UUID。这个属性就是我们这次下载任务相关联的信息。</p>
<h5 id="2-做了一系列判断，见注释"><a href="#2-做了一系列判断，见注释" class="headerlink" title="2) 做了一系列判断，见注释"></a>2) 做了一系列判断，见注释</h5><h5 id="3-创建AFImageDownloader并判断缓存"><a href="#3-创建AFImageDownloader并判断缓存" class="headerlink" title="3) 创建AFImageDownloader并判断缓存"></a>3) 创建AFImageDownloader并判断缓存</h5><p>然后生成了一个我们之前分析过得<code>AFImageDownloader</code>，然后去获取缓存，如果有缓存，则直接读缓存。还记得<code>AFImageDownloader</code>里也有一个读缓存的方法么？那个是和cachePolicy相关的，而这个是有缓存的话直接读取。不明白的可以回过头去看看。</p>
<h5 id="4-请求图片"><a href="#4-请求图片" class="headerlink" title="4) 请求图片"></a>4) 请求图片</h5><p>走到这说明没缓存了，然后就去用<code>AFImageDownloader</code>，我们之前讲过的方法，去请求图片。完成后，则调用成功或者失败的回调，并且置空属性<code>self.af_activeImageDownloadReceipt</code>，成功则设置图片。</p>
<h4 id="3-cancelImageDownloadTask"><a href="#3-cancelImageDownloadTask" class="headerlink" title="3. cancelImageDownloadTask"></a>3. cancelImageDownloadTask</h4><p>还有一个取消这次任务的方法:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消task</span></span><br><span class="line">- (<span class="keyword">void</span>)cancelImageDownloadTask &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.af_activeImageDownloadReceipt != <span class="literal">nil</span>) &#123;</span><br><span class="line">        <span class="comment">//取消事件回调响应</span></span><br><span class="line">        [[<span class="keyword">self</span>.class sharedImageDownloader] cancelTaskForImageDownloadReceipt:<span class="keyword">self</span>.af_activeImageDownloadReceipt];</span><br><span class="line">        <span class="comment">//置空</span></span><br><span class="line">        [<span class="keyword">self</span> clearActiveDownloadInformation];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实也是去调用我们之前讲过的<code>AFImageDownloader</code>的取消方法。</p>
<p>这个类总共就这么几行代码，就完成了我们几乎没有人不用的，设置ImageView图片的方法。当然真正的难点在于<code>AFImageDownloader</code>和<code>AFAutoPurgingImageCache</code>。</p>
<h3 id="5-2-4-总结"><a href="#5-2-4-总结" class="headerlink" title="5.2.4 总结"></a>5.2.4 总结</h3><p>接下来我们来总结一下整个请求图片，缓存，然后设置图片的流程：</p>
<ul>
<li>调用<code>- (void)setImageWithURL:(NSURL *)url;</code>时，我们生成 <code>AFImageDownloader</code>单例，并替我们请求数据。</li>
<li>而<code>AFImageDownloader</code>会生成一个<code>AFAutoPurgingImageCache</code>替我们缓存生成的数据。当然我们设置的时候，给<code>session</code>的<code>configuration</code>设置了一个系统级别的缓存<code>NSUrlCache</code>,这两者是互相独立工作的，互不影响的。</li>
<li>然后<code>AFImageDownloader</code>，就实现下载和协调<code>AFAutoPurgingImageCache</code>去缓存，还有一些取消下载的方法。然后通过回调把数据给到我们的类目<code>UIImageView+AFNetworking</code>,如果成功获取数据，则由类目设置上图片，整个流程结束。</li>
</ul>
<p>经过这三个文件： <code>UIImageView+AFNetworking</code>、<code>AFImageDownloader</code>、<code>AFAutoPurgingImageCache</code>，至此整个设置网络图片的方法结束了。</p>
<p>写在最后：对于UIKit的总结，我们就到此为止了，其它部分的扩展，小伙伴们可以自行阅读，都很简单，基本上每个类200行左右的代码。核心功能基本上都是围绕<code>AFURLSessionManager</code>实现的。</p>
<h1 id="六、AF2-x与AF3-x"><a href="#六、AF2-x与AF3-x" class="headerlink" title="六、AF2.x与AF3.x"></a>六、AF2.x与AF3.x</h1><p>以下是<strong>涉及AF2.x的核心实现，与AF3.x最新版本之间的对比，以及本系列的一个最终总结：AFNetworking到底做了什么？</strong></p>
<h2 id="6-1-源码结构"><a href="#6-1-源码结构" class="headerlink" title="6.1 源码结构"></a>6.1 源码结构</h2><p>首先我们来看看AF2.x的项目目录:</p>
<img src="/images/AFN/AFN-10.jpg" alt="img" style="zoom:70%;" />

<p>除了UIKit扩展外，大概就是上述这么多类，其中最重要的有3个类：</p>
<ul>
<li>AFURLConnectionOperation：大家都知道，AF2.x是基于<code>NSURLConnection</code>来封装的，而<code>NSURLConnection</code>的创建以及数据请求，就被封装在这个类中。所以这个类基本上是AF2.x最底层也是最核心的类。</li>
<li>AFHTTPRequestOperation：继承自<code>AFURLConnectionOperation</code>，对它父类一些方法做了些封装。</li>
<li>AFHTTPRequestOperationManager：则是一个管家，去管理这些这些<code>operation</code>。</li>
</ul>
<p>我们接下来按照网络请求的流程去看看AF2.x的实现：</p>
<p>注：本文会涉及一些<code>NSOperationQueue</code>、<code>NSOperation</code>方面的知识，如果对这方面的内容不了解的话，可以先看看雷纯峰的这篇：<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/">iOS 并发编程之 Operation Queues </a></p>
<p>首先，我们来写一个get或者post请求：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">AFHTTPRequestOperationManager *manager = [AFHTTPRequestOperationManager manager];</span><br><span class="line">[manager GET:url parameters:params</span><br><span class="line">     success:^(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125; failure:^(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">         </span><br><span class="line">     &#125;];</span><br></pre></td></tr></table></figure>

<p>就这么简单的几行代码，完成了一个网络请求。</p>
<h2 id="6-2-AFHTTPRequestOperationManager"><a href="#6-2-AFHTTPRequestOperationManager" class="headerlink" title="6.2 AFHTTPRequestOperationManager"></a>6.2 AFHTTPRequestOperationManager</h2><h3 id="6-2-1-初始化方法"><a href="#6-2-1-初始化方法" class="headerlink" title="6.2.1 初始化方法"></a>6.2.1 初始化方法</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)manager &#123;</span><br><span class="line">    <span class="keyword">return</span> [[<span class="keyword">self</span> alloc] initWithBaseURL:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithBaseURL:<span class="literal">nil</span>];    </span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithBaseURL:(<span class="built_in">NSURL</span> *)url &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Ensure terminal slash for baseURL path, so that NSURL +URLWithString:relativeToURL: works as expected</span></span><br><span class="line">    <span class="keyword">if</span> ([[url path] length] &gt; <span class="number">0</span> &amp;&amp; ![[url absoluteString] hasSuffix:<span class="string">@&quot;/&quot;</span>]) &#123;</span><br><span class="line">        url = [url URLByAppendingPathComponent:<span class="string">@&quot;&quot;</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.baseURL = url;</span><br><span class="line">    <span class="keyword">self</span>.requestSerializer = [AFHTTPRequestSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFJSONResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line">    <span class="keyword">self</span>.reachabilityManager = [AFNetworkReachabilityManager sharedManager];</span><br><span class="line">    <span class="comment">//用来调度所有请求的queue</span></span><br><span class="line">    <span class="keyword">self</span>.operationQueue = [[<span class="built_in">NSOperationQueue</span> alloc] init];</span><br><span class="line">    <span class="comment">//是否做证书验证</span></span><br><span class="line">    <span class="keyword">self</span>.shouldUseCredentialStorage = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方法很简单，基本和AF3.x类似，除了以下两点：</p>
<ol>
<li>设置了一个<code>operationQueue</code>，这个队列，用来调度里面所有的<code>operation</code>，在AF2.x中，每一个<code>operation</code>就是一个网络请求。</li>
<li>设置<code>shouldUseCredentialStorage</code>为YES，这个后面会传给<code>operation</code>，<code>operation</code>会根据这个值，去返回给代理，系统是否做https的证书验证。</li>
</ol>
<h3 id="6-2-2-get方法及AFHTTPRequestOperation创建"><a href="#6-2-2-get方法及AFHTTPRequestOperation创建" class="headerlink" title="6.2.2 get方法及AFHTTPRequestOperation创建"></a>6.2.2 get方法及AFHTTPRequestOperation创建</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">- (AFHTTPRequestOperation *)GET:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">                     parameters:(<span class="keyword">id</span>)parameters</span><br><span class="line">                        success:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                        failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//1. 用 self.requestSerializer 生成了一个request，至于如何生成，可以参考之前的文章，这里就不赘述了。</span></span><br><span class="line">    <span class="built_in">NSMutableURLRequest</span> *request = [<span class="keyword">self</span>.requestSerializer requestWithMethod:<span class="string">@&quot;GET&quot;</span> URLString:[[<span class="built_in">NSURL</span> URLWithString:URLString relativeToURL:<span class="keyword">self</span>.baseURL] absoluteString] parameters:parameters error:<span class="literal">nil</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2. 生成了一个 AFHTTPRequestOperation，然后把这个 operation 加到我们一开始创建的 queue 中。</span></span><br><span class="line">    AFHTTPRequestOperation *operation = [<span class="keyword">self</span> HTTPRequestOperationWithRequest:request success:success failure:failure];</span><br><span class="line"></span><br><span class="line">    [<span class="keyword">self</span>.operationQueue addOperation:operation];</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中创建<code>AFHTTPRequestOperation</code>方法如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 方法创建了一个 AFHTTPRequestOperation ，并把自己的一些参数交给了这个 operation 处理。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (AFHTTPRequestOperation *)HTTPRequestOperationWithRequest:(<span class="built_in">NSURLRequest</span> *)request</span><br><span class="line">                      success:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                      failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//创建自定义的AFHTTPRequestOperation</span></span><br><span class="line">    AFHTTPRequestOperation *operation = [[AFHTTPRequestOperation alloc] initWithRequest:request];</span><br><span class="line">    operation.responseSerializer = <span class="keyword">self</span>.responseSerializer;</span><br><span class="line">    operation.shouldUseCredentialStorage = <span class="keyword">self</span>.shouldUseCredentialStorage;</span><br><span class="line">    operation.credential = <span class="keyword">self</span>.credential;</span><br><span class="line">    <span class="comment">//设置自定义的安全策略</span></span><br><span class="line">    operation.securityPolicy = <span class="keyword">self</span>.securityPolicy;</span><br><span class="line"></span><br><span class="line">    [operation setCompletionBlockWithSuccess:success failure:failure];</span><br><span class="line">    operation.completionQueue = <span class="keyword">self</span>.completionQueue;</span><br><span class="line">    operation.completionGroup = <span class="keyword">self</span>.completionGroup;</span><br><span class="line">    <span class="keyword">return</span> operation;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进入到AFHTTPRequestOperation的初始化方法</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithRequest:urlRequest];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到除了设置了一个<code>self.responseSerializer</code>，实际上是调用了父类，也是我们最核心的类<code>AFURLConnectionOperation</code>的初始化方法。</p>
<h2 id="6-3-AFURLConnectionOperation"><a href="#6-3-AFURLConnectionOperation" class="headerlink" title="6.3 AFURLConnectionOperation"></a>6.3 AFURLConnectionOperation</h2><h3 id="6-3-1-初始化方法"><a href="#6-3-1-初始化方法" class="headerlink" title="6.3.1 初始化方法"></a>6.3.1 初始化方法</h3><p>首先我们要明确<strong>这个类是继承自NSOperation的</strong>，然后我们接着往下看：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化</span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="built_in">NSParameterAssert</span>(urlRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置为ready</span></span><br><span class="line">    _state = AFOperationReadyState;</span><br><span class="line">    <span class="comment">//递归锁</span></span><br><span class="line">    <span class="keyword">self</span>.lock = [[<span class="built_in">NSRecursiveLock</span> alloc] init];</span><br><span class="line">    <span class="keyword">self</span>.lock.name = kAFNetworkingLockName;</span><br><span class="line">    <span class="keyword">self</span>.runLoopModes = [<span class="built_in">NSSet</span> setWithObject:<span class="built_in">NSRunLoopCommonModes</span>];</span><br><span class="line">    <span class="keyword">self</span>.request = urlRequest;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是否应该咨询证书存储连接</span></span><br><span class="line">    <span class="keyword">self</span>.shouldUseCredentialStorage = <span class="literal">YES</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//https认证策略</span></span><br><span class="line">    <span class="keyword">self</span>.securityPolicy = [AFSecurityPolicy defaultPolicy];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>初始化方法中，初始化了一些属性，下面我们来简单的介绍一下这些属性：</p>
<h3 id="6-3-2-成员变量和属性"><a href="#6-3-2-成员变量和属性" class="headerlink" title="6.3.2 成员变量和属性"></a>6.3.2 成员变量和属性</h3><h4 id="1-属性state和重写setter"><a href="#1-属性state和重写setter" class="headerlink" title="1. 属性state和重写setter"></a>1. 属性state和重写setter</h4><p><code>_state</code>设置为<code>AFOperationReadyState</code> 准备就绪状态，这是个枚举：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, AFOperationState) &#123;</span><br><span class="line">    AFOperationPausedState      = <span class="number">-1</span>,  <span class="comment">//停止</span></span><br><span class="line">    AFOperationReadyState       = <span class="number">1</span>,   <span class="comment">//准备就绪</span></span><br><span class="line">    AFOperationExecutingState   = <span class="number">2</span>,  <span class="comment">//正在进行中</span></span><br><span class="line">    AFOperationFinishedState    = <span class="number">3</span>,  <span class="comment">//完成</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>本类重写了state的setter方法，在改变<code>state</code>的时候，同时会发送<code>KVO</code>。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)setState:(AFOperationState)state &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断从当前状态到另一个状态是不是合理，在加上现在是否取消。。大神的框架就是屌啊，这判断严谨的。。一层层</span></span><br><span class="line">    <span class="keyword">if</span> (!AFStateTransitionIsValid(<span class="keyword">self</span>.state, state, [<span class="keyword">self</span> isCancelled])) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//拿到对应的父类管理当前线程周期的key</span></span><br><span class="line">    <span class="built_in">NSString</span> *oldStateKey = AFKeyPathFromOperationState(<span class="keyword">self</span>.state);</span><br><span class="line">    <span class="built_in">NSString</span> *newStateKey = AFKeyPathFromOperationState(state);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//发出KVO</span></span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:newStateKey];</span><br><span class="line">    [<span class="keyword">self</span> willChangeValueForKey:oldStateKey];</span><br><span class="line">    _state = state;</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:oldStateKey];</span><br><span class="line">    [<span class="keyword">self</span> didChangeValueForKey:newStateKey];</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个<code>_state</code>标志着这个网络请求的状态，一共如上4种状态。这些状态其实对应着<code>operation</code>如下的状态：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//映射这个operation的各个状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> NSString * <span class="title">AFKeyPathFromOperationState</span><span class="params">(AFOperationState state)</span> </span>&#123;</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (state) &#123;</span><br><span class="line">        <span class="keyword">case</span> AFOperationReadyState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isReady&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationExecutingState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isExecuting&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationFinishedState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isFinished&quot;</span>;</span><br><span class="line">        <span class="keyword">case</span> AFOperationPausedState:</span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;isPaused&quot;</span>;</span><br><span class="line">        <span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wunreachable-code&quot;</span></span></span><br><span class="line">            <span class="keyword">return</span> @<span class="string">&quot;state&quot;</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-重写父类NSOperation的属性getter"><a href="#2-重写父类NSOperation的属性getter" class="headerlink" title="2. 重写父类NSOperation的属性getter"></a>2. 重写父类NSOperation的属性getter</h4><p>复写了这些属性的get方法，用来和自定义的state一一对应：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复写这些方法，与自己的定义的state对应</span></span><br><span class="line"> - (<span class="built_in">BOOL</span>)isReady &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationReadyState &amp;&amp; [<span class="keyword">super</span> isReady];</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="built_in">BOOL</span>)isExecuting &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationExecutingState;</span><br><span class="line">&#125;</span><br><span class="line"> - (<span class="built_in">BOOL</span>)isFinished &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.state == AFOperationFinishedState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-属性lock"><a href="#3-属性lock" class="headerlink" title="3. 属性lock"></a>3. 属性lock</h4><p><code>self.lock</code>这个锁是用来提供给本类一些数据操作的线程安全，至于为什么要用递归锁，是因为有些方法可能会存在递归调用的情况，例如有些需要锁的方法可能会在一个大的操作环中，形成递归。<strong>而AF使用了递归锁，避免了这种情况下死锁的发生</strong>。</p>
<h4 id="4-属性runLoopModes"><a href="#4-属性runLoopModes" class="headerlink" title="4. 属性runLoopModes"></a>4. 属性runLoopModes</h4><p>初始化了<code>self.runLoopModes</code>，默认为<code>NSRunLoopCommonModes</code>。</p>
<h4 id="5-属性securityPolicy"><a href="#5-属性securityPolicy" class="headerlink" title="5. 属性securityPolicy"></a>5. 属性securityPolicy</h4><p>生成了一个默认的 <code>self.securityPolicy</code>，关于这个policy执行的https认证，可以见楼主之前的文章。</p>
<h3 id="6-3-3-复写operation的start方法"><a href="#6-3-3-复写operation的start方法" class="headerlink" title="6.3.3 复写operation的start方法"></a>6.3.3 复写operation的start方法</h3><p>这个类为了自定义<code>operation</code>的各种状态，而且更好的掌控它的生命周期，复写了<code>operation</code>的<code>start</code>方法。</p>
<h4 id="1-源码实现"><a href="#1-源码实现" class="headerlink" title="1. 源码实现"></a>1. 源码实现</h4><p>当这个<code>operation</code>在一个新线程被调度执行的时候，首先就调入这个<code>start</code>方法中，接下来我们它的实现看看：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)start &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果被取消了就调用取消的方法</span></span><br><span class="line">    <span class="keyword">if</span> ([<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        <span class="comment">//在AF常驻线程中去执行</span></span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(cancelConnection) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//准备好了，才开始</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ([<span class="keyword">self</span> isReady]) &#123;</span><br><span class="line">        <span class="comment">//改变状态，开始执行</span></span><br><span class="line">        <span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">        [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注意，发起请求和取消请求都是在同一个线程！！包括回调都是在一个线程</span></span><br><span class="line">    </span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法判断了当前的状态，是取消还是准备就绪，然后去调用了各自对应的方法。</p>
<h4 id="2-开辟新线程"><a href="#2-开辟新线程" class="headerlink" title="2. 开辟新线程"></a>2. 开辟新线程</h4><p>注意这些方法都是在另外一个线程中去调用的，我们来看看这个线程：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)networkRequestThreadEntryPoint:(<span class="keyword">id</span>)__unused object &#123;</span><br><span class="line">    <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">        [[<span class="built_in">NSThread</span> currentThread] setName:<span class="string">@&quot;AFNetworking&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="comment">//添加端口，防止runloop直接退出</span></span><br><span class="line">        [runLoop addPort:[<span class="built_in">NSMachPort</span> port] forMode:<span class="built_in">NSDefaultRunLoopMode</span>];</span><br><span class="line">        [runLoop run];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">NSThread</span> *)networkRequestThread &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">NSThread</span> *_networkRequestThread = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> oncePredicate;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;oncePredicate, ^&#123;</span><br><span class="line">        _networkRequestThread = [[<span class="built_in">NSThread</span> alloc] initWithTarget:<span class="keyword">self</span> selector:<span class="keyword">@selector</span>(networkRequestThreadEntryPoint:) object:<span class="literal">nil</span>];</span><br><span class="line">        [_networkRequestThread start];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> _networkRequestThread;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这两个方法基本上是被许多人举例用过无数次了…</p>
<ul>
<li>这是一个单例，用<code>NSThread</code>创建了一个线程，并且为这个线程添加了一个<code>runloop</code>，并且加了一个<code>NSMachPort</code>，来防止<code>runloop</code>直接退出。</li>
<li><strong>这条线程就是AF用来发起网络请求，并且接受网络请求回调的线程，仅仅就这一条线程</strong>（到最后我们来讲为什么要这么做）。和我们之前讲的AF3.x发起请求，并且接受请求回调时的处理方式，遥相呼应。</li>
</ul>
<h4 id="3-start调用流程"><a href="#3-start调用流程" class="headerlink" title="3. start调用流程"></a>3. start调用流程</h4><p>我们接着来看如果准备就绪，start调用的方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//改变状态，开始执行</span></span><br><span class="line"><span class="keyword">self</span>.state = AFOperationExecutingState;</span><br><span class="line">[<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(operationDidStart) onThread:[[<span class="keyword">self</span> <span class="keyword">class</span>] networkRequestThread] withObject:<span class="literal">nil</span> waitUntilDone:<span class="literal">NO</span> modes:[<span class="keyword">self</span>.runLoopModes allObjects]];</span><br></pre></td></tr></table></figure>

<p>接着在常驻线程中,并且不阻塞的方式，在我们<code>self.runLoopModes</code>的模式下调用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)operationDidStart &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//如果没取消</span></span><br><span class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span> isCancelled]) &#123;</span><br><span class="line">        <span class="comment">//设置为startImmediately YES 请求发出，回调会加入到主线程的 Runloop 下，RunloopMode 会默认为 NSDefaultRunLoopMode</span></span><br><span class="line">        <span class="keyword">self</span>.connection = [[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:<span class="keyword">self</span>.request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">NO</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">NSRunLoop</span> *runLoop = [<span class="built_in">NSRunLoop</span> currentRunLoop];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSString</span> *runLoopMode <span class="keyword">in</span> <span class="keyword">self</span>.runLoopModes) &#123;</span><br><span class="line">            <span class="comment">//把connection和outputStream注册到当前线程runloop中去，只有这样，才能在这个线程中回调</span></span><br><span class="line">            [<span class="keyword">self</span>.connection scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">            [<span class="keyword">self</span>.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打开输出流</span></span><br><span class="line">        [<span class="keyword">self</span>.outputStream open];</span><br><span class="line">        <span class="comment">//开启请求</span></span><br><span class="line">        [<span class="keyword">self</span>.connection start];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingOperationDidStartNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法做了以下几件事：</p>
<h5 id="1-创建NSURLConnection"><a href="#1-创建NSURLConnection" class="headerlink" title="1) 创建NSURLConnection"></a>1) 创建NSURLConnection</h5><p>首先这个方法创建了一个<code>NSURLConnection</code>，设置代理为自己，startImmediately为NO，至于这个参数干什么用的，我们来看看官方文档：</p>
<blockquote>
<p>startImmediately<br> YES if the connection should begin loading data immediately, otherwise NO. If you pass NO, the connection is not scheduled with a run loop. You can then schedule the connection in the run loop and mode of your choice by calling scheduleInRunLoop:forMode: .</p>
</blockquote>
<p>大意是，这个值默认为YES，而且任务完成的结果会在主线程的runloop中回调。如果我们设置为NO，则需要调用我们下面看到的：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">self.connection scheduleInRunLoop:runLoop forMode:runLoopMode</span>];</span><br></pre></td></tr></table></figure>

<p>去注册一个runloop和mode，它会在我们指定的这个runloop所在的线程中回调结果。</p>
<h5 id="2-outputStream的创建及注册"><a href="#2-outputStream的创建及注册" class="headerlink" title="2) outputStream的创建及注册"></a>2) outputStream的创建及注册</h5><p>值得一提的是这里调用了:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">self.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode</span>];</span><br></pre></td></tr></table></figure>

<p>这个<code>outputStream</code>在getter方法中被初始化了：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSOutputStream</span> *)outputStream &#123;</span><br><span class="line">    <span class="keyword">if</span> (!_outputStream) &#123;</span><br><span class="line">        <span class="comment">//一个写入到内存中的流，可以通过NSStreamDataWrittenToMemoryStreamKey拿到写入后的数据</span></span><br><span class="line">        <span class="keyword">self</span>.outputStream = [<span class="built_in">NSOutputStream</span> outputStreamToMemory];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _outputStream;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里数据请求和拼接并没有用<code>NSMutableData</code>，而是用了<code>outputStream</code>，而且把写入的数据，放到内存中。</p>
<ul>
<li>其实讲道理来说<code>outputStream</code>的优势在于下载大文件的时候，可以以流的形式，将文件直接保存到本地，<strong>这样可以为我们节省很多的内存</strong>，调用如下方法设置：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="built_in">NSOutputStream</span> outputStreamToFileAtPath:<span class="string">@&quot;filePath&quot;</span> append:<span class="literal">YES</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li>但是这里是把流写入内存中，这样其实这个节省内存的意义已经不存在了。那为什么还要用呢？这里我猜测的是就是为了用它这个可以注册在某一个<code>runloop</code>的指定<code>mode</code>下。 虽然AF使用这个<code>outputStream</code>是肯定在这个常驻线程中的，不会有线程安全的问题。但是要注意它是被声明在.h中的：</li>
</ul>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSOutputStream</span> *outputStream;</span><br></pre></td></tr></table></figure>

<p>难保外部不会在其他线程对这个数据做什么操作，所以它相对于<code>NSMutableData</code>作用就体现出来了，就算我们在外部其它线程中去操作它，也不会有线程安全的问题。</p>
<h5 id="3-开始执行connection"><a href="#3-开始执行connection" class="headerlink" title="3) 开始执行connection"></a>3) 开始执行connection</h5><h5 id="4-到主线程发送任务开始执行的通知"><a href="#4-到主线程发送任务开始执行的通知" class="headerlink" title="4) 到主线程发送任务开始执行的通知"></a>4) 到主线程发送任务开始执行的通知</h5><h3 id="6-3-4-实现NSURLConnectionDelegate"><a href="#6-3-4-实现NSURLConnectionDelegate" class="headerlink" title="6.3.4 实现NSURLConnectionDelegate"></a>6.3.4 实现NSURLConnectionDelegate</h3><p>接下来网络请求开始执行了，就开始触发<code>connection</code>的代理方法了：</p>
<img src="/images/AFN/AFN-11.jpg" alt="img" style="zoom:74%;" />


<p> AF2.x一共实现了如上这么多代理方法，这些代理方法，作用大部分和我们之前讲的<code>NSURLSession</code>的代理方法类似，我们重点讲下面这四个代理：</p>
<p>注意，有一点需要说明，我们之前是把connection注册在我们常驻线程的runloop中了，<strong>所以以下所有的代理方法，都是在这仅有的一条常驻线程中回调。</strong></p>
<h4 id="1-connection-didReceiveResponse"><a href="#1-connection-didReceiveResponse" class="headerlink" title="1. connection:didReceiveResponse"></a>1. connection:didReceiveResponse</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//收到响应，响应头类似相关数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">self</span>.response = response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没什么好说的，就是收到响应后，把response赋给自己的属性。</p>
<h4 id="2-connection-didReceiveData"><a href="#2-connection-didReceiveData" class="headerlink" title="2. connection:didReceiveData"></a>2. connection:didReceiveData</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拼接获取到的数据</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">    didReceiveData:(<span class="built_in">NSData</span> *)data</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSUInteger</span> length = [data length];</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">YES</span>) &#123;</span><br><span class="line">        <span class="built_in">NSInteger</span> totalNumberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//如果outputStream 还有空余空间</span></span><br><span class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.outputStream hasSpaceAvailable]) &#123;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//创建一个buffer流缓冲区，大小为data的字节数</span></span><br><span class="line">            <span class="keyword">const</span> uint8_t *dataBuffer = (uint8_t *)[data bytes];</span><br><span class="line"></span><br><span class="line">            <span class="built_in">NSInteger</span> numberOfBytesWritten = <span class="number">0</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="comment">//当写的长度小于数据的长度，在循环里</span></span><br><span class="line">            <span class="keyword">while</span> (totalNumberOfBytesWritten &lt; (<span class="built_in">NSInteger</span>)length) &#123;</span><br><span class="line">                <span class="comment">//往outputStream写数据，系统的方法，一次就写一部分，得循环写</span></span><br><span class="line">                numberOfBytesWritten = [<span class="keyword">self</span>.outputStream write:&amp;dataBuffer[(<span class="built_in">NSUInteger</span>)totalNumberOfBytesWritten] maxLength:(length - (<span class="built_in">NSUInteger</span>)totalNumberOfBytesWritten)];</span><br><span class="line">                <span class="comment">//如果 numberOfBytesWritten写入失败了。跳出循环</span></span><br><span class="line">                <span class="keyword">if</span> (numberOfBytesWritten == <span class="number">-1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//加上每次写的长度</span></span><br><span class="line">                totalNumberOfBytesWritten += numberOfBytesWritten;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//出错</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.outputStream.streamError) &#123;</span><br><span class="line">            <span class="comment">//取消connection</span></span><br><span class="line">            [<span class="keyword">self</span>.connection cancel];</span><br><span class="line">            <span class="comment">//调用失败的方法</span></span><br><span class="line">            [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(connection:didFailWithError:) withObject:<span class="keyword">self</span>.connection withObject:<span class="keyword">self</span>.outputStream.streamError];</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主线程回调下载数据大小</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">self</span>.totalBytesRead += (<span class="keyword">long</span> <span class="keyword">long</span>)length;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadProgress) &#123;</span><br><span class="line">            <span class="keyword">self</span>.downloadProgress(length, <span class="keyword">self</span>.totalBytesRead, <span class="keyword">self</span>.response.expectedContentLength);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法看起来长，其实容易理解而且简单，它只做了3件事：</p>
<ol>
<li>给<code>outputStream</code>拼接数据，具体如果拼接，大家可以读注释自行理解下。</li>
<li>如果出错则调用：<code>connection:didFailWithError:</code>也就是网络请求失败的代理，我们一会下面就会讲。</li>
<li>在主线程中回调下载进度。</li>
</ol>
<h4 id="3-connectionDidFinishLoading"><a href="#3-connectionDidFinishLoading" class="headerlink" title="3. connectionDidFinishLoading"></a>3. connectionDidFinishLoading</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//完成了调用</span></span><br><span class="line">- (<span class="keyword">void</span>)connectionDidFinishLoading:(<span class="built_in">NSURLConnection</span> __unused *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从outputStream中拿到数据 NSStreamDataWrittenToMemoryStreamKey写入到内存中的流</span></span><br><span class="line">    <span class="keyword">self</span>.responseData = [<span class="keyword">self</span>.outputStream propertyForKey:<span class="built_in">NSStreamDataWrittenToMemoryStreamKey</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//关闭outputStream</span></span><br><span class="line">    [<span class="keyword">self</span>.outputStream close];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//如果响应数据已经有了，则outputStream置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseData) &#123;</span><br><span class="line">       <span class="keyword">self</span>.outputStream = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清空connection</span></span><br><span class="line">    <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span> finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个代理是任务完成之后调用。我们从<code>outputStream</code>拿到了最后下载数据，然后关闭置空了<code>outputStream</code>。并且清空了<code>connection</code>。调用了<code>finish</code>:</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="keyword">void</span>)finish &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="comment">//修改状态</span></span><br><span class="line">    <span class="keyword">self</span>.state = AFOperationFinishedState;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送完成的通知</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:AFNetworkingOperationDidFinishNotification object:<span class="keyword">self</span>];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把当前任务状态改为已完成，并且到主线程发送任务完成的通知。<strong>这里我们设置状态为已完成。注意上面已经讲过：本类是复写了state的setter方法的</strong>，在改变<code>state</code>的时候，同时会发送<code>KVO</code>。</p>
<p>大家了解<code>NSOperationQueue</code>就知道，如果对应的operation的属性<code>finnished</code>被设置为YES，则代表当前<code>operation</code>结束了，会把<code>operation</code>从队列中移除，并且调用<code>operation</code>的<code>completionBlock</code>。<strong>这点很重要，因为我们请求到的数据就是从这个<code>completionBlock</code>中传递回去的</strong>（下面接着讲这个完成Block，就能从这里对接上了）。</p>
<h4 id="4-connection-didFailWithError"><a href="#4-connection-didFailWithError" class="headerlink" title="4. connection:didFailWithError"></a>4. connection:didFailWithError</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求失败的回调，在cancel connection的时候，自己也主动调用了</span></span><br><span class="line">- (<span class="keyword">void</span>)connection:(<span class="built_in">NSURLConnection</span> __unused *)connection</span><br><span class="line">  didFailWithError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//拿到error</span></span><br><span class="line">    <span class="keyword">self</span>.error = error;</span><br><span class="line">    <span class="comment">//关闭outputStream</span></span><br><span class="line">    [<span class="keyword">self</span>.outputStream close];</span><br><span class="line">    <span class="comment">//如果响应数据已经有了，则outputStream置为nil</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.responseData) &#123;</span><br><span class="line">        <span class="keyword">self</span>.outputStream = <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.connection = <span class="literal">nil</span>;</span><br><span class="line">    [<span class="keyword">self</span> finish];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>唯一需要说一下的就是这里给<code>self.error</code>赋值，之后完成Block会根据这个error，去判断这次请求是成功还是失败。</p>
<p>至此我们把<code>AFURLConnectionOperation</code>的业务主线讲完了。</p>
<p>我们此时数据请求完了，数据在<code>self.responseData</code>中，那它是怎么回到我们手里的呢。需要回到<code>AFURLConnectionOperation</code>子类<code>AFHTTPRequestOperation</code>，有这么一个方法：<code>setCompletionBlockWithSuccess:failure:</code></p>
<h2 id="6-4-AFHTTPRequestOperation"><a href="#6-4-AFHTTPRequestOperation" class="headerlink" title="6.4 AFHTTPRequestOperation"></a>6.4 AFHTTPRequestOperation</h2><h3 id="6-4-1-初始化方法"><a href="#6-4-1-初始化方法" class="headerlink" title="6.4.1 初始化方法"></a>6.4.1 初始化方法</h3><p>前面已经看过这个AFHTTPRequestOperation的初始化方法，这里再整合一下</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">instancetype</span>)initWithRequest:(<span class="built_in">NSURLRequest</span> *)urlRequest &#123;</span><br><span class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> initWithRequest:urlRequest];</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">self</span>.responseSerializer = [AFHTTPResponseSerializer serializer];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了设置了一个<code>self.responseSerializer</code>，实际上是调用了父类，也是我们最核心的类<code>AFURLConnectionOperation</code>的初始化方法。</p>
<h3 id="6-4-2-设置completionBlock"><a href="#6-4-2-设置completionBlock" class="headerlink" title="6.4.2 设置completionBlock"></a>6.4.2 设置completionBlock</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setCompletionBlockWithSuccess:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="keyword">id</span> responseObject))success</span><br><span class="line">                              failure:(<span class="keyword">void</span> (^)(AFHTTPRequestOperation *operation, <span class="built_in">NSError</span> *error))failure</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// completionBlock is manually nilled out in AFURLConnectionOperation to break the retain cycle.</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-retain-cycles&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">    <span class="keyword">self</span>.completionBlock = ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.completionGroup) &#123;</span><br><span class="line">            dispatch_group_enter(<span class="keyword">self</span>.completionGroup);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_async</span>(http_request_operation_processing_queue(), ^&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.error) &#123;</span><br><span class="line">                <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                    dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                        failure(<span class="keyword">self</span>, <span class="keyword">self</span>.error);</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">id</span> responseObject = <span class="keyword">self</span>.responseObject;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.error) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (failure) &#123;</span><br><span class="line">                        dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            failure(<span class="keyword">self</span>, <span class="keyword">self</span>.error);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">                        dispatch_group_async(<span class="keyword">self</span>.completionGroup ?: http_request_operation_completion_group(), <span class="keyword">self</span>.completionQueue ?: dispatch_get_main_queue(), ^&#123;</span><br><span class="line">                            success(<span class="keyword">self</span>, responseObject);</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionGroup) &#123;</span><br><span class="line">                dispatch_group_leave(<span class="keyword">self</span>.completionGroup);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一开始我们在<code>AFHTTPRequestOperationManager</code>中是调用过这个方法的：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[operation setCompletionBlockWithSuccess:success failure:failure];</span><br></pre></td></tr></table></figure>

<ul>
<li>我们在把成功和失败的Block传给了这个方法。</li>
<li>这个方法也很好理解，就是设置我们之前提到过得<code>completionBlock</code>，<strong>当自己数据请求完成，就会调用这个Block。然后我们在这个Block中调用传过来的成功或者失败的Block。</strong>如果error为空，说明请求成功，把数据传出去，否则为失败，把error信息传出。</li>
<li>这里也类似AF3.x，可以自定义一个完成组和完成队列。数据可以在我们自定义的完成组和队列中回调出去。</li>
<li>除此之外，还有一个有意思的地方：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Warc-retain-cycles&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br></pre></td></tr></table></figure>

<p>之前我们说过，这是在忽略编译器的一些警告。</p>
<ul>
<li><code>-Wgnu</code>就不说了，是忽略 ?: 。</li>
<li>值得提下的是<code>-Warc-retain-cycles</code>，这里忽略了循环引用的警告。我们仔细看看就知道<code>self</code>持有了<code>completionBlock</code>，而<code>completionBlock</code>内部持有<code>self</code>。这里确实循环引用了。那么AF是如何解决这个循环引用的呢？</li>
</ul>
<p>我们在回到<code>AFURLConnectionOperation</code>，还有一个方法我们之前没讲到，它复写了setCompletionBlock这个方法。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//复写setCompletionBlock</span></span><br><span class="line">- (<span class="keyword">void</span>)setCompletionBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (!block) &#123;</span><br><span class="line">        [<span class="keyword">super</span> setCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</span><br><span class="line">        [<span class="keyword">super</span> setCompletionBlock:^ &#123;</span><br><span class="line">            __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakSelf)strongSelf = weakSelf;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic push</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic ignored <span class="meta-string">&quot;-Wgnu&quot;</span></span></span><br><span class="line">            <span class="comment">//看有没有自定义的完成组，否则用AF的组</span></span><br><span class="line">            dispatch_group_t group = strongSelf.completionGroup ?: url_request_operation_completion_group();</span><br><span class="line">            <span class="comment">//看有没有自定义的完成queue，否则用主队列</span></span><br><span class="line">            <span class="built_in">dispatch_queue_t</span> queue = strongSelf.completionQueue ?: dispatch_get_main_queue();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> clang diagnostic pop</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//调用设置的Block,在这个组和队列中</span></span><br><span class="line">            dispatch_group_async(group, queue, ^&#123;</span><br><span class="line">                block();</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//结束时候置nil，防止循环引用</span></span><br><span class="line">            dispatch_group_notify(group, url_request_operation_completion_queue(), ^&#123;</span><br><span class="line">                [strongSelf setCompletionBlock:<span class="literal">nil</span>];</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，它在我们设置的block调用结束的时候，主动的调用:</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">strongSelf setCompletionBlock:nil</span>];</span><br></pre></td></tr></table></figure>

<p>把Block置空，这样循环引用不复存在了。</p>
<h3 id="6-4-3-数据解析的调用"><a href="#6-4-3-数据解析的调用" class="headerlink" title="6.4.3 数据解析的调用"></a>6.4.3 数据解析的调用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">id</span>)responseObject &#123;</span><br><span class="line">    [<span class="keyword">self</span>.lock lock];</span><br><span class="line">    <span class="keyword">if</span> (!_responseObject &amp;&amp; [<span class="keyword">self</span> isFinished] &amp;&amp; !<span class="keyword">self</span>.error) &#123;</span><br><span class="line">        <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">        <span class="comment">//做数据解析</span></span><br><span class="line">        <span class="keyword">self</span>.responseObject = [<span class="keyword">self</span>.responseSerializer responseObjectForResponse:<span class="keyword">self</span>.response data:<span class="keyword">self</span>.responseData error:&amp;error];</span><br><span class="line">        <span class="keyword">if</span> (error) &#123;</span><br><span class="line">            <span class="keyword">self</span>.responseSerializationError = error;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">self</span>.lock unlock];</span><br><span class="line">    <span class="keyword">return</span> _responseObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AFHTTPRequestOperation</code> 复写了 <code>responseObject</code> 的getter方法，并且把数据按照我们需要的类型（json、xml等等）进行解析。</p>
<h2 id="6-5-ResponseSerializer与SecurityPolicy"><a href="#6-5-ResponseSerializer与SecurityPolicy" class="headerlink" title="6.5 ResponseSerializer与SecurityPolicy"></a>6.5 ResponseSerializer与SecurityPolicy</h2><p>关于数据的序列化、SecurityPolicy，前面已经详细的讲过，AF2.x与AF3.x基本差不多，不再赘述。<code>AFSecurityPolicy</code> 在  <code>AFURLConnectionOperation</code>中https认证的代理中被调用</p>
<p>至此，AF2.x整个业务流程就结束了。</p>
<h2 id="6-6-总结"><a href="#6-6-总结" class="headerlink" title="6.6 总结"></a>6.6 总结</h2><p>接下来，我们来总结总结AF2.x整个业务请求的流程：</p>
<img src="/images/AFN/AFN-12.jpg" alt="img" style="zoom:65%;" />

<p>如上图，我们来梳理一下整个流程：</p>
<ul>
<li>最上层的是<code>AFHTTPRequestOperationManager</code>,我们调用它进行get、post等等各种类型的网络请求</li>
<li>然后它去调用<code>AFURLRequestSerialization</code>做request参数拼装。然后生成了一个<code>AFHTTPRequestOperation</code>实例，并把request交给它。然后把<code>AFHTTPRequestOperation</code>添加到一个<code>NSOperationQueue</code>中。</li>
<li>接着<code>AFHTTPRequestOperation</code>拿到request后，会去调用它的父类<code>AFURLConnectionOperation</code>的初始化方法，并且把相关参数交给它，除此之外，当父类完成数据请求后，它调用了<code>AFURLResponseSerialization</code>把数据解析成我们需要的格式（json、XML等等）。</li>
<li>最后就是我们AF最底层的类<code>AFURLConnectionOperation</code>，它去数据请求，并且如果是https请求，会在请求的相关代理中，调用<code>AFSecurityPolicy</code>做https认证。最后请求到的数据返回。</li>
</ul>
<p>这就是AF2.x整个做网络请求的业务流程。</p>
<h2 id="6-7-遗留问题：一条常驻线程"><a href="#6-7-遗留问题：一条常驻线程" class="headerlink" title="6.7 遗留问题：一条常驻线程"></a>6.7 遗留问题：一条常驻线程</h2><p>我们来解决解决之前遗留下来的问题：为什么AF2.x需要一条常驻线程？</p>
<p>首先如果我们用<code>NSURLConnection</code>，我们为了获取请求结果有以下三种选择：</p>
<ol>
<li>在主线程调异步接口</li>
<li>每一个请求用一个线程，对应一个runloop，然后等待结果回调。</li>
<li>只用一条线程，一个runloop，所有结果回调在这个线程上。</li>
</ol>
<p>很显然AF选择的是第3种方式，创建了一条常驻线程专门处理所有请求的回调事件，这个模型跟<code>nodejs</code>有点类似，我们来讨论讨论不选择另外两种方式的原因：</p>
<p>先说第一种。试想如果我们所有的请求都在主线程中异步调用，好像没什么不可以？那为什么AF不这么做呢…在这里有两点原因（楼主个人总结的，有不同意见，欢迎讨论）：</p>
<ol>
<li><p>第一，如果我们放到主线程去做，势必要这么写：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSURLConnection</span> alloc] initWithRequest:request delegate:<span class="keyword">self</span> startImmediately:<span class="literal">YES</span>] </span><br></pre></td></tr></table></figure>

<p>这样NSURLConnection的回调会被放在主线程中<code>NSDefaultRunLoopMode</code>中，这样我们在其它类似<code>UITrackingRunLoopMode</code>模式下，我们是得不到网络请求的结果的，这显然不是我们想要的，那么我们势必需要调用：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[connection scheduleInRunLoop:[<span class="built_in">NSRunLoop</span> currentRunLoop] forMode:<span class="built_in">NSRunLoopCommonModes</span>]; </span><br></pre></td></tr></table></figure>

<p>把它加入 <code>NSRunLoopCommonModes</code> 中，试想如果有大量的网络请求，同时回调回来，就会影响我们的UI体验了。</p>
</li>
<li><p>另外一点原因是，如果我们请求数据返回，势必要进行数据解析，解析成我们需要的格式，那么这些解析都在主线程中做，给主线程增加额外的负担。又或者我们回调回来开辟一个新的线程去做数据解析，那么我们有n个请求回来开辟n条线程带来的性能损耗，以及线程间切换带来的损耗，是不是一笔更大的开销。</p>
</li>
</ol>
<p>所以综述两点原因，我们并不适合在主线程中回调。</p>
<p>再说第二种。我们一开始就开辟n条线程去做请求，然后设置runloop保活住线程，等待结果回调。其实看到这，大家想想都觉得这个方法很傻，为了等待不确定的请求结果，阻塞住线程，白白浪费n条线程的开销。</p>
<p>综上所述，这就是<strong>AF2.x需要一条常驻线程的原因了</strong>。</p>
<p>至此我们把AF2.x核心流程分析完了。</p>
<h1 id="七、总结AFNetworking到底做了什么？"><a href="#七、总结AFNetworking到底做了什么？" class="headerlink" title="七、总结AFNetworking到底做了什么？"></a>七、总结AFNetworking到底做了什么？</h1><p>接着到我们本系列一个最终总结了: <strong>AFNetworking到底做了什么？</strong></p>
<p>相信如果从头看到尾的小伙伴，心里都有了一个属于自己的答案。其实在楼主心里，实在不想去总结它，因为<code>AFNetworking</code>中凝聚了太多大牛的思想，根本不是你看完几遍源码所能去议论的。但是想想也知道，如果我说不总结，估计有些看到这的朋友杀人的心都有…所以我还是赶鸭子上架，来总结总结它。</p>
<p>AFNetworking的作用总结：</p>
<p>一、首先我们需要明确一点的是：<strong>相对于AFNetworking2.x，AFNetworking3.x确实没那么有用了。</strong>AFNetworking之前的核心作用就是为了帮我们去调度所有的请求。但是最核心地方却被苹果的<code>NSURLSession</code>给借鉴过去了，嗯…是借鉴。这些请求的调度，现在完全由<code>NSURLSession</code>给做了，AFNetworking3.x的作用被大大的削弱了。</p>
<p>二、但是除此之外，其实它还是很有用的：</p>
<ol>
<li><strong>首先它帮我们做了各种请求方式request的拼接。</strong>想想如果我们用<code>NSURLSession</code>，我们去做请求，是不是还得自己去考虑各种请求方式下，拼接参数的问题。</li>
<li><strong>它还帮我们做了一些公用参数（session级别的），和一些私用参数（task级别的）的分离</strong>。它用Block的形式，支持我们自定义一些代理方法，如果没有实现的话，AF还帮我们做了一些默认的处理。而如果我们用<code>NSURLSession</code>的话，还得参照AF这么一套代理转发的架构模式去封装。</li>
<li><strong>它帮我们做了自定义的https认证处理</strong>。看过楼主之前那篇<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/a84237b07611">AFNetworking之于https认证</a>的朋友就知道，如果我们自己用<code>NSURLSession</code>实现那几种自定义认证，需要多写多少代码…</li>
<li><strong>对于请求到的数据，AF帮我们做了各种格式的数据解析，并且支持我们设置自定义的code范围，自定义的数据方式</strong>。如果不在这些范围中，则直接调用失败block。如果用<code>NSURLSession</code>呢？这些都自己去写吧…（你要是做过各种除json外其他的数据解析,就会知道这里面坑有多少…）</li>
<li><strong>对于成功和失败的回调处理。</strong>AF帮我们在数据请求到，到回调给用户之间，做了各种错误的判断，保证了成功和失败的回调，界限清晰。在这过程中，AF帮我们做了太多的容错处理，而<code>NSURLSession</code>呢？只给了一个完成的回调，我们得多做多少判断，才能拿到一个确定能正常显示的数据？</li>
<li>……</li>
<li>…</li>
</ol>
<p>光是这些网络请求的业务逻辑，AF帮我们做的就太多太多，当然还远不仅于此。它用凝聚着许多大牛的经验方式，帮我在有些处理中做了最优的选择，比如我们之前说到的，回调线程数设置为1的问题…帮我们绕开了很多的坑，比如系统内部并行创建<code>task</code>导致id不唯一等等…</p>
<p>三、而如果我们需要一些UIKit的扩展，AF则提供了最稳定，而且最优化实现方式：</p>
<ul>
<li>就比如之前说到过得那个状态栏小菊花，如果是我们自己去做，得多写多少代码，而且实现的还没有AF那样质量高。</li>
<li>又或者<code>AFImageDownloader</code>，它对于组图片之间的下载协调，以及缓存使用的之间线程调度。对于线程，锁，以及性能各方面权衡，找出最优化的处理方式，试问小伙伴们自己基于<code>NSURLSession</code>去写，能到做几分…</li>
</ul>
<p>所以最后的结论是：<strong>AFNetworking虽然变弱了，但是它还是很有用的。</strong>用它真的不仅仅是习惯，而是因为它确实帮我们做了太多。</p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="https://tenloy.github.io">Tenloy</a>
            <p>原文链接：<a href="https://tenloy.github.io/2021/09/05/AFN-Analyse.html">https://tenloy.github.io/2021/09/05/AFN-Analyse.html</a>
            <p>发表日期：2021.09.05 , 8:53 AM</p>
            <p>更新日期：2024.04.07 , 8:02 PM</p>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Crative Commons 4.0 许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2021/09/07/core-animation01.html" title= "Core Animation(一) - UIView与CALayer、布局与绘制">
                    <div class="nextTitle">Core Animation(一) - UIView与CALayer、布局与绘制</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2021/09/04/nrl-session.html" title= "NSURLSession概述">
                    <div class="prevTitle">NSURLSession概述</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:luotengoto@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/Tenloy" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <a href="https://www.jianshu.com/u/8db1bc12db9f" class="iconfont-jian jianshu" target="_blank" title=jianshu></a>
            
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:40vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%A1%86%E6%9E%B6%E7%BB%93%E6%9E%84"><span class="toc-text">一、框架结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81AFURL-amp-HTTPSessionManager"><span class="toc-text">二、AFURL&amp;HTTPSessionManager</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-AFHTTPSessionManager%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-text">2.1 AFHTTPSessionManager的初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%BA%90%E7%A0%81"><span class="toc-text">2.1.1 初始化源码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-AFHTTPSessionManager"><span class="toc-text">1. AFHTTPSessionManager</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-AFURLSessionManager"><span class="toc-text">2. AFURLSessionManager</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-AF-maxConcurrentOperationCount%E8%AE%BE%E7%BD%AE"><span class="toc-text">2.1.2 AF maxConcurrentOperationCount设置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-AFHTTPSessionManager%E5%88%9B%E5%BB%BAGET-Task"><span class="toc-text">2.2 AFHTTPSessionManager创建GET Task</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.2.1 源码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-AFURLRequestSerialization%E5%88%9B%E5%BB%BArequest"><span class="toc-text">2.2.2 AFURLRequestSerialization创建request</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AErequest%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. 设置request请求类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0request%E9%85%8D%E7%BD%AE%E5%8F%82%E6%95%B0"><span class="toc-text">2. 添加request配置参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BC%96%E7%A0%81%E5%8F%8A%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-text">3. 编码及设置请求参数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AEheader%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-text">1) 设置header中的参数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%B0%86%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">2) 将请求参数转换为字符串</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%A0%B9%E6%8D%AE%E8%AF%B7%E6%B1%82%E7%B1%BB%E5%9E%8B%E8%AE%BE%E7%BD%AE%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0"><span class="toc-text">3) 根据请求类型设置请求参数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-AFURLSessionManger%E7%88%B6%E7%B1%BB%E5%88%9B%E5%BB%BAtask"><span class="toc-text">2.2.3 AFURLSessionManger父类创建task</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-create-task-safely"><span class="toc-text">1. create_task_safely()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-addDelegateForDataTask"><span class="toc-text">2. addDelegateForDataTask:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-AFURLSessionManager%E4%B8%ADSession%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E5%8F%8A%E8%BD%AC%E5%8F%91"><span class="toc-text">2.3 AFURLSessionManager中Session代理实现及转发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E6%A6%82%E8%A7%88"><span class="toc-text">2.3.1 代理方法概览</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-NSURLSessionDelegate%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.2 NSURLSessionDelegate实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#01-URLSession-didBecomeInvalidWithError"><span class="toc-text">01. URLSession:didBecomeInvalidWithError</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#02-URLSession-didReceiveChallenge"><span class="toc-text">02. URLSession:didReceiveChallenge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#03-URLSessionDidFinishEventsForBackgro"><span class="toc-text">03. URLSessionDidFinishEventsForBackgro..</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-NSURLSessionTaskDelegate%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.3 NSURLSessionTaskDelegate实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#04-URLSession-task-willPerformHTTPRedirection"><span class="toc-text">04. URLSession:task:willPerformHTTPRedirection</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#05-URLSession-task-didReceiveChallenge"><span class="toc-text">05.URLSession:task:didReceiveChallenge</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#06-URLSession-task-needNewBodyStream"><span class="toc-text">06. URLSession:task:needNewBodyStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#07-URLSession-task-didSendBodyData"><span class="toc-text">07. URLSession:task:didSendBodyData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#08-URLSession-task-didCompleteWithError"><span class="toc-text">08. URLSession:task:didCompleteWithError</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-4-NSURLSessionDataDelegate%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.4 NSURLSessionDataDelegate实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#09-URLSession-dataTask-didReceiveResponse"><span class="toc-text">09. URLSession:dataTask:didReceiveResponse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-URLSession-dataTask-didBecomeDownloadTask"><span class="toc-text">10. URLSession:dataTask:didBecomeDownloadTask</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-URLSession-dataTask-didReceiveData"><span class="toc-text">11. URLSession:dataTask:didReceiveData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-URLSession-dataTask-willCacheResponse"><span class="toc-text">12. URLSession:dataTask:willCacheResponse</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-5-NSURLSessionDownloadDelegate%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3.5 NSURLSessionDownloadDelegate实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-URLSession-downloadTask-didFinishDown%E2%80%A6"><span class="toc-text">13. URLSession:downloadTask:didFinishDown…</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-URLSession-downloadTask-didWriteData"><span class="toc-text">14. URLSession:downloadTask:didWriteData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-URLSession-downloadTask-didResumeAtOffset"><span class="toc-text">15. URLSession:downloadTask:didResumeAtOffset</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-6-%E8%BD%AC%E5%8F%91%E5%88%B0AFURLSxxMxxTaskDelegate%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">2.3.6 转发到AFURLSxxMxxTaskDelegate的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-URLSession-task-didCompleteWithError"><span class="toc-text">1. URLSession:task:didCompleteWithError</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-URLSession-dataTask-didReceiveData"><span class="toc-text">2. URLSession:dataTask:didReceiveData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-URLSession-downloadTask-didFinishDownload%E2%80%A6"><span class="toc-text">3. URLSession:downloadTask:didFinishDownload…</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-AFURLSessionTaskSwizzling%E7%B1%BB"><span class="toc-text">2.4 _AFURLSessionTaskSwizzling类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81AFURLResponseSerialization"><span class="toc-text">三、AFURLResponseSerialization</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-AFHTTPResponseSerializer"><span class="toc-text">3.1 AFHTTPResponseSerializer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-AFJSONResponseSerializer"><span class="toc-text">3.2 AFJSONResponseSerializer</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81AFSecurityPolicy"><span class="toc-text">四、AFSecurityPolicy</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-TLS%E7%9A%84%E8%BF%9E%E6%8E%A5%E8%BF%87%E7%A8%8B%E7%AE%80%E8%BF%B0"><span class="toc-text">4.1 TLS的连接过程简述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-session-didReceiveChallenge%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95"><span class="toc-text">4.2 session:didReceiveChallenge代理方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-AFSecurityPolicy%E5%86%85%E9%83%A8"><span class="toc-text">4.3 AFSecurityPolicy内部</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E4%BA%94%E4%B8%AA%E5%B1%9E%E6%80%A7"><span class="toc-text">4.3.1 五个属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-evaluateServerTrust-%E6%96%B9%E6%B3%95"><span class="toc-text">4.3.2 evaluateServerTrust:方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8F%82%E6%95%B0SecTrustRef%E4%B8%8E%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%A3%E8%AF%BB"><span class="toc-text">1. 参数SecTrustRef与源码实现解读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E4%B8%80-AFServerTrustIsValid"><span class="toc-text">2. 调用函数一: AFServerTrustIsValid</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E4%BA%8C%E3%80%81%E4%B8%89%E8%8E%B7%E5%8F%96%E8%AF%81%E4%B9%A6%E9%93%BE%E8%AF%81%E4%B9%A6%E6%88%96%E5%85%AC%E9%92%A5"><span class="toc-text">3. 调用函数二、三获取证书链证书或公钥</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E8%B0%83%E7%94%A8%E5%87%BD%E6%95%B0%E5%9B%9B-%E5%88%A4%E6%96%AD%E5%85%AC%E9%92%A5%E6%98%AF%E5%90%A6%E7%9B%B8%E5%90%8C"><span class="toc-text">4. 调用函数四: 判断公钥是否相同</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E9%AA%8C%E8%AF%81%E8%BF%87%E7%A8%8B%E4%B8%AD%E8%B0%83%E7%94%A8%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%94%9F%E5%87%BD%E6%95%B0"><span class="toc-text">5. 验证过程中调用的系统原生函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E5%85%B3%E4%BA%8EHTTPS-%E5%BC%80%E5%8F%91%E8%80%85%E9%9C%80%E8%A6%81%E5%81%9A%E4%BB%80%E4%B9%88"><span class="toc-text">4.4 关于HTTPS, 开发者需要做什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E5%A6%82%E6%9E%9C%E5%8F%AA%E6%83%B3%E8%AE%BF%E9%97%AE%E8%83%BD%E9%80%9A"><span class="toc-text">4.4.1 如果只想访问能通</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%A6%82%E6%9E%9C%E6%83%B3%E9%AA%8C%E8%AF%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9D%A5%E6%BA%90"><span class="toc-text">4.4.2 如果想验证服务器来源</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E6%80%BB%E7%BB%93-AF%E4%B9%8B%E4%BA%8Ehttps%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88"><span class="toc-text">4.5 总结: AF之于https到底做了什么</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81UIKit%E6%89%A9%E5%B1%95%E4%B8%8E%E7%BC%93%E5%AD%98%E5%AE%9E%E7%8E%B0"><span class="toc-text">五、UIKit扩展与缓存实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-AFNetworkActivityIndicatorManager"><span class="toc-text">5.1 AFNetworkActivityIndicatorManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">5.1.1 初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E9%80%9A%E7%9F%A5%E8%A7%A6%E5%8F%91%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">5.1.2 通知触发调用的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E9%87%8D%E5%86%99currentState%E7%9A%84setter"><span class="toc-text">5.1.3 重写currentState的setter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-UIImageView-AFNetworking"><span class="toc-text">5.2 UIImageView+AFNetworking</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-AFImageDownloader"><span class="toc-text">5.2.1 AFImageDownloader</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%85%88%E7%9C%8B%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">1. 先看初始化方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%86%8D%E7%9C%8B%E5%88%9B%E5%BB%BA%E8%AF%B7%E6%B1%82task%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text">2. 再看创建请求task的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%A4%E6%96%ADurl%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA"><span class="toc-text">1) 判断url是否为空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%B7%B2%E7%94%9F%E6%88%90task"><span class="toc-text">2) 判断是否是已生成task</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-1-AFImageDownloaderResponseHandler"><span class="toc-text">2-1) AFImageDownloaderResponseHandler</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-2-AFImageDownloaderMergedTask"><span class="toc-text">2-2) AFImageDownloaderMergedTask</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%E7%BC%93%E5%AD%98%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8"><span class="toc-text">3. 判断缓存是否存在</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%9B%E5%BB%BANSURLSessionDataTask%E5%B9%B6%E8%AE%BE%E7%BD%AE%E5%AE%8C%E6%88%90%E5%9B%9E%E8%B0%83"><span class="toc-text">4. 创建NSURLSessionDataTask并设置完成回调</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BAResponseHandler%E5%92%8CMergedTask"><span class="toc-text">5. 创建ResponseHandler和MergedTask</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E5%88%A4%E6%96%AD%E5%BD%93%E5%89%8D%E5%B9%B6%E8%A1%8C%E6%95%B0%E6%98%AF%E5%90%A6%E8%B6%85%E9%99%90"><span class="toc-text">6. 判断当前并行数是否超限</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E5%88%9B%E5%BB%BAAFImageDownloadReceipt"><span class="toc-text">7. 创建AFImageDownloadReceipt</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8F%96%E6%B6%88task"><span class="toc-text">3. 取消task</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-AFAutoPurgingImageCache"><span class="toc-text">5.2.2 AFAutoPurgingImageCache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8B%E6%96%87%E8%A6%81%E7%94%A8%E5%88%B0%E7%9A%84AFCachedImage"><span class="toc-text">1. 下文要用到的AFCachedImage</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">2. 初始化方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95addImage"><span class="toc-text">3. 核心方法addImage:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%85%B6%E4%BB%96%E5%87%A0%E4%B8%AA%E6%96%B9%E6%B3%95"><span class="toc-text">4. 其他几个方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-UIImageView-AFNetworking"><span class="toc-text">5.2.3 UIImageView+AFNetworking</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-setImageWithURL"><span class="toc-text">1. setImageWithURL:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-setImageWithURLRequest"><span class="toc-text">2. setImageWithURLRequest:</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%A4%E6%96%ADurl%E6%98%AF%E5%90%A6%E4%B8%BA%E7%A9%BA-1"><span class="toc-text">1) 判断url是否为空</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%81%9A%E4%BA%86%E4%B8%80%E7%B3%BB%E5%88%97%E5%88%A4%E6%96%AD%EF%BC%8C%E8%A7%81%E6%B3%A8%E9%87%8A"><span class="toc-text">2) 做了一系列判断，见注释</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%88%9B%E5%BB%BAAFImageDownloader%E5%B9%B6%E5%88%A4%E6%96%AD%E7%BC%93%E5%AD%98"><span class="toc-text">3) 创建AFImageDownloader并判断缓存</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E8%AF%B7%E6%B1%82%E5%9B%BE%E7%89%87"><span class="toc-text">4) 请求图片</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-cancelImageDownloadTask"><span class="toc-text">3. cancelImageDownloadTask</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4-%E6%80%BB%E7%BB%93"><span class="toc-text">5.2.4 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81AF2-x%E4%B8%8EAF3-x"><span class="toc-text">六、AF2.x与AF3.x</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84"><span class="toc-text">6.1 源码结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-AFHTTPRequestOperationManager"><span class="toc-text">6.2 AFHTTPRequestOperationManager</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">6.2.1 初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-2-get%E6%96%B9%E6%B3%95%E5%8F%8AAFHTTPRequestOperation%E5%88%9B%E5%BB%BA"><span class="toc-text">6.2.2 get方法及AFHTTPRequestOperation创建</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-AFURLConnectionOperation"><span class="toc-text">6.3 AFURLConnectionOperation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">6.3.1 初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-2-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%9E%E6%80%A7"><span class="toc-text">6.3.2 成员变量和属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%B1%9E%E6%80%A7state%E5%92%8C%E9%87%8D%E5%86%99setter"><span class="toc-text">1. 属性state和重写setter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%87%8D%E5%86%99%E7%88%B6%E7%B1%BBNSOperation%E7%9A%84%E5%B1%9E%E6%80%A7getter"><span class="toc-text">2. 重写父类NSOperation的属性getter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B1%9E%E6%80%A7lock"><span class="toc-text">3. 属性lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%B1%9E%E6%80%A7runLoopModes"><span class="toc-text">4. 属性runLoopModes</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E5%B1%9E%E6%80%A7securityPolicy"><span class="toc-text">5. 属性securityPolicy</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-3-%E5%A4%8D%E5%86%99operation%E7%9A%84start%E6%96%B9%E6%B3%95"><span class="toc-text">6.3.3 复写operation的start方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-text">1. 源码实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%80%E8%BE%9F%E6%96%B0%E7%BA%BF%E7%A8%8B"><span class="toc-text">2. 开辟新线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-start%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B"><span class="toc-text">3. start调用流程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BANSURLConnection"><span class="toc-text">1) 创建NSURLConnection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-outputStream%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8F%8A%E6%B3%A8%E5%86%8C"><span class="toc-text">2) outputStream的创建及注册</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8Cconnection"><span class="toc-text">3) 开始执行connection</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%88%B0%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%8F%91%E9%80%81%E4%BB%BB%E5%8A%A1%E5%BC%80%E5%A7%8B%E6%89%A7%E8%A1%8C%E7%9A%84%E9%80%9A%E7%9F%A5"><span class="toc-text">4) 到主线程发送任务开始执行的通知</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-4-%E5%AE%9E%E7%8E%B0NSURLConnectionDelegate"><span class="toc-text">6.3.4 实现NSURLConnectionDelegate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-connection-didReceiveResponse"><span class="toc-text">1. connection:didReceiveResponse</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-connection-didReceiveData"><span class="toc-text">2. connection:didReceiveData</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-connectionDidFinishLoading"><span class="toc-text">3. connectionDidFinishLoading</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-connection-didFailWithError"><span class="toc-text">4. connection:didFailWithError</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-4-AFHTTPRequestOperation"><span class="toc-text">6.4 AFHTTPRequestOperation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95"><span class="toc-text">6.4.1 初始化方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-2-%E8%AE%BE%E7%BD%AEcompletionBlock"><span class="toc-text">6.4.2 设置completionBlock</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-4-3-%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-text">6.4.3 数据解析的调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-5-ResponseSerializer%E4%B8%8ESecurityPolicy"><span class="toc-text">6.5 ResponseSerializer与SecurityPolicy</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-6-%E6%80%BB%E7%BB%93"><span class="toc-text">6.6 总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-7-%E9%81%97%E7%95%99%E9%97%AE%E9%A2%98%EF%BC%9A%E4%B8%80%E6%9D%A1%E5%B8%B8%E9%A9%BB%E7%BA%BF%E7%A8%8B"><span class="toc-text">6.7 遗留问题：一条常驻线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E6%80%BB%E7%BB%93AFNetworking%E5%88%B0%E5%BA%95%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">七、总结AFNetworking到底做了什么？</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    
    
    
    
        <span class="sidebar-category-name" data-categories="数据结构与算法"><span class="iconfont-archer">&#xe60a;</span>数据结构与算法</span>
    
        <span class="sidebar-category-name" data-categories="计算机组成原理"><span class="iconfont-archer">&#xe60a;</span>计算机组成原理</span>
    
        <span class="sidebar-category-name" data-categories="计算机网络"><span class="iconfont-archer">&#xe60a;</span>计算机网络</span>
    
        <span class="sidebar-category-name" data-categories="汇编语言"><span class="iconfont-archer">&#xe60a;</span>汇编语言</span>
    
        <span class="sidebar-category-name" data-categories="数据的存储与传输"><span class="iconfont-archer">&#xe60a;</span>数据的存储与传输</span>
    
        <span class="sidebar-category-name" data-categories="操作系统"><span class="iconfont-archer">&#xe60a;</span>操作系统</span>
    
        <span class="sidebar-category-name" data-categories="互联网标准RFC"><span class="iconfont-archer">&#xe60a;</span>互联网标准RFC</span>
    
        <span class="sidebar-category-name" data-categories="编译链接与装载"><span class="iconfont-archer">&#xe60a;</span>编译链接与装载</span>
    
        <span class="sidebar-category-name" data-categories="iOS"><span class="iconfont-archer">&#xe60a;</span>iOS</span>
    
        <span class="sidebar-category-name" data-categories="架构与设计模式"><span class="iconfont-archer">&#xe60a;</span>架构与设计模式</span>
    
        <span class="sidebar-category-name" data-categories="图形处理与渲染"><span class="iconfont-archer">&#xe60a;</span>图形处理与渲染</span>
    
        <span class="sidebar-category-name" data-categories="软件工程"><span class="iconfont-archer">&#xe60a;</span>软件工程</span>
    
        <span class="sidebar-category-name" data-categories="音视频处理"><span class="iconfont-archer">&#xe60a;</span>音视频处理</span>
    
        <span class="sidebar-category-name" data-categories="DSL"><span class="iconfont-archer">&#xe60a;</span>DSL</span>
    
        <span class="sidebar-category-name" data-categories="Swift"><span class="iconfont-archer">&#xe60a;</span>Swift</span>
    
        <span class="sidebar-category-name" data-categories="Git"><span class="iconfont-archer">&#xe60a;</span>Git</span>
    
        <span class="sidebar-category-name" data-categories="Web"><span class="iconfont-archer">&#xe60a;</span>Web</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 75
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-side-search"> 
                <span class="iconfont-jian search-icon">&#xe7fc;搜索</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2022 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span><a class="archive-post-title" href= "/2022/05/05/sqlite.html" >iOS SQLite的使用与优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href= "/2022/04/28/mmap.html" >内存映射mmap函数的原理与应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/18</span><a class="archive-post-title" href= "/2022/03/18/avfoundation.html" >AVFoundation Programming Guide(译)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span><a class="archive-post-title" href= "/2022/03/17/avframework.html" >iOS音视频库概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2022/02/09/OAuth.html" >[转] OAuth 2.0简述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/18</span><a class="archive-post-title" href= "/2022/01/18/wkwebview-buges.html" >WKWebView使用过程中遇到的坑</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/22</span><a class="archive-post-title" href= "/2021/11/22/bit-calculation.html" >[转] 位运算实现加、减、乘、除运算</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span><a class="archive-post-title" href= "/2021/11/10/git-use.html" >Git的使用总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/21</span><a class="archive-post-title" href= "/2021/10/21/dyld-objc.html" >(六) dyld与Runtime—_objc_init、map_images、load_images</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/18</span><a class="archive-post-title" href= "/2021/10/18/compile-dynamic-link.html" >(五) Mach-O 文件的动态链接、库、Dyld(含dlopen)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span><a class="archive-post-title" href= "/2021/10/10/compile-load.html" >(四) Mach-O 文件的装载、ASLR及符号地址</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/08</span><a class="archive-post-title" href= "/2021/10/08/compile-static-link.html" >(三) Mach-O 文件的静态链接</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/06</span><a class="archive-post-title" href= "/2021/10/06/compile-macho.html" >(二) Mach-O 文件结构</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2021/10/05/compile-clang-llvm.html" >(一) Clang/LLVM 介绍、OC 程序的编译过程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/02</span><a class="archive-post-title" href= "/2021/10/02/makefile.html" >[转] Make 命令的使用与NodeJS案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/2021/09/28/architectural-pattern.html" >常见架构模式: MVC、MVP、MVVM、VIPER</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href= "/2021/09/25/design-pattern.html" >常见的设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href= "/2021/09/20/program-thought.html" >常见的编程范式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing-case.html" >图形处理(三) - 图形处理实践案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing.html" >图形处理(二) - 图形与视频处理相关的框架</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2021/09/13/image-encode-decode.html" >图形处理(一) - 图片的加载与编解码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/12</span><a class="archive-post-title" href= "/2021/09/12/iOS-Render.html" >[转] iOS离屏渲染原理及优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2021/09/11/core-animation03.html" >Core-Animation(三) - 渲染流程探究及性能分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/09</span><a class="archive-post-title" href= "/2021/09/09/core-animation02.html" >Core Animation(二) - 隐式动画、CATransaction与CAAction</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/07</span><a class="archive-post-title" href= "/2021/09/07/core-animation01.html" >Core Animation(一) - UIView与CALayer、布局与绘制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span><a class="archive-post-title" href= "/2021/09/05/AFN-Analyse.html" >[转] AFN框架实现解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/04</span><a class="archive-post-title" href= "/2021/09/04/nrl-session.html" >NSURLSession概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2021/09/02/Log.html" >移动端日志库设计</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href= "/2021/08/01/Crash-Monitor.html" >iOS崩溃监控与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2021/07/30/Lag-Monitor.html" >iOS卡顿监控与堆栈获取</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/SwiftUI.html" >SwiftUI</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/Swift-Version-History.html" >Swift版本更新API介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/26</span><a class="archive-post-title" href= "/2021/07/26/RunLoop-Reposted-From-ibireme.html" >[转] 深入理解RunLoop—ibireme</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2021/07/25/Protocol-Buffer.html" >Protocol Buffer的基本介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href= "/2021/07/24/base64.html" >Base64编码及iOS中的Base64</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span><a class="archive-post-title" href= "/2021/07/23/chinese-encode.html" >[转] 彻底弄懂常见的7种中文字符编码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/10</span><a class="archive-post-title" href= "/2021/07/10/p-npc-np.html" >P问题、NP问题、NPC、NP-Hard、P=NP?</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href= "/2021/06/30/probability.html" >(六) 概率算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/28</span><a class="archive-post-title" href= "/2021/06/28/branch-bound.html" >(五) 分支限界算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/26</span><a class="archive-post-title" href= "/2021/06/26/back-track.html" >(四) 回溯法(试探算法)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/24</span><a class="archive-post-title" href= "/2021/06/24/greed.html" >(三) 贪心算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/22</span><a class="archive-post-title" href= "/2021/06/22/dynamic-programming.html" >(二) 动态规划算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href= "/2021/06/20/divide-and-conquer.html" >(一) 分治算法及减治、变治算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span><a class="archive-post-title" href= "/2021/06/18/several-programming.html" >穷举、递推、迭代(辗转法)、递归算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/15</span><a class="archive-post-title" href= "/2021/06/15/datastruction-overview.html" >数据结构与算法概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/06</span><a class="archive-post-title" href= "/2021/06/06/Web-Module.html" >前端各种模块化方案总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Fiber.html" >[转] 最通俗的 React Fiber(时间分片)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Coroutine.html" >[转] 什么是协程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href= "/2021/05/19/DSL.html" >[转] 谈谈DSL以及DSL的应用（以CocoaPods 为例）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href= "/2021/05/03/iOS-private-pod.html" >私有Pod库部署</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/29</span><a class="archive-post-title" href= "/2021/04/29/iOS-ComRouter.html" >[转] iOS的组件化方案</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/27</span><a class="archive-post-title" href= "/2021/04/27/iOS-CI.html" >iOS的持续集成</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/26</span><a class="archive-post-title" href= "/2021/04/26/Containers.html" >常见的容器概念：Linux容器、Docker容器、服务器容器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span><a class="archive-post-title" href= "/2021/04/24/Dock-Reprinted-from-RuanYIFeng.html" >[转] Docker入门教程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span><a class="archive-post-title" href= "/2021/04/20/Sync-Async.html" >同步和异步解读及编程中的使用场景</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span><a class="archive-post-title" href= "/2021/04/17/Arm64-Handbook.html" >ARM64指令简易手册</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span><a class="archive-post-title" href= "/2021/04/16/Arm64-Introduce.html" >iOS需要了解的ARM64汇编</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span><a class="archive-post-title" href= "/2021/04/13/Command-Line.html" >CLI Shell、Terminal、脚本(语言)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href= "/2021/04/10/Ins-SysCall-Kernel-Shell.html" >指令、系统调用、库、Shell、APP的层次关系</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span><a class="archive-post-title" href= "/2021/04/08/ISA-Microarch-Soc.html" >指令集、微架构、手机芯片(Soc)及ARM的介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span><a class="archive-post-title" href= "/2021/04/02/Engineering.html" >工程化、动态化、容器化、组件化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2021/04/01/GithubPages-Hexo.html" >使用Hexo+Github Pages搭建个人博客</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/22</span><a class="archive-post-title" href= "/2020/12/22/aes.html" >数据加密 — 对称加密(以AES为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href= "/2020/12/21/aes-standard.html" >[转] AES标准及Rijndael算法解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span><a class="archive-post-title" href= "/2020/12/20/asymmetric.html" >数据加密 — 非对称加密(加签/加密，以RSA为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/09</span><a class="archive-post-title" href= "/2020/12/09/pki.html" >常见的PKI标准(X.509、PKCS)及证书相关介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href= "/2020/10/28/runtime-data-structure.html" >Objc Runtime总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2020/09/11/GCD.html" >Objective-C — 深入浅出GCD常用API</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/06</span><a class="archive-post-title" href= "/2020/09/06/oc-block.html" >Objective-C — Block</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/26</span><a class="archive-post-title" href= "/2020/08/26/AutoreleasePool.html" >AutoreleasePool</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/24</span><a class="archive-post-title" href= "/2020/08/24/oc-memory-manage.html" >Objective-C — 内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href= "/2020/08/01/ui-navigation-bar.html" >[转] 导航栏的架构介绍及使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/15</span><a class="archive-post-title" href= "/2020/07/15/symbol-decl.html" >变量声明、函数声明的作用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2020/07/01/ios-apns.html" >iOS APNS接收逻辑梳理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/2020/06/13/ios-vest.html" >iOS制作马甲总结</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="AutoreleasePool"><span class="iconfont-archer">&#xe606;</span>AutoreleasePool</span>
    
        <span class="sidebar-tag-name" data-tags="hexo"><span class="iconfont-archer">&#xe606;</span>hexo</span>
    
        <span class="sidebar-tag-name" data-tags="GCD"><span class="iconfont-archer">&#xe606;</span>GCD</span>
    
        <span class="sidebar-tag-name" data-tags="ISA"><span class="iconfont-archer">&#xe606;</span>ISA</span>
    
        <span class="sidebar-tag-name" data-tags="Microarch"><span class="iconfont-archer">&#xe606;</span>Microarch</span>
    
        <span class="sidebar-tag-name" data-tags="Soc"><span class="iconfont-archer">&#xe606;</span>Soc</span>
    
        <span class="sidebar-tag-name" data-tags="CLI"><span class="iconfont-archer">&#xe606;</span>CLI</span>
    
        <span class="sidebar-tag-name" data-tags="Shell"><span class="iconfont-archer">&#xe606;</span>Shell</span>
    
        <span class="sidebar-tag-name" data-tags="ARM64"><span class="iconfont-archer">&#xe606;</span>ARM64</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="Docker"><span class="iconfont-archer">&#xe606;</span>Docker</span>
    
        <span class="sidebar-tag-name" data-tags="DSL"><span class="iconfont-archer">&#xe606;</span>DSL</span>
    
        <span class="sidebar-tag-name" data-tags="协程"><span class="iconfont-archer">&#xe606;</span>协程</span>
    
        <span class="sidebar-tag-name" data-tags="Fiber"><span class="iconfont-archer">&#xe606;</span>Fiber</span>
    
        <span class="sidebar-tag-name" data-tags="dp"><span class="iconfont-archer">&#xe606;</span>dp</span>
    
        <span class="sidebar-tag-name" data-tags="RunLoop"><span class="iconfont-archer">&#xe606;</span>RunLoop</span>
    
        <span class="sidebar-tag-name" data-tags="SwiftUI"><span class="iconfont-archer">&#xe606;</span>SwiftUI</span>
    
        <span class="sidebar-tag-name" data-tags="CrashMonitor"><span class="iconfont-archer">&#xe606;</span>CrashMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="Swift-Syntax"><span class="iconfont-archer">&#xe606;</span>Swift-Syntax</span>
    
        <span class="sidebar-tag-name" data-tags="Log"><span class="iconfont-archer">&#xe606;</span>Log</span>
    
        <span class="sidebar-tag-name" data-tags="LagMonitor"><span class="iconfont-archer">&#xe606;</span>LagMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="AFN"><span class="iconfont-archer">&#xe606;</span>AFN</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Tenloy"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


