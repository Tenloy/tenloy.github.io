<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Tenloy">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Tenloy">
    
    <meta name="keywords" content="Tenloy,iOS,Swift">
    
    <meta name="description" content="学习 生活 记录 回忆">
    <meta name="description" content="AVFoundation概述 译文，原文链接：AVFoundation Programming Guide.（不完全一致。内容结构有调整，增加了一些类的定义源码）  AVFoundation 是一个媒体框架，它提供的接口：  可以精确地处理基于时间的音视频媒体数据，比如媒体文件的查找、创建、编辑、二次编码。 可以从设备获取输入流并在实时捕获和播放期间操作视频。  iOS 上的架构：    OS X">
<meta property="og:type" content="article">
<meta property="og:title" content="AVFoundation Programming Guide(译)">
<meta property="og:url" content="https://tenloy.github.io/2022/03/18/avfoundation.html">
<meta property="og:site_name" content="Tenloy&#39;s Blog">
<meta property="og:description" content="AVFoundation概述 译文，原文链接：AVFoundation Programming Guide.（不完全一致。内容结构有调整，增加了一些类的定义源码）  AVFoundation 是一个媒体框架，它提供的接口：  可以精确地处理基于时间的音视频媒体数据，比如媒体文件的查找、创建、编辑、二次编码。 可以从设备获取输入流并在实时捕获和播放期间操作视频。  iOS 上的架构：    OS X">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tenloy.github.io/images/avf/frameworksBlockDiagram_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/frameworksBlockDiagramOSX_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/avassetHierarchy_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/avassetAndTracks_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/export_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/avplayerLayer_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/playerObjects_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/avmutablecomposition_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/avmutableaudiomix_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/avmutablevideocomposition_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/puttingitalltogether_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/captureOverview_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/captureDetail_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/cameras_2x.png">
<meta property="og:image" content="https://tenloy.github.io/images/avf/avmetadataItem.jpg">
<meta property="article:published_time" content="2022-03-18T16:54:19.000Z">
<meta property="article:modified_time" content="2022-06-02T09:59:42.736Z">
<meta property="article:author" content="Tenloy">
<meta property="article:tag" content="Tenloy, iOS, Tenloy Blog, 博客，Swift, 编译, 计算机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tenloy.github.io/images/avf/frameworksBlockDiagram_2x.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>AVFoundation Programming Guide(译) · Tenloy&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"Search for Posts","hits_empty":"没有找到任何搜索结果: ${query}","hits_stats":"找到约${hits}条结果（用时${time}ms）"}')

            var algolia = {
                applicationID: 'V0HYXBS9FB',
                apiKey: '6550d5de786935564142097c3e78c380',
                indexName: 'law_blog_index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Tenloy's Blog" type="application/atom+xml">
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Tenloy&#39;s Blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">AVFoundation Programming Guide(译)</a>
            </div>
    </div>
    
    <!-- 将home-link的操作改为应用到header-top-right上 -->
    <div class="header-top-right">
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-search">
                <span class="iconfont-jian tl-search-icon">&#xe7fc;搜索</span>
            </div>
            
        <a class="home-link" href=/>Tenloy's Blog</a>
    </div>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:40vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            AVFoundation Programming Guide(译)
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">29.5k</span>Reading time: <span class="post-count reading-time">131 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2022/03/18</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="AVFoundation概述"><a href="#AVFoundation概述" class="headerlink" title="AVFoundation概述"></a>AVFoundation概述</h1><blockquote>
<p>译文，原文链接：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/AudioVideo/Conceptual/AVFoundationPG/RevisionHistory.html#//apple_ref/doc/uid/TP40010188-CH99-SW1">AVFoundation Programming Guide</a>.（不完全一致。内容结构有调整，增加了一些类的定义源码）</p>
</blockquote>
<p>AVFoundation 是一个媒体框架，它提供的接口：</p>
<ul>
<li>可以精确地处理基于时间的音视频媒体数据，比如媒体文件的查找、创建、编辑、二次编码。</li>
<li>可以从设备获取输入流并在实时捕获和播放期间操作视频。</li>
</ul>
<p>iOS 上的架构：</p>
<img src="/images/avf/frameworksBlockDiagram_2x.png" alt="img" style="zoom:70%;" />

<p> OS X 上相应的媒体架构：</p>
<img src="/images/avf/frameworksBlockDiagramOSX_2x.png" alt="img" style="zoom:70%;" />

<p>AVFoundation 框架包含视频API 和音频API 两方面。较早的与音频相关的类提供了处理音频的简单方法：</p>
<ul>
<li>播放声音文件，可以使用 AVAudioPlayer。</li>
<li>录制音频，可以使用 AVAudioRecorder。</li>
<li>使用 AVAudioSession 配置应用程序的音频行为。</li>
</ul>
<p>在完成具体的开发任务时，你应该尽可能的选择更高层次的抽象框架。</p>
<ul>
<li>如果只需要播放视频，可以使用 AVKit 框架</li>
<li>如果需要在 iOS 设备上录制视频，而且并不关心更具体的录制参数，可以使用 UIKit 中 UIImagePickerController 类。</li>
</ul>
<p>需要注意的是，在 AVFoundation 框架中使用的一些原始数据结构 (包括时间相关的数据结构和存储描述媒体数据的底层对象)，都在 Core Media 框架中声明。</p>
<h1 id="一、使用Assets"><a href="#一、使用Assets" class="headerlink" title="一、使用Assets"></a>一、使用Assets</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>Asset 资产;财产;有价值的人(或事物);有用的人(或事物);</p>
<ul>
<li><p>现实中，更多的指资产、财产</p>
</li>
<li><p>编程中，可以理解为资源，图像、音频、视频等，与resource相近(Android中两者所表示的文件在编译处理上大有不同，不展开讲了)。以下出现的资产、资源都是指asset的中文翻译</p>
</li>
</ul>
</blockquote>
<p>AVFoundation 框架中表示媒体的主要类 — AVAsset。 <code>AVAsset</code> 表示基于时间的视听数据，比如电影文件或视频流。<code>AVAsset</code> 的结构决定了 AV Foundation 框架大部分的工作方式。</p>
<ul>
<li>AVAsset 实例是一个或多个媒体数据（音频和视频轨道）的集合的聚合表示。它提供有关整个集合的信息，例如其标题、持续时间、自然呈现大小等。<ul>
<li>AVAsset也可能有元数据</li>
</ul>
</li>
<li>AVAsset 是一个抽象类，可以使用它的子类来：<ul>
<li>从 URL 创建一个 asset 对象</li>
<li>根据已有的媒体资源合成出一个新的媒体资源。</li>
</ul>
</li>
<li>AVAsset 不依赖于特定的数据格式。</li>
<li>AVAsset 中的每条独立的媒体数据都有一个统一类的型，称为轨道(track)。<ul>
<li>在一个典型的简单情况下，一个轨道代表音频分量，另一个轨道代表视频分量；</li>
<li>然而，在复杂的合成中，可能有多个重叠的音频和视频轨道。</li>
</ul>
</li>
</ul>
<p>拥有一个电影资产后，可以从中提取静止图像、将其转码为另一种格式或修剪内容。</p>
<h2 id="1-1-资产与轨道-AVAsset与AVAssetTrack"><a href="#1-1-资产与轨道-AVAsset与AVAssetTrack" class="headerlink" title="1.1 资产与轨道(AVAsset与AVAssetTrack)"></a>1.1 资产与轨道(AVAsset与AVAssetTrack)</h2><h3 id="1-1-1-AVAsset类结构"><a href="#1-1-1-AVAsset类结构" class="headerlink" title="1.1.1 AVAsset类结构"></a>1.1.1 AVAsset类结构</h3><p>AVAsset 是 AV Foundation 框架的核心关键类，它提供了对视听数据(如电影、视频流)的<strong>格式无关的抽象</strong>。</p>
<p>类之间的关系如下图所示。大部分情况下，使用的都是这些类的子类：</p>
<ul>
<li>使用 AVComposition 子类创建新的 asset</li>
<li>使用 AVURLAsset 子类根据一个指定的 URL（包括来自MPMedia、AssetLibrary框架的asset(iPod库/相册)）创建 asset</li>
</ul>
<img src="/images/avf/avassetHierarchy_2x.png" alt="img" style="zoom:70%;" />

<p>一个 asset 包含：</p>
<ul>
<li>一组 track，每个 track 都有特定媒体类型，包括但不限于 audio，video，text，closed captions 以及 subtitles。</li>
<li>整个资源的信息，比如时长和标题。</li>
<li>Asset 对象也可能包含元数据 (metadata)，metadata 由 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/avfoundation/avmetadataitem">AVMetadataItem</a> 类表示。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">AVAsynchronousKeyValueLoading</span>&gt;</span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWithURL:(<span class="built_in">NSURL</span> *)URL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> duration;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> preferredRate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> preferredVolume;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGAffineTransform</span> preferredTransform;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> naturalSize API_DEPRECATED(<span class="string">&quot;Use the naturalSize and preferredTransform, as appropriate, of the receiver&#x27;s video tracks. See -tracksWithMediaType:&quot;</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVDisplayCriteria</span> *preferredDisplayCriteria;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> minimumTimeOffsetFromLive;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 异步加载 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetAsynchronousLoading</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> providesPreciseDurationAndTiming;</span><br><span class="line">- (<span class="keyword">void</span>)cancelLoading;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 引用限制 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetReferenceRestrictions</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetReferenceRestrictions</span> referenceRestrictions;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* track检查 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetTrackInspection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *tracks;</span><br><span class="line">- (<span class="built_in">AVAssetTrack</span> *)trackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID;</span><br><span class="line">- (<span class="keyword">void</span>)loadTrackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAssetTrack</span> *_result, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)tracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)tracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrackGroup</span> *&gt; *trackGroups;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元数据读取 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetMetadataReading</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMetadataItem</span> *creationDate;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *lyrics;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *commonMetadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataFormat</span>&gt; *availableMetadataFormats;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *)metadataForFormat:(<span class="built_in">AVMetadataFormat</span>)format;</span><br><span class="line">- (<span class="keyword">void</span>)loadMetadataForFormat:(<span class="built_in">AVMetadataFormat</span>)format completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 章节检查 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetChapterInspection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSLocale</span> *&gt; *availableChapterLocales;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *)chapterMetadataGroupsWithTitleLocale:(<span class="built_in">NSLocale</span> *)locale containingItemsWithCommonKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataKey</span>&gt; *)commonKeys;</span><br><span class="line">- (<span class="keyword">void</span>)loadChapterMetadataGroupsWithTitleLocale:(<span class="built_in">NSLocale</span> *)locale containingItemsWithCommonKeys:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataKey</span>&gt; *)commonKeys completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *)chapterMetadataGroupsBestMatchingPreferredLanguages:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)preferredLanguages;</span><br><span class="line">- (<span class="keyword">void</span>)loadChapterMetadataGroupsBestMatchingPreferredLanguages:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)preferredLanguages completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVTimedMetadataGroup</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 媒体 选择 选项 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetMediaSelection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMediaCharacteristic</span>&gt; *availableMediaCharacteristicsWithMediaSelectionOptions;</span><br><span class="line">- (<span class="built_in">AVMediaSelectionGroup</span> *)mediaSelectionGroupForMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line">- (<span class="keyword">void</span>)loadMediaSelectionGroupForMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVMediaSelectionGroup</span> *_result, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaSelection</span> *preferredMediaSelection;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> &lt;<span class="built_in">AVMediaSelection</span> *&gt; *allMediaSelections;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetProtectedContent</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> hasProtectedContent;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetFragments</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> canContainFragments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> containsFragments;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> overallDurationHint;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAsset</span> (<span class="title">AVAssetUsability</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> playable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> exportable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> readable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> composable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> compatibleWithSavedPhotosAlbum;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> compatibleWithAirPlayVideo;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="1-1-2-轨道-Track"><a href="#1-1-2-轨道-Track" class="headerlink" title="1.1.2 轨道(Track)"></a>1.1.2 轨道(Track)</h3><p>如下图所示，一个 track 由 AVAssetTrack 类表示。简单场景下，一个 track 代表 audio component，另一个 track 代表 video component；复杂场景下，可能有多个 audio 和 video 重叠的 track。</p>
<img src="/images/avf/avassetAndTracks_2x.png" alt="img" style="zoom:70%;" />

<p>一个 track 包含多个属性：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/* 包含此轨道的asset对象  */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">weak</span>) <span class="built_in">AVAsset</span> *asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基本性质和特点 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackBasicPropertiesAndCharacteristics</span>)</span></span><br><span class="line"><span class="comment">// 类型 (video or audio)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="comment">// track 包含一个描述格式的数组。这个数组中的元素为 CMFormatDescription 对象，用来描述 track 包含的媒体的格式信息。</span></span><br><span class="line">  <span class="comment">// track通常呈现统一的媒体（例如，使用相同编码设置编码的媒体），此时是包含单一格式的描述。</span></span><br><span class="line">  <span class="comment">// 但是，在某些情况下，track可能包含多种格式描述。例如，一个 H.264 编码的视频轨道可能有一些片段使用 Main profile 编码，而其他片段使用 High profile 编码。</span></span><br><span class="line">  <span class="comment">// 此外，作为 AVAssetTrack 的子类的单个 AVCompositionTrack 可能包含使用不同编解码器的音频或视频片段。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span> *formatDescriptions;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> playable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> decodable;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> selfContained;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">long</span> <span class="keyword">long</span> totalSampleDataLength;</span><br><span class="line">- (<span class="built_in">BOOL</span>)hasMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 时间属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackTemporalProperties</span>)</span></span><br><span class="line"><span class="comment">//该轨道在assett整体时间线内的时间范围</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTimeRange</span> timeRange;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 语言属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackLanguageProperties</span>) </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 视觉特征的属性.如画面大小 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackPropertiesForVisualCharacteristic</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">/* 听觉特性的属性.如音量大小 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackPropertiesForAudibleCharacteristic</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 基于帧特性的属性 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackPropertiesForFrameBasedCharacteristic</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 片段。一个 track 可能被分为几段，每一段由一个 AVAssetTrackSegment 对象表示，该对象就是一个由资源数据到 track 时间轴的映射。 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackSegments</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元数据读取 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackMetadataReading</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* track的关联 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackTrackAssociations</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 样本光标 AVSampleCursor实例 */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetTrack</span> (<span class="title">AVAssetTrackSampleCursorProvision</span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="1-2-创建AVURLAsset"><a href="#1-2-创建AVURLAsset" class="headerlink" title="1.2 创建AVURLAsset"></a>1.2 创建AVURLAsset</h2><h3 id="1-2-1-类源码"><a href="#1-2-1-类源码" class="headerlink" title="1.2.1 类源码"></a>1.2.1 类源码</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> : <span class="title">AVAsset</span></span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVFileType</span>&gt; *)audiovisualTypes;</span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)audiovisualMIMETypes;</span><br><span class="line">+ (<span class="built_in">BOOL</span>)isPlayableExtendedMIMEType: (<span class="built_in">NSString</span> *)extendedMIMEType;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)URLAssetWithURL:(<span class="built_in">NSURL</span> *)URL options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)options;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)URL options:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)options <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *URL;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVURLAssetURLHandling</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetResourceLoader</span> *resourceLoader;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVURLAssetCache</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetCache</span> *assetCache;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVAssetCompositionUtility</span> )</span></span><br><span class="line">- (<span class="built_in">AVAssetTrack</span> *)compatibleTrackForCompositionTrack:(<span class="built_in">AVCompositionTrack</span> *)compositionTrack;</span><br><span class="line">- (<span class="keyword">void</span>)findCompatibleTrackForCompositionTrack:(<span class="built_in">AVCompositionTrack</span> *)compositionTrack completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAssetTrack</span> *_result, <span class="built_in">NSError</span> *))completionHandler API_AVAILABLE(macos(<span class="number">12.0</span>), ios(<span class="number">15.0</span>), tvos(<span class="number">15.0</span>), watchos(<span class="number">8.0</span>));</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVURLAsset</span> (<span class="title">AVAssetVariantInspection</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetVariant</span> *&gt; *variants;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-创建一个AVURLAsset对象"><a href="#1-2-2-创建一个AVURLAsset对象" class="headerlink" title="1.2.2 创建一个AVURLAsset对象"></a>1.2.2 创建一个AVURLAsset对象</h3><p>AVURLAsset代表任何一个能用URL识别的资源的asset。最简单的是从一个file创建asset。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = &lt;#<span class="string">&quot;标识视听资产（如电影文件）的URL&quot;</span>#&gt;;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *anAsset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:url options:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<p>初始化的第二个参数options是一个字典。</p>
<p>字典中唯一使用的key是AVURLAssetPreferPreciseDurationAndTimingKey。对应的值是一个布尔值（包含在 NSValue对象中），这个布尔值指出了这个asset是否应该提供准确的duration，以及支持随机读取指定时间的内容。</p>
<p>获得一个asset 精确的的持续时间duration可能需要大量的处理开销。使用一个近似的持续时间通常是更划算的选择，并且对于播放已经足够。因此：</p>
<ul>
<li>如果只是播放asset，options传递nil，或者字典里对应的值是NO(包含在NSValue对象中)</li>
<li>如果要将asset添加到composition，需要精确的随机存取，传递一个字典，对应值是YES(包含在NSValue对象中)</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *dict = @&#123;<span class="built_in">AVURLAssetPreferPreciseDurationAndTimingKey</span> : @YES&#125;; </span><br><span class="line"><span class="built_in">AVURLAsset</span> *asset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:fileUrl options:dict];</span><br></pre></td></tr></table></figure>

<h3 id="1-2-3-访问用户的asset-iPod库-相册"><a href="#1-2-3-访问用户的asset-iPod库-相册" class="headerlink" title="1.2.3 访问用户的asset(iPod库+相册)"></a>1.2.3 访问用户的asset(iPod库+相册)</h3><p>要访问由 iPod 库、相册中的资产，需要获取对应资产的 URL。</p>
<ul>
<li>访问 iPod 库，需要创建一个 MPMediaQuery 实例来查找想要的项目，然后使用 <strong>MPMediaItemPropertyAssetURL</strong> 获取其 URL。</li>
<li>访问照片应用程序管理的资产，使用 <strong>ALAssetsLibrary</strong> —— iOS9.0之后这个库失效，使用PHPhotoLibrary库</li>
</ul>
<p>下面的是获取用户相册中第一个视频的示例代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">ALAssetsLibrary *library = [[ALAssetsLibrary alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Enumerate just the photos and videos group by using ALAssetsGroupSavedPhotos.</span></span><br><span class="line">[library enumerateGroupsWithTypes:ALAssetsGroupSavedPhotos usingBlock:^(ALAssetsGroup *group, <span class="built_in">BOOL</span> *stop) &#123;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Within the group enumeration block, filter to enumerate just videos.</span></span><br><span class="line">[group setAssetsFilter:[ALAssetsFilter allVideos]];</span><br><span class="line"> </span><br><span class="line"><span class="comment">// For this example, we&#x27;re only interested in the first item.</span></span><br><span class="line">[group enumerateAssetsAtIndexes:[<span class="built_in">NSIndexSet</span> indexSetWithIndex:<span class="number">0</span>]</span><br><span class="line">                        options:<span class="number">0</span></span><br><span class="line">                     usingBlock:^(ALAsset *alAsset, <span class="built_in">NSUInteger</span> index, <span class="built_in">BOOL</span> *innerStop) &#123;</span><br><span class="line"> </span><br><span class="line">                         <span class="comment">// The end of the enumeration is signaled by asset == nil.</span></span><br><span class="line">                         <span class="keyword">if</span> (alAsset) &#123;</span><br><span class="line">                             ALAssetRepresentation *representation = [alAsset defaultRepresentation];</span><br><span class="line">                             <span class="built_in">NSURL</span> *url = [representation url];</span><br><span class="line">                             <span class="built_in">AVAsset</span> *avAsset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line">                             <span class="comment">// Do something interesting with the AV asset.</span></span><br><span class="line">                         &#125;</span><br><span class="line">                     &#125;];</span><br><span class="line">                 &#125;</span><br><span class="line">                 failureBlock: ^(<span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                     <span class="comment">// Typically you should handle an error more gracefully than this.</span></span><br><span class="line">                     <span class="built_in">NSLog</span>(<span class="string">@&quot;No groups&quot;</span>);</span><br><span class="line">                 &#125;];</span><br></pre></td></tr></table></figure>

<h2 id="1-3-使用Asset"><a href="#1-3-使用Asset" class="headerlink" title="1.3 使用Asset"></a>1.3 使用Asset</h2><p>注意：<strong>初始化asset或track并不一定意味着它已准备好使用。</strong>可能需要一些时间去计算项目的持续时间(duration)（例如，MP3 文件可能不包含摘要信息）。计算时不要阻塞当前线程，可以使用 AVAsynchronousKeyValueLoading 协议来请求值，完成处理后通过定义的block回调结果（AVAsset 和 AVAssetTrack 符合 AVAsynchronousKeyValueLoading 协议）。</p>
<p>可以使用 <code>statusOfValueForKey:error:</code> 判断是否为属性加载了值。asset首次加载时，其大部分或全部属性的值为 AVKeyValueStatusUnknown。</p>
<p>可以使用 <code>loadValuesAsynchronouslyForKeys:completionHandler:</code> 为一个或多个属性加载值。在完成处理程序中，可以根据属性的状态采取任何适当的操作。注意：加载是可能会失败的，比如基于网络的 URL 不可访问，或者加载被取消。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = &lt;#A URL that identifies an audiovisual asset such as a movie file#&gt;;</span><br><span class="line"><span class="built_in">AVURLAsset</span> *anAsset = [[<span class="built_in">AVURLAsset</span> alloc] initWithURL:url options:<span class="literal">nil</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *keys = @[<span class="string">@&quot;duration&quot;</span>]; <span class="comment">// 如果准备一个asset去播放，应该加载它的 tracks 属性</span></span><br><span class="line"> </span><br><span class="line">[asset loadValuesAsynchronouslyForKeys:keys completionHandler:^() &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVKeyValueStatus</span> tracksStatus = [asset statusOfValueForKey:<span class="string">@&quot;duration&quot;</span> error:&amp;error];</span><br><span class="line">    <span class="keyword">switch</span> (tracksStatus) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusLoaded</span>:</span><br><span class="line">            [<span class="keyword">self</span> updateUserInterfaceForDuration];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusFailed</span>:</span><br><span class="line">            [<span class="keyword">self</span> reportError:error forAsset:asset];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVKeyValueStatusCancelled</span>:</span><br><span class="line">            <span class="comment">// Do whatever is appropriate for cancelation.</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="1-4-视频中获取静态图像-AssetImageGenerator"><a href="#1-4-视频中获取静态图像-AssetImageGenerator" class="headerlink" title="1.4 视频中获取静态图像(AssetImageGenerator)"></a>1.4 视频中获取静态图像(AssetImageGenerator)</h2><p>从视频中获取静态图片 (比如某个时间点的视频预览缩略图)，可以使用 AVAssetImageGenerator。</p>
<p>使用asset初始化一个图像生成器对象。注意即使asset在初始化时没有视觉轨道，初始化也可能成功，所以如果有必要，应该使用 trackWithMediaCharacteristic: 提前判断一下asset是否用于可视化的track。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> anAsset = &lt;#Get an asset#&gt;; <span class="comment">// 使用要生成缩略图的asset来初始化</span></span><br><span class="line"><span class="keyword">if</span> ([[anAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">AVAssetImageGenerator</span> *imageGenerator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:anAsset];</span><br><span class="line">    <span class="comment">// Image Generator使用默认启用的视频轨道来生成图像</span></span><br><span class="line">    <span class="comment">// Implementation continues...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以配置图像生成器的几个方面，比如：</p>
<ul>
<li>使用 maximumSize 属性设置图片的最大尺寸</li>
<li>使用 apertureMode 属性设置图片的光栅模式</li>
<li>根据给定的时间点生成单张或者一系列的图片</li>
</ul>
<p>注意：生成过程中必须确保 imagegenerator 的强引用。</p>
<h3 id="1-4-1-生成单个图像"><a href="#1-4-1-生成单个图像" class="headerlink" title="1.4.1 生成单个图像"></a>1.4.1 生成单个图像</h3><p>使用 copyCGImageAtTime:actualTime:error: 在指定时间生成单个图像。AVFoundation可能无法精确的根据你指定的时间生成图像，所以可以将一个指向 CMTime 的指针作为第二个参数传递，该指针在返回时包含实际生成图像的时间。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *myAsset = &lt;#An asset#&gt;];</span><br><span class="line"><span class="built_in">AVAssetImageGenerator</span> *imageGenerator = [[<span class="built_in">AVAssetImageGenerator</span> alloc] initWithAsset:myAsset];</span><br><span class="line"></span><br><span class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([myAsset duration]);</span><br><span class="line"><span class="built_in">CMTime</span> midpoint = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">2.0</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">CMTime</span> actualTime;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CGImageRef</span> halfWayImage = [imageGenerator copyCGImageAtTime:midpoint actualTime:&amp;actualTime error:&amp;error];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (halfWayImage != <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSString</span> *actualTimeString = (<span class="built_in">NSString</span> *)<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, actualTime);</span><br><span class="line">    <span class="built_in">NSString</span> *requestedTimeString = (<span class="built_in">NSString</span> *)<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, midpoint);</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Got halfWayImage: Asked for %@, got %@&quot;</span>, requestedTimeString, actualTimeString);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Do something interesting with the image.</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(halfWayImage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-2-生成一系列图像"><a href="#1-4-2-生成一系列图像" class="headerlink" title="1.4.2 生成一系列图像"></a>1.4.2 生成一系列图像</h3><p>使用 <code>generateCGImagesAsynchronouslyForTimes:completionHandler:</code> 生成一系列图像。</p>
<ul>
<li>第一个参数是一个 NSValue 对象数组，每个对象都包含一个 CMTime 结构体对象，指定你希望的生成图像的时间。</li>
<li>第二个参数是一个block，用作为生成的每个图像调用的回调。block的参数中提供了一个结果常量，表示图像创建是成功、失败、被取消等结果，在 block 中，应当检查图片生成的结果。另外，根据不同情况，可能包含以下的参数：<ul>
<li>生成的图片</li>
<li>请求生成图片的时间和实际生成图片的时间</li>
<li>生成失败的原因</li>
</ul>
</li>
</ul>
<p>在完成创建图像之前，保持一个对图像生成器的强引用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *myAsset = &lt;#An asset#&gt;];</span><br><span class="line"><span class="comment">// Assume: @property (strong) AVAssetImageGenerator *imageGenerator;</span></span><br><span class="line"><span class="keyword">self</span>.imageGenerator = [<span class="built_in">AVAssetImageGenerator</span> assetImageGeneratorWithAsset:myAsset];</span><br><span class="line"></span><br><span class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([myAsset duration]);</span><br><span class="line"><span class="built_in">CMTime</span> firstThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">3.0</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">CMTime</span> secondThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds*<span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">CMTime</span> end = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds, <span class="number">600</span>);</span><br><span class="line"><span class="built_in">NSArray</span> *times = @[<span class="built_in">NSValue</span> valueWithCMTime:kCMTimeZero],</span><br><span class="line">                  [<span class="built_in">NSValue</span> valueWithCMTime:firstThird], [<span class="built_in">NSValue</span> valueWithCMTime:secondThird],</span><br><span class="line">                  [<span class="built_in">NSValue</span> valueWithCMTime:end]];</span><br><span class="line"></span><br><span class="line">[imageGenerator generateCGImagesAsynchronouslyForTimes:times</span><br><span class="line">                completionHandler:^(<span class="built_in">CMTime</span> requestedTime, <span class="built_in">CGImageRef</span> image, <span class="built_in">CMTime</span> actualTime,</span><br><span class="line">                                    <span class="built_in">AVAssetImageGeneratorResult</span> result, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">NSString</span> *requestedTimeString = (<span class="built_in">NSString</span> *)</span><br><span class="line">                    <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, requestedTime));</span><br><span class="line">                <span class="built_in">NSString</span> *actualTimeString = (<span class="built_in">NSString</span> *)</span><br><span class="line">                    <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, actualTime));</span><br><span class="line">                <span class="built_in">NSLog</span>(<span class="string">@&quot;Requested: %@; actual %@&quot;</span>, requestedTimeString, actualTimeString);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorSucceeded</span>) &#123;</span><br><span class="line">                    <span class="comment">// Do something interesting with the image.</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorFailed</span>) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;Failed with error: %@&quot;</span>, [error localizedDescription]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result == <span class="built_in">AVAssetImageGeneratorCancelled</span>) &#123;</span><br><span class="line">                    <span class="built_in">NSLog</span>(<span class="string">@&quot;Canceled&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">  &#125;];</span><br></pre></td></tr></table></figure>

<p>调用图像生成器的 cancelAllCGImageGeneration ，来取消图像序列的生成。</p>
<h2 id="1-5-视频的剪辑和转码-AVAssetExportSession"><a href="#1-5-视频的剪辑和转码-AVAssetExportSession" class="headerlink" title="1.5 视频的剪辑和转码(AVAssetExportSession)"></a>1.5 视频的剪辑和转码(AVAssetExportSession)</h2><p>AVAssetExportSession 对象可以剪辑视频或者对视频进行格式转换。流程图如下：</p>
<img src="/images/avf/export_2x.png" alt="img" style="zoom:80%;" />

<p>导出会话(export session)是管理asset异步导出的控制器对象。</p>
<ul>
<li><p>使用要导出的asset、指示导出选项的导出预设(export preset)的名称来初始化会话。</p>
<ul>
<li>使用 exportPresetsCompatibleWithAsset: 检查是否可以使用给定预设导出asset</li>
</ul>
</li>
<li><p>然后配置 export session 指定导出的 URL 、文件格式、其他信息 (比如是否因为网络使用而对元数据进行优化)。</p>
<ul>
<li>指定输出URL：该URL必须是文件URL</li>
<li>文件类型：AVAssetExportSession 可以从 URL 的路径扩展名推断输出文件类型；但是，通常您直接使用 outputFileType 设置它。</li>
<li>其它可选的设置，例如元数据、时间范围、输出文件长度的限制、导出的文件是否应针对网络使用输出优化、视频合成等。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *anAsset = &lt;#Get an asset#&gt;;</span><br><span class="line"><span class="built_in">NSArray</span> *compatiblePresets = [<span class="built_in">AVAssetExportSession</span> exportPresetsCompatibleWithAsset:anAsset];</span><br><span class="line"><span class="keyword">if</span> ([compatiblePresets containsObject:<span class="built_in">AVAssetExportPresetLowQuality</span>]) &#123;</span><br><span class="line">    <span class="built_in">AVAssetExportSession</span> *exportSession = [[<span class="built_in">AVAssetExportSession</span> alloc]</span><br><span class="line">        initWithAsset:anAsset presetName:<span class="built_in">AVAssetExportPresetLowQuality</span>];</span><br><span class="line">    <span class="comment">// Implementation continues.</span></span><br><span class="line">    <span class="comment">// 使用 timeRange 属性修剪影片</span></span><br><span class="line">    exportSession.outputURL = &lt;#A file URL#&gt;;</span><br><span class="line">    exportSession.outputFileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">CMTime</span> start = <span class="built_in">CMTimeMakeWithSeconds</span>(<span class="number">1.0</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="built_in">CMTime</span> duration = <span class="built_in">CMTimeMakeWithSeconds</span>(<span class="number">3.0</span>, <span class="number">600</span>);</span><br><span class="line">    <span class="built_in">CMTimeRange</span> range = <span class="built_in">CMTimeRangeMake</span>(start, duration);</span><br><span class="line">    exportSession.timeRange = range;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>使用 exportAsynchronouslyWithCompletionHandler: 方法导出文件。导出操作完成时会调用complete handler。在该代码块中，需要根据 status 属性判断导出是否成功。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[exportSession exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> ([exportSession status]) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVAssetExportSessionStatusFailed</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Export failed: %@&quot;</span>, [[exportSession error] localizedDescription]);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="built_in">AVAssetExportSessionStatusCancelled</span>:</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Export canceled&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure></li>
<li><p>可以通过向会话发送 cancelExport 消息来取消导出。</p>
</li>
</ul>
<p>导出到一个已存在的文件或者导出到应用程序沙盒目录外将会导致导出失败。其他可能导致失败的情况包括：</p>
<ul>
<li>导出过程中接收到电话呼叫</li>
<li>程序进入后台, 有其他程序开始使用播放功能</li>
</ul>
<p>在这些情况下，要告知用户导出失败，并允许用户重新开始导出。</p>
<h1 id="二、播放Assets"><a href="#二、播放Assets" class="headerlink" title="二、播放Assets"></a>二、播放Assets</h1><p>AVFoundation 允许以更精确的方式管理asset的播放。为了支持这一点，它将asset的呈现状态(presentation state)与asset本身分开。这就能让开发者在同一时刻以不同分辨率呈现同一资源的两个不同片段。</p>
<ul>
<li>使用 AVPlayer 对象来控制asset的播放。</li>
<li>使用播放器项目(player item)对象管理asset的呈现状态（AVPlayerItem 实例）</li>
<li>使用播放器项目轨道(player item track)对象管理asset中每个轨道的呈现状态 （AVPlayerItemTrack实例）</li>
</ul>
<p>比如，使用 player item 和 player item tracks 可以：</p>
<ul>
<li>设置资源的可视部分在播放时的尺寸</li>
<li>播放时，设置audio 的混音参数、视频合成设置，或者禁用asset中的某些部分</li>
</ul>
<p>使用 <em>player</em> 对象可以播放 player items 对象，或者直接指定将其输出 (output) 到 Core Animation layer 之上。还可以使用播放队列(<em>player queue</em>) 来顺序播放多个 player items 对象。</p>
<p>使用 AVPlayerLayer 对象来显示视频。</p>
<h2 id="2-1-核心类概述"><a href="#2-1-核心类概述" class="headerlink" title="2.1 核心类概述"></a>2.1 核心类概述</h2><h3 id="2-1-1-播放器AVPlayer"><a href="#2-1-1-播放器AVPlayer" class="headerlink" title="2.1.1 播放器AVPlayer"></a>2.1.1 播放器AVPlayer</h3><p>播放器(player)是一个控制器对象，用于管理资源的播放，例如开始和停止播放，以及寻找特定时间。</p>
<ul>
<li>使用 AVPlayer 实例来播放单个资源。</li>
<li>使用 AVQueuePlayer 对象按顺序播放多个项目（AVQueuePlayer 是 AVPlayer 的子类）。在 OS X 上，您可以选择使用 AVKit 框架的 AVPlayerView 类在视图中播放内容。</li>
</ul>
<p>播放器可提供有关播放状态的信息，因此，如果需要，可以将用户界面与播放器的状态同步。</p>
<p>通常，将播放器的输出定向到专门的核心动画层（AVPlayerLayer 或 AVSynchronizedLayer 的实例）。要了解有关图层的更多信息，请参阅核心动画编程指南。</p>
<blockquote>
<p>多个播放器层：您可以从单个 AVPlayer 实例创建多个 AVPlayerLayer 对象，但只有最近创建的layer才会在屏幕上显示视频内容。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放器AVPlayer</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayer</span> : <span class="title">NSObject</span> </span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)URL;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithPlayerItem:(<span class="keyword">nullable</span> <span class="built_in">AVPlayerItem</span> *)item;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVPlayerStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">AVPlayerItem</span> *currentItem;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> volume;  <span class="comment">// 音量</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">getter</span>=isMuted) <span class="built_in">BOOL</span> muted; <span class="comment">// 静音</span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-AVPlayerItem"><a href="#2-1-2-AVPlayerItem" class="headerlink" title="2.1.2 AVPlayerItem"></a>2.1.2 AVPlayerItem</h3><ul>
<li>播放资源时，需要向 AVPlayer 对象提供一个 AVPlayerItem 实例，而不是直接提供asset。</li>
<li>player item会管理与其关联的asset的呈现状态。</li>
<li>player item包含了播放器项目轨道（AVPlayerItemTrack 的实例），它们对应于asset中的轨道。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 播放器项目AVPlayerItem</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayerItem</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)URL;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAsset:(<span class="built_in">AVAsset</span> *)asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">AVPlayerItemStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAsset</span> *asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVPlayerItemTrack</span> *&gt; *tracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CMTime</span> duration;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">CGSize</span> presentationSize;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>不仅可以使用现有asset初始化player item，也可以直接从 URL 初始化，以便你可以在特定位置播放资源（AVPlayerItem会为资源创建和配置一个asset）。</p>
<p>然而，与 AVAsset 一样，简单地初始化一个player item并不一定意味着它已经可以立即播放。你可以<strong>使用KVO观察player item的status属性</strong>来确定它是否以及何时准备好播放。</p>
<h3 id="2-1-3-AVPlayerLayer"><a href="#2-1-3-AVPlayerLayer" class="headerlink" title="2.1.3 AVPlayerLayer"></a>2.1.3 AVPlayerLayer</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayerLayer</span> : <span class="title">CALayer</span></span>&#123;</span><br><span class="line"><span class="keyword">@private</span></span><br><span class="line">	<span class="built_in">AVPlayerLayerInternal</span>		*_playerLayer;</span><br><span class="line">&#125;</span><br><span class="line">+ (<span class="built_in">AVPlayerLayer</span> *)playerLayerWithPlayer:(<span class="keyword">nullable</span> <span class="built_in">AVPlayer</span> *)player;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">nullable</span>) <span class="built_in">AVPlayer</span> *player;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">AVLayerVideoGravity</span> videoGravity;</span><br><span class="line"><span class="comment">//指示player的当前player item的第一个视频帧是否准备好显示</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isReadyForDisplay) <span class="built_in">BOOL</span> readyForDisplay;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGRect</span> videoRect;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *pixelBufferAttributes;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-类关系梳理"><a href="#2-1-4-类关系梳理" class="headerlink" title="2.1.4 类关系梳理"></a>2.1.4 类关系梳理</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVPlayerItemTrack</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">/* 被播放器项目轨道表示了其呈现状态的资产轨道。 */</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">nullable</span>) <span class="built_in">AVAssetTrack</span> *assetTrack;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>按照类关联关系：AVPlayer → AVPlayerItem → AVPlayerItemTrack → AVAssetTrack</p>
</blockquote>
<img src="/images/avf/avplayerLayer_2x.png" alt="avplayerLayer_2x" style="zoom:70%;" />

<p>这种抽象意味着可以同时使用不同的播放器播放一个给定的资源，每个播放器以不同的方式呈现。比如下图 ，不同的播放器使用不同的设置播放同一个相同的资产。可以使用项目轨道，在播放期间禁用特定轨道（例如屏蔽声音）。</p>
<img src="/images/avf/playerObjects_2x.png" alt="playerObjects_2x" style="zoom:70%;" />

<h2 id="2-2-处理不同类型的资源"><a href="#2-2-处理不同类型的资源" class="headerlink" title="2.2 处理不同类型的资源"></a>2.2 处理不同类型的资源</h2><h3 id="2-2-1-两种类型资源"><a href="#2-2-1-两种类型资源" class="headerlink" title="2.2.1 两种类型资源"></a>2.2.1 两种类型资源</h3><p>asset播放的方式取决于其类型。从广义上讲，有两种主要类型：</p>
<ul>
<li>基于文件的资源 file-based assets ，你可以随机访问（例如从本地文件、媒体库、相册）</li>
<li>基于流的资源 stream-based assets（HTTP 实时流格式）</li>
</ul>
<h3 id="2-2-2-播放基于文件的资源"><a href="#2-2-2-播放基于文件的资源" class="headerlink" title="2.2.2 播放基于文件的资源"></a>2.2.2 播放基于文件的资源</h3><p>步骤：</p>
<ol>
<li>使用 AVURLAsset 创建 AVAsset</li>
<li>使用asset创建 AVPlayerItem 的实例</li>
<li>将 AVPlayerItem实例 与 AVPlayer 实例相关联</li>
<li>等待，直到player item的status属性表明已经可以播放（通过KVO观察属性变化）。</li>
</ol>
<p>示例代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define this constant for the key-value observation context.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *ItemStatusContext;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle] URLForResource:<span class="string">@&quot;VideoFileName&quot;</span> </span><br><span class="line">                                             withExtension:<span class="string">@&quot;extension&quot;</span>];</span><br><span class="line">    <span class="comment">//创建一个资源实例</span></span><br><span class="line">    <span class="built_in">AVAsset</span> *asset = [<span class="built_in">AVAsset</span> assetWithURL:fileURL];</span><br><span class="line">    <span class="comment">//关联播放资源</span></span><br><span class="line">    <span class="built_in">AVPlayerItem</span> *playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</span><br><span class="line">    <span class="comment">//添加监听PlayerItem的status属性值</span></span><br><span class="line">    [playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;status&quot;</span> options:<span class="number">0</span> context:&amp;ItemStatusContext];</span><br><span class="line">    <span class="comment">//创建player</span></span><br><span class="line">    _player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:playerItem]; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context == &amp;ItemStatusContext) &#123;</span><br><span class="line">        <span class="comment">// ... 处理逻辑 ...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</span><br><span class="line">           change:change context:context];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-3-播放-HTTP-实时流"><a href="#2-2-3-播放-HTTP-实时流" class="headerlink" title="2.2.3 播放 HTTP 实时流"></a>2.2.3 播放 HTTP 实时流</h3><p>使用 URL 初始化 AVPlayerItem 的实例。（不能直接创建 AVAsset 实例来表示 HTTP 实时流中的媒体）</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@&quot;&lt;#Live stream URL#&gt;];</span></span><br><span class="line"><span class="string">// You may find a test stream at &lt;http://devimages.apple.com/iphone/samples/bipbop/bipbopall.m3u8&gt;.</span></span><br><span class="line"><span class="string">self.playerItem = [AVPlayerItem playerItemWithURL:url];</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 观察player item的status属性</span></span><br><span class="line"><span class="string">[playerItem addObserver:self forKeyPath:@&quot;</span>status<span class="string">&quot; options:0 context:&amp;ItemStatusContext];</span></span><br><span class="line"><span class="string">self.player = [AVPlayer playerWithPlayerItem:playerItem];</span></span><br></pre></td></tr></table></figure>


<p>将 AVPlayerItem实例 与 AVPlayer 实例相关联，准备播放。当准备好播放时，player item会创建 AVAsset 和 AVAssetTrack 实例，可以使用它们来检查实时流的内容。</p>
<p>要获取流媒体项目的持续时间，可以观察player item的duration属性。当项目准备好播放时，此属性将更新为流的正确值。</p>
<p>如果只是想播放直播，可以如以下代码，直接使用 URL 创建创建播放器player：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithURL:&lt;#Live stream URL#&gt;];</span><br><span class="line"><span class="comment">//观察player的status的属性</span></span><br><span class="line">[player addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;status&quot;</span> options:<span class="number">0</span> context:&amp;PlayerStatusContext];</span><br></pre></td></tr></table></figure>

<p>补充：与AVAsset和AVPlayerItem一样，初始化了播放器并不意味着它已准备好播放。你应该监听播放器的status属性，当它准备好播放时，其值会更改为 AVPlayerStatusReadyToPlay。您还可以观察 currentItem 属性以访问为流创建的播放器项目。</p>
<h3 id="2-2-4-URL类型的判断"><a href="#2-2-4-URL类型的判断" class="headerlink" title="2.2.4 URL类型的判断"></a>2.2.4 URL类型的判断</h3><p>如果不知道自己的 URL 类型，可以按照以下步骤操作：</p>
<ol>
<li>尝试使用 URL 初始化 AVURLAsset，然后加载它的tracks属性。如果tracks加载成功，就可以为资源创建一个AVPlayerItem实例。</li>
<li>如果第一步失败，则直接从 URL 创建一个 AVPlayerItem，监听其status属性来确定它是否可以播放。</li>
</ol>
<p>上面任一分支成功，最后都会得到一个player item，然后将其与播放器player关联。</p>
<h2 id="2-3-播放一个项目-AVPlayer"><a href="#2-3-播放一个项目-AVPlayer" class="headerlink" title="2.3 播放一个项目 AVPlayer"></a>2.3 播放一个项目 AVPlayer</h2><h3 id="2-3-1-概述"><a href="#2-3-1-概述" class="headerlink" title="2.3.1 概述"></a>2.3.1 概述</h3><p>调用播放器的play方法，即可开始播放</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)play:sender &#123;</span><br><span class="line">    [player play]；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了简单的播放之外，还可以管理播放的各个方面，例如：</p>
<ul>
<li>设置播放头的速率和位置 （<em>播放头playhead为显示当前播放位置的那一条与时间轴垂直的线</em>）</li>
<li>监控播放器的播放状态（比如设置用户界面与资源的呈现状态同步）。</li>
</ul>
<h3 id="2-3-2-更改播放速度"><a href="#2-3-2-更改播放速度" class="headerlink" title="2.3.2 更改播放速度"></a>2.3.2 更改播放速度</h3><p>设置播放器的 rate 属性来更改播放速度。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">aPlayer.rate = <span class="number">0.5</span>;</span><br><span class="line">aPlayer.rate = <span class="number">2.0</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>值 1.0 表示“以当前项目的自然速度播放”。</li>
<li>值 0.0 与暂停播放相同——也可以直接调用 <code>pause</code> 方法暂停。</li>
<li>当项目支持反向播放时，可以使用赋值 rate 负数来设置反向播放速度。</li>
</ul>
<p>playerItem 的几个属性，用来确定支持的反向播放类型：</p>
<ul>
<li>canPlayReverse（是否支持 -1.0 的速度值）</li>
<li>canPlaySlowReverse（是否支持介于 0.0 到 -1.0 之间的速度）</li>
<li> canPlayFastReverse（是否支持小于 -1.0 的速度值）</li>
</ul>
<h3 id="2-3-3-寻找—重新定位播放头"><a href="#2-3-3-寻找—重新定位播放头" class="headerlink" title="2.3.3 寻找—重新定位播放头"></a>2.3.3 寻找—重新定位播放头</h3><p>要将播放头移动到特定时间，可以使用以下两种方式：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// seekToTime:方法是针对性能而不是精度进行调整的</span></span><br><span class="line"><span class="built_in">CMTime</span> fiveSecondsIn = <span class="built_in">CMTimeMake</span>(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">[player seekToTime:fiveSecondsIn];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要精确移动播放头，使用下面的方法。[tolerance 容许偏差]</span></span><br><span class="line"><span class="built_in">CMTime</span> FiveSecondsIn = <span class="built_in">CMTimeMake</span>(<span class="number">5</span>, <span class="number">1</span>);</span><br><span class="line">[player seekToTime:fiveSecondsIn toleranceBefore:kCMTimeZero toleranceAfter:kCMTimeZero];</span><br></pre></td></tr></table></figure>

<p>注意：使用零容差可能需要框架解码大量数据。仅当你正在编写需要精确控制的复杂媒体编辑APP时才应使用。</p>
<p>播放后，播放器的头部被设置到项目的末尾，进一步调用 play 无效。要将播放头放回项目的开头，您可以注册以接收来自项目的 AVPlayerItemDidPlayToEndTimeNotification 通知。在通知的回调方法中，您使用参数 kCMTimeZero 调用 seekToTime:。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register with the notification center after creating the player item.</span></span><br><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">    addObserver:<span class="keyword">self</span></span><br><span class="line">    selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">    name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">    object:&lt;#The player item#&gt;];</span><br><span class="line"> </span><br><span class="line">- (<span class="keyword">void</span>)playerItemDidReachEnd:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    [player seekToTime:kCMTimeZero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-播放多个项目-AVQueuePlayer"><a href="#2-4-播放多个项目-AVQueuePlayer" class="headerlink" title="2.4 播放多个项目 AVQueuePlayer"></a>2.4 播放多个项目 AVQueuePlayer</h2><p>使用 AVQueuePlayer 对象按顺序播放多个项目。 AVQueuePlayer 类是 AVPlayer 的子类。使用一个盛放player Item的数组初始化队列播放器。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *items = &lt;#An array of player items#&gt;;</span><br><span class="line"><span class="built_in">AVQueuePlayer</span> *queuePlayer = [[<span class="built_in">AVQueuePlayer</span> alloc] initWithItems:items];</span><br><span class="line"><span class="comment">// 使用 play 播放队列，就像使用 AVPlayer 对象一样</span></span><br><span class="line">[queuePlayer paly];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列播放器依次播放每个项目。可以调用advanceToNextItem跳到下一个项目</span></span><br><span class="line">[queuePlayer advanceToNextItem];</span><br></pre></td></tr></table></figure>

<p>可以使用 insertItem:afterItem:、removeItem: 和 removeAllItems 修改队列。添加新项目时，应使用 canInsertItem:afterItem: 检查是否可以将其插入队列。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVPlayerItem</span> *anItem = &lt;#Get a player item#&gt;;</span><br><span class="line"><span class="comment">// 判断是否可以将新项目附加到队列中，第二个参数可以传 nil</span></span><br><span class="line"><span class="keyword">if</span> ([queuePlayer canInsertItem:anItem afterItem:<span class="literal">nil</span>]) &#123;</span><br><span class="line">    [queuePlayer insertItem:anItem afterItem:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-播放监听"><a href="#2-5-播放监听" class="headerlink" title="2.5 播放监听"></a>2.5 播放监听</h2><h3 id="2-5-1-使用场景"><a href="#2-5-1-使用场景" class="headerlink" title="2.5.1 使用场景"></a>2.5.1 使用场景</h3><p>可以监听播放器player的呈现状态和正在播放的播放器项目player item的许多方面。当一些不受开发者直接控制的状态更改时，这将特别有用。例如：</p>
<ul>
<li>如果用户使用多任务切换到不同的应用程序，AVPlayer的 rate 属性值将下降到 0.0。</li>
<li>如果正在播放远程媒体，AVPlayerItem 的 loadedTimeRanges 和 seekableTimeRanges 属性将随着更多数据可用而改变。<br>这些属性告诉您播放器项目时间线的哪些部分可用。</li>
<li>当为 HTTP 直播流创建 AVPlayerItem 时，AVPlayer的 currentItem 属性会发生变化。</li>
<li>播放 HTTP 直播流时，AVPlayerItem 的 tracks 属性可能会发生变化。（比如如果流为内容提供了不同的编码，当播放器切换到不同的编码，tracks会发生变化。）</li>
<li>如果由于某种原因播放失败，AVPlayer 或 AVPlayerItem 的 status 属性可能会更改。</li>
</ul>
<p>可以使用KVO来监听这些属性值的变化。<strong>注意：需要在主线程上注册、注销KVO通知。</strong></p>
<h3 id="2-5-2-监听status的变化"><a href="#2-5-2-监听status的变化" class="headerlink" title="2.5.2 监听status的变化"></a>2.5.2 监听status的变化</h3><p>当播放器或播放器项目的 status 发生变化时，会发出一个KVO改变通知。如果对象由于某种原因无法播放（例如，如果媒体服务被重置），则 status 将根据需要更改为 AVPlayerStatusFailed 或 AVPlayerItemStatusFailed。在这种情况下，对象的 error 属性将被赋值为一个NSError对象，描述了错误原因。</p>
<p>AV Foundation 没有指定发送通知的线程。如果要通知更新用户界面，则必须确保是在主线程上进行操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (context == &lt;#Player status context#&gt;) &#123;</span><br><span class="line">        <span class="built_in">AVPlayer</span> *thePlayer = (<span class="built_in">AVPlayer</span> *)object;</span><br><span class="line">        <span class="keyword">if</span> ([thePlayer status] == <span class="built_in">AVPlayerStatusFailed</span>) &#123;</span><br><span class="line">            <span class="built_in">NSError</span> *error = [&lt;#The <span class="built_in">AVPlayer</span> object#&gt; error];</span><br><span class="line">            <span class="comment">// Respond to error: for example, display an alert sheet.</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Deal with other status change if appropriate.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Deal with other change notifications if appropriate.</span></span><br><span class="line">    [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</span><br><span class="line">           change:change context:context];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-5-3-监听可视化内容的就绪状态"><a href="#2-5-3-监听可视化内容的就绪状态" class="headerlink" title="2.5.3 监听可视化内容的就绪状态"></a>2.5.3 监听可视化内容的就绪状态</h3><p>监听 AVPlayerLayer 对象的 readyForDisplay 属性，以便在图层具有用户可见内容时收到通知。特别是，当你只需要在有可视化内容时，才要将播放器图层 player layer 插入到图层树layer tree中的情况。</p>
<h3 id="2-5-4-监听播放时间"><a href="#2-5-4-监听播放时间" class="headerlink" title="2.5.4 监听播放时间"></a>2.5.4 监听播放时间</h3><p>使用场景：根据已播放时间或剩余时间来更新用户界面，或执行一些其他用户界面同步。</p>
<p>跟踪 AVPlayer 对象中播放头位置的变化，可以使用下面的两个方法：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// block会在指定的时间间隔中被调用。如果时间有跳跃，会在播放开始或者结束的时候调用</span></span><br><span class="line">- (<span class="keyword">id</span>)addPeriodicTimeObserverForInterval:(<span class="built_in">CMTime</span>)interval </span><br><span class="line">                                   queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue </span><br><span class="line">                              usingBlock:(<span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> time))block;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 传入一个包装CMTime的NSValue数组。每当这些时间被通过时，block都会被调用</span></span><br><span class="line">- (<span class="keyword">id</span>)addBoundaryTimeObserverForTimes:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)times </span><br><span class="line">                                queue:(<span class="keyword">nullable</span> <span class="built_in">dispatch_queue_t</span>)queue </span><br><span class="line">                           usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>这两种方法都返回一个作为 observer 的不透明对象。必须对其保持强引用。</li>
<li>必须平衡上面这两个方法与 removeTimeObserver: 的调用。</li>
<li>使用上面两个方法，AV Foundation 不保证在每个间隔、边界通过时都会调用block。如果先前调用的block执行尚未完成，就不会调用block。因此，您必须确保您在block中执行的工作不会对系统造成过多的负担。</li>
</ol>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Assume a property: @property (strong) id playerObserver;</span></span><br><span class="line"> </span><br><span class="line">Float64 durationSeconds = <span class="built_in">CMTimeGetSeconds</span>([&lt;#An asset#&gt; duration]);</span><br><span class="line"><span class="built_in">CMTime</span> firstThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds/<span class="number">3.0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">CMTime</span> secondThird = <span class="built_in">CMTimeMakeWithSeconds</span>(durationSeconds*<span class="number">2.0</span>/<span class="number">3.0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">NSArray</span> *times = @[[<span class="built_in">NSValue</span> valueWithCMTime:firstThird], [<span class="built_in">NSValue</span> valueWithCMTime:secondThird]];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">self</span>.playerObserver = [&lt;#A player#&gt; addBoundaryTimeObserverForTimes:times queue:<span class="literal">NULL</span> usingBlock:^&#123;</span><br><span class="line">    <span class="built_in">NSString</span> *timeDescription = (<span class="built_in">NSString</span> *)</span><br><span class="line">        <span class="built_in">CFBridgingRelease</span>(<span class="built_in">CMTimeCopyDescription</span>(<span class="literal">NULL</span>, [<span class="keyword">self</span>.player currentTime]));</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Passed a boundary at %@&quot;</span>, timeDescription);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h3 id="2-5-5-监听播放结束"><a href="#2-5-5-监听播放结束" class="headerlink" title="2.5.5 监听播放结束"></a>2.5.5 监听播放结束</h3><p>可以注册<code>AVPlayerItemDidPlayToEndTimeNotification</code>通知来监听 player item 的播放结束.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:&lt;#The observer, typically <span class="keyword">self</span>#&gt;</span><br><span class="line">                                         selector:<span class="keyword">@selector</span>(&lt;#The selector name#&gt;)</span><br><span class="line">                                           name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">                                           object:&lt;#A player item#&gt;];</span><br></pre></td></tr></table></figure>

<h2 id="2-6-示例：使用-AVPlayerLayer-播放视频文件"><a href="#2-6-示例：使用-AVPlayerLayer-播放视频文件" class="headerlink" title="2.6 示例：使用 AVPlayerLayer 播放视频文件"></a>2.6 示例：使用 AVPlayerLayer 播放视频文件</h2><p>这个简短的代码示例说明了如何使用 AVPlayer 对象来播放视频文件。它展示了如何：</p>
<ul>
<li>使用 AVPlayerLayer 图层去配置一个view</li>
<li>创建一个 AVPlayer 对象</li>
<li>为 file-based asset 创建一个 AVPlayerItem 对象，并使用KVO观察其status值</li>
<li>监听资源是否准备好播放，同步改变播放按钮的可用状态。</li>
<li>播放item，然后将播放头恢复到开头位置。</li>
</ul>
<blockquote>
<p>提示: 为了展示核心代码, 这份示例省略了某些内容, 比如内存管理和通知的移除等. 使用 AV Foundation 之前, 你最好已经拥有 Cocoa 框架的使用经验.</p>
</blockquote>
<h3 id="step1-定义-Player-View"><a href="#step1-定义-Player-View" class="headerlink" title="step1: 定义 Player View"></a>step1: 定义 Player View</h3><p>要播放一个 asset 的可视部分, 你需要一个包含<code>AVPlayerLayer</code>对象的 view, 用来接收<code>AVPlayer</code>对象的输出. 可以简单的定义一个 UIView 的子类来实现这一功能：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;UIKit/UIKit.h&gt;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;AVFoundation/AVFoundation.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerView</span> : <span class="title">UIView</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">AVPlayer</span> *player;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">PlayerView</span></span></span><br><span class="line">+ (Class)layerClass &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">AVPlayerLayer</span> <span class="keyword">class</span>];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="built_in">AVPlayer</span>*)player &#123;</span><br><span class="line">    <span class="keyword">return</span> [(<span class="built_in">AVPlayerLayer</span> *)[<span class="keyword">self</span> layer] player];</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)setPlayer:(<span class="built_in">AVPlayer</span> *)player &#123;</span><br><span class="line">    [(<span class="built_in">AVPlayerLayer</span> *)[<span class="keyword">self</span> layer] setPlayer:player];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="step2-配置-View-Controller"><a href="#step2-配置-View-Controller" class="headerlink" title="step2: 配置 View Controller"></a>step2: 配置 View Controller</h3><p>假设你有一个简单的视图控制器，声明如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">PlayerView</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PlayerViewController</span> : <span class="title">UIViewController</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">AVPlayer</span> *player;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">AVPlayerItem</span> *playerItem;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> PlayerView *playerView;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">IBOutlet</span> <span class="built_in">UIButton</span> *playButton;</span><br><span class="line">- (<span class="keyword">IBAction</span>)loadAssetFromFile:sender;</span><br><span class="line">- (<span class="keyword">IBAction</span>)play:sender;</span><br><span class="line">- (<span class="keyword">void</span>)syncUI;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>syncUI 方法将按钮的状态与播放器的状态同步：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)syncUI &#123;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.player.currentItem != <span class="literal">nil</span>) &amp;&amp;</span><br><span class="line">        ([<span class="keyword">self</span>.player.currentItem status] == <span class="built_in">AVPlayerItemStatusReadyToPlay</span>)) &#123;</span><br><span class="line">        <span class="keyword">self</span>.playButton.enabled = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.playButton.enabled = <span class="literal">NO</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以在 viewDidLoad 方法中就调用 syncUI 以确保在首次显示视图时用户界面一致。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    [<span class="keyword">self</span> syncUI];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="step3-创建-Asset、PlayerItem、Player"><a href="#step3-创建-Asset、PlayerItem、Player" class="headerlink" title="step3: 创建 Asset、PlayerItem、Player"></a>step3: 创建 Asset、PlayerItem、Player</h3><p>使用<code>AVURLAsset</code>根据 URL 创建 asset.(下面的代码假设项目中包含了一个视频资源)</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)loadAssetFromFile:sender &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSURL</span> *fileURL = [[<span class="built_in">NSBundle</span> mainBundle]</span><br><span class="line">        URLForResource:&lt;#<span class="string">@&quot;VideoFileName&quot;</span>#&gt; withExtension:&lt;#<span class="string">@&quot;extension&quot;</span>#&gt;];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">AVURLAsset</span> *asset = [<span class="built_in">AVURLAsset</span> URLAssetWithURL:fileURL options:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">NSString</span> *tracksKey = <span class="string">@&quot;tracks&quot;</span>;</span><br><span class="line"></span><br><span class="line">    [asset loadValuesAsynchronouslyForKeys:@[tracksKey] completionHandler:</span><br><span class="line">     ^&#123;</span><br><span class="line">         <span class="comment">// The completion block goes here.</span></span><br><span class="line">     &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 completion block 中创建 <code>AVPlayerItem</code>，并将其设置为 player view 的 player。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Define this constant for the key-value observation context.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *ItemStatusContext;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Completion handler block.</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),</span><br><span class="line">  ^&#123;</span><br><span class="line">      <span class="built_in">NSError</span> *error;</span><br><span class="line">      <span class="built_in">AVKeyValueStatus</span> status = [asset statusOfValueForKey:tracksKey error:&amp;error];</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (status == <span class="built_in">AVKeyValueStatusLoaded</span>) &#123;</span><br><span class="line">          <span class="keyword">self</span>.playerItem = [<span class="built_in">AVPlayerItem</span> playerItemWithAsset:asset];</span><br><span class="line">          <span class="comment">// 与创建asset一样，简单地创建PlayerItem并不意味着它可以使用。要确定它何时可以播放，需要观察其status属性。</span></span><br><span class="line">          <span class="comment">// 在 playerItem 与 player 完成关联之前，配置此监听</span></span><br><span class="line">          [<span class="keyword">self</span>.playerItem addObserver:<span class="keyword">self</span> forKeyPath:<span class="string">@&quot;status&quot;</span> </span><br><span class="line">                               options:<span class="built_in">NSKeyValueObservingOptionInitial</span></span><br><span class="line">                               context:&amp;ItemStatusContext];</span><br><span class="line">          [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></span><br><span class="line">                                   selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">                                       name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">                                     object:<span class="keyword">self</span>.playerItem];</span><br><span class="line">          <span class="comment">// 将 playerItem 与 player 完成关联时，会触发 playerItem 的播放准备。</span></span><br><span class="line">          <span class="keyword">self</span>.player = [<span class="built_in">AVPlayer</span> playerWithPlayerItem:<span class="keyword">self</span>.playerItem];</span><br><span class="line">          [<span class="keyword">self</span>.playerView setPlayer:<span class="keyword">self</span>.player];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// You should deal with the error appropriately.</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;The asset&#x27;s tracks were not loaded:\n%@&quot;</span>, [error localizedDescription]);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="step4-响应-PlayerItem-的-status-改变"><a href="#step4-响应-PlayerItem-的-status-改变" class="headerlink" title="step4: 响应 PlayerItem 的 status 改变"></a>step4: 响应 PlayerItem 的 status 改变</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)observeValueForKeyPath:(<span class="built_in">NSString</span> *)keyPath ofObject:(<span class="keyword">id</span>)object</span><br><span class="line">                        change:(<span class="built_in">NSDictionary</span> *)change context:(<span class="keyword">void</span> *)context &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (context == &amp;ItemStatusContext) &#123;</span><br><span class="line">        <span class="comment">// 保证在主线程上调用了UI操作代码</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),</span><br><span class="line">                       ^&#123;</span><br><span class="line">                           [<span class="keyword">self</span> syncUI];</span><br><span class="line">                       &#125;);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    [<span class="keyword">super</span> observeValueForKeyPath:keyPath ofObject:object</span><br><span class="line">           change:change context:context];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="step5-播放-Item"><a href="#step5-播放-Item" class="headerlink" title="step5: 播放 Item"></a>step5: 播放 Item</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">IBAction</span>)play:sender &#123;</span><br><span class="line">    [player play];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>item 只被播放一次，播放结束后，播放点会被设置为 item 的结束点，这样下一次调用 play 方法将会失效。要将播放点设置到 item 的起始处，参考如下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Register with the notification center after creating the player item.</span></span><br><span class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter]</span><br><span class="line">        addObserver:<span class="keyword">self</span></span><br><span class="line">        selector:<span class="keyword">@selector</span>(playerItemDidReachEnd:)</span><br><span class="line">        name:<span class="built_in">AVPlayerItemDidPlayToEndTimeNotification</span></span><br><span class="line">        object:[<span class="keyword">self</span>.player currentItem]];</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)playerItemDidReachEnd:(<span class="built_in">NSNotification</span> *)notification &#123;</span><br><span class="line">    [<span class="keyword">self</span>.player seekToTime:kCMTimeZero];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="三、编辑-Assets"><a href="#三、编辑-Assets" class="headerlink" title="三、编辑 Assets"></a>三、编辑 Assets</h1><p>AVFoundation 框架为音视频编辑提供了功能丰富的类集。</p>
<p>这些 API 的核心称为合成/组合 (compositions)。composition 是一个或多个媒体资源的 track 的集合。</p>
<ul>
<li>从现有媒体片段<ul>
<li>使用 compositions(组合) 从现有的媒体片段（通常是一个或多个视频和音频轨道）创建新的asset。</li>
<li>使用可变的 composition 来添加和删除轨道，并调整它们的时间顺序。</li>
<li>可以设置音轨的相对音量和渐变效果；并设置视频轨道的透明度和透明度渐变。</li>
<li>composition 是保存在内存中的一系列媒体片段的集合。可以通过 <em>export session</em> 将 composition 导出到文件中。</li>
</ul>
</li>
<li>从样本缓冲区或静止图像<ul>
<li>使用资产写入器(asset writer)从样本缓冲区或静止图像等媒体创建asset。</li>
</ul>
</li>
</ul>
<h2 id="3-1-Asset合成-AVMutableComposition"><a href="#3-1-Asset合成-AVMutableComposition" class="headerlink" title="3.1 Asset合成(AVMutableComposition)"></a>3.1 Asset合成(AVMutableComposition)</h2><h3 id="核心类概述"><a href="#核心类概述" class="headerlink" title="核心类概述"></a>核心类概述</h3><p>AVMutableComposition 类提供了插入和删除 track，以及管理其时间顺序的的接口。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> : <span class="title">AVComposition</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *tracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CGSize</span> naturalSize;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)composition;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)compositionWithURLAssetInitializationOptions:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)URLAssetInitializationOptions;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">//composition层面的编辑，管理时间顺序</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> (<span class="title">AVMutableCompositionCompositionLevelEditing</span>)</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)insertTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange ofAsset:(<span class="built_in">AVAsset</span> *)asset atTime:(<span class="built_in">CMTime</span>)startTime error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">void</span>)insertEmptyTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)removeTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)scaleTimeRange:(<span class="built_in">CMTimeRange</span>)timeRange toDuration:(<span class="built_in">CMTime</span>)duration;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Track层面的编辑</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> (<span class="title">AVMutableCompositionTrackLevelEditing</span>)</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 向composition中添加一个新track时，必须同时提供媒体类型 (media type) 和 track ID。</span></span><br><span class="line"><span class="comment"> * @param mediaType 除了最常用的音频和视频类型，还有其他的媒体类型可以选择。比如 AVMediaTypeSubtitle(字幕)，AVMediaTypeText。</span></span><br><span class="line"><span class="comment"> * @param preferredTrackID 每个 track 都会有一个唯一的标识符 track ID(32位整数值)</span></span><br><span class="line"><span class="comment">                           如果指定 kCMPersistentTrackID_Invalid 作为 track ID，则会自动为关联的 track 自动生成一个唯一的 ID。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">AVMutableCompositionTrack</span> *)addMutableTrackWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType preferredTrackID:(<span class="built_in">CMPersistentTrackID</span>)preferredTrackID;</span><br><span class="line">- (<span class="keyword">void</span>)removeTrack:(<span class="built_in">AVCompositionTrack</span> *)track;</span><br><span class="line">- (<span class="built_in">AVMutableCompositionTrack</span> *)mutableTrackCompatibleWithTrack:(<span class="built_in">AVAssetTrack</span> *)track;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Track检查</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableComposition</span> (<span class="title">AVMutableCompositionTrackInspection</span>)</span></span><br><span class="line">- (<span class="built_in">AVMutableCompositionTrack</span> *)trackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID;</span><br><span class="line">- (<span class="keyword">void</span>)loadTrackWithTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVMutableCompositionTrack</span> *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *)tracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *)tracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic;</span><br><span class="line">- (<span class="keyword">void</span>)loadTracksWithMediaCharacteristic:(<span class="built_in">AVMediaCharacteristic</span>)mediaCharacteristic completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVMutableCompositionTrack</span> *&gt; *, <span class="built_in">NSError</span> *))completionHandler;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>下图展示了如何通过已存在的 assets 组合成为一个 composition。</p>
<img src="/images/avf/avmutablecomposition_2x.png" alt="avmutablecomposition_2x" style="zoom:70%;" />

<h3 id="3-1-1-创建AVMutableComposition"><a href="#3-1-1-创建AVMutableComposition" class="headerlink" title="3.1.1 创建AVMutableComposition"></a>3.1.1 创建AVMutableComposition</h3><p>先使用 AVMutableComposition 类创建一个自定义的 Composition。</p>
<h3 id="3-1-2-添加AVMutableCompositionTrack"><a href="#3-1-2-添加AVMutableCompositionTrack" class="headerlink" title="3.1.2 添加AVMutableCompositionTrack"></a>3.1.2 添加AVMutableCompositionTrack</h3><p>然后如果要向组合中添加媒体数据，那么需要先使用 AVMutableCompositionTrack 类在自定义的 Composition 中添加一个或多个 composition tracks。</p>
<p>下面是一个通过 video track 和 audio track 创建 composition 的例子:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableComposition</span> *mutableComposition = [<span class="built_in">AVMutableComposition</span> composition];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the video composition track.</span></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *mutableCompositionVideoTrack = [mutableComposition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the audio composition track.</span></span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *mutableCompositionAudioTrack = [mutableComposition addMutableTrackWithMediaType:<span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-向composition-track中添加AVAssetTrack"><a href="#3-1-3-向composition-track中添加AVAssetTrack" class="headerlink" title="3.1.3 向composition track中添加AVAssetTrack"></a>3.1.3 向composition track中添加AVAssetTrack</h3><h4 id="1-添加媒体数据"><a href="#1-添加媒体数据" class="headerlink" title="1. 添加媒体数据"></a>1. 添加媒体数据</h4><p>当配置好一个包含一个或多个track的composition时，就可以开始将媒体数据添加到合适的track中。</p>
<p>首先，需要访问媒体数据所在的<code>AVAsset</code>对象。将具有相同媒体类型的多个 track 添加到同一个 mutable composition track 中。</p>
<p>下面的例子说明了如何将两个不同的 video asset tracks 顺序添加到一个 composition track 中:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可以从许多地方检索 AVAsset，例如相机胶卷</span></span><br><span class="line"><span class="built_in">AVAsset</span> *videoAsset = &lt;#<span class="built_in">AVAsset</span> with at least one video track#&gt;;</span><br><span class="line"><span class="built_in">AVAsset</span> *anotherVideoAsset = &lt;<span class="meta">#another AVAsset with at least one video track#&gt;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从每个 asset 中获取第一个视频轨道</span></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *videoAssetTrack = [[videoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *anotherVideoAssetTrack = [[anotherVideoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add them both to the composition.</span></span><br><span class="line">[mutableCompositionVideoTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero,videoAssetTrack.timeRange.duration) ofTrack:videoAssetTrack atTime:kCMTimeZero error:<span class="literal">nil</span>];</span><br><span class="line"></span><br><span class="line">[mutableCompositionVideoTrack insertTimeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero,anotherVideoAssetTrack.timeRange.duration) ofTrack:anotherVideoAssetTrack atTime:videoAssetTrack.timeRange.duration error:<span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<h4 id="2-检索兼容的-Composition-Tracks"><a href="#2-检索兼容的-Composition-Tracks" class="headerlink" title="2. 检索兼容的 Composition Tracks"></a>2. 检索兼容的 Composition Tracks</h4><p>如果可能的情况下，每种媒体类型都应当只有一个对之对应的 composition track，这样会降低资源的使用。当串行呈现媒体数据时，应当将相同类型的媒体数据放到同一个 composition track 中。</p>
<p>可以通过查询一个 mutable composition，找出是否有与 asset track 对应的 composition track.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *compatibleCompositionTrack = [mutableComposition mutableTrackCompatibleWithTrack:&lt;<span class="meta">#the AVAssetTrack you want to insert#&gt;];</span></span><br><span class="line"><span class="keyword">if</span> (compatibleCompositionTrack) &#123;</span><br><span class="line">    <span class="comment">// Implementation continues.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: 在同一个 composition track 添加多个视频段，可能会导致视频段之间进行切换时掉帧，嵌入式设备尤其明显。如何为 composition track 选择合适数量的视频段取决于 App 的设计以及其目标设备。</p>
</blockquote>
<h3 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4 小结"></a>3.1.4 小结</h3><p>如果你需要顺序合并多个 asset 到一个文件中，上面的内容就已经够用了。但是如果要对合成中的 track 执行任何自定义的音视频处理操作，那么你需要分别进行音频混合、视频组合。</p>
<h2 id="3-2-音频混合-AVMutableAudioMix"><a href="#3-2-音频混合-AVMutableAudioMix" class="headerlink" title="3.2 音频混合(AVMutableAudioMix)"></a>3.2 音频混合(AVMutableAudioMix)</h2><h3 id="3-2-1-核心类概述"><a href="#3-2-1-核心类概述" class="headerlink" title="3.2.1 核心类概述"></a>3.2.1 核心类概述</h3><p>如下图(performs audio mixing)中所示，使用 AVMutableAudioMix 类可以对 composition 中的 audio track 进行自定义操作。你还可以指定 audio track 的最大音量或者为其设置渐变效果。</p>
<img src="/images/avf/avmutableaudiomix_2x.png" alt="avmutableaudiomix_2x" style="zoom:70%;" />

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAudioMix</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAudioMixInputParameters</span> *&gt; *inputParameters;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableAudioMix</span> : <span class="title">AVAudioMix</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)audioMix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAudioMixInputParameters</span> *&gt; *inputParameters;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAudioMixInputParameters</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) MTAudioProcessingTapRef audioTapProcessor;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getVolumeRampForTime:(<span class="built_in">CMTime</span>)time startVolume:(<span class="keyword">float</span> *)startVolume endVolume:(<span class="keyword">float</span> *)endVolume timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableAudioMixInputParameters</span> : <span class="title">AVAudioMixInputParameters</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)audioMixInputParametersWithTrack:(<span class="built_in">AVAssetTrack</span> *)track;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)audioMixInputParameters;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) MTAudioProcessingTapRef audioTapProcessor;</span><br><span class="line">- (<span class="keyword">void</span>)setVolumeRampFromStartVolume:(<span class="keyword">float</span>)startVolume toEndVolume:(<span class="keyword">float</span>)endVolume timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setVolume:(<span class="keyword">float</span>)volume atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-示例-自定义音频处理-—-音量渐变"><a href="#3-2-2-示例-自定义音频处理-—-音量渐变" class="headerlink" title="3.2.2 示例: 自定义音频处理 — 音量渐变"></a>3.2.2 示例: 自定义音频处理 — 音量渐变</h3><p>使用一个<code>AVMutableAudioMix</code>对象就可以为 composition 中的每一个 audio tracks 单独执行自定义的音频处理操作。</p>
<p>下面的例子展示了如何给一个 audio track 设置音量渐变让声音有一个缓慢淡出结束的效果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过类方法 audioMix 创建一个 audio mix</span></span><br><span class="line"><span class="built_in">AVMutableAudioMix</span> *mutableAudioMix = [<span class="built_in">AVMutableAudioMix</span> audioMix];</span><br><span class="line"><span class="comment">// 使用AVMutableAudioMixInputParameters设置 将音轨添加到混音时使用的参数。</span></span><br><span class="line"><span class="built_in">AVMutableAudioMixInputParameters</span> *mixParameters = [<span class="built_in">AVMutableAudioMixInputParameters</span> audioMixInputParametersWithTrack:mutableCompositionAudioTrack];</span><br><span class="line"><span class="comment">// 修改音量 Set the volume ramp, 使声音有一个缓慢淡出效果</span></span><br><span class="line">[mixParameters setVolumeRampFromStartVolume:<span class="number">1.</span>f toEndVolume:<span class="number">0.</span>f timeRange:<span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, mutableComposition.duration)];</span><br><span class="line"><span class="comment">// Attach the input parameters to the audio mix. </span></span><br><span class="line">mutableAudioMix.inputParameters = @[mixParameters];</span><br></pre></td></tr></table></figure>

<p>AVMutableAudioMixInputParameters 类的接口将 audio mix 与 composition 中特定的 track 关联起来</p>
<h2 id="3-3-视频合成-AVMutableVideoComposition"><a href="#3-3-视频合成-AVMutableVideoComposition" class="headerlink" title="3.3 视频合成(AVMutableVideoComposition)"></a>3.3 视频合成(AVMutableVideoComposition)</h2><h3 id="3-3-1-核心类概述"><a href="#3-3-1-核心类概述" class="headerlink" title="3.3.1 核心类概述"></a>3.3.1 核心类概述</h3><h4 id="1-类图"><a href="#1-类图" class="headerlink" title="1. 类图"></a>1. 类图</h4><p>如下图所示，使用 AVMutableVideoComposition 类可以直接处理合成中的视频 track。</p>
<ul>
<li>从一个 video composition 输出视频时，可以指定输出的尺寸、缩放比例、帧率。</li>
<li>AVMutableVideoCompositionInstruction (视频合成指令)，可以修改视频背景色、设置 layer 的 instructions。<ul>
<li>AVMutableVideoCompositionLayerInstruction (视频合成图层指令) 可以对合成中的 video track 实现transform、渐变transform、透明度、透明度渐变等效果。</li>
</ul>
</li>
<li>Video composition类还允许通过 <code>animationTool</code> 属性在视频中应用 Core Animation 框架的一些效果。</li>
</ul>
<img src="/images/avf/avmutablevideocomposition_2x.png" alt="avmutablevideocomposition_2x" style="zoom:70%;" />

<h4 id="2-视频合成类"><a href="#2-视频合成类" class="headerlink" title="2. 视频合成类"></a>2. 视频合成类</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoComposition</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt; </span></span><br><span class="line">+ (<span class="built_in">AVVideoComposition</span> *)videoCompositionWithPropertiesOfAsset:(<span class="built_in">AVAsset</span> *)asset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) Class&lt;<span class="built_in">AVVideoCompositing</span>&gt; customVideoCompositorClass;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> frameDuration;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMPersistentTrackID</span> sourceTrackIDForFrameTiming;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGSize</span> renderSize;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> renderScale;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="keyword">id</span> &lt;<span class="built_in">AVVideoCompositionInstruction</span>&gt;&gt; *instructions;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">retain</span>) <span class="built_in">AVVideoCompositionCoreAnimationTool</span> *animationTool;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *sourceSampleDataTrackIDs;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出帧的颜色空间</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoComposition</span> (<span class="title">AVVideoCompositionColorimetery</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *colorPrimaries;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *colorYCbCrMatrix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *colorTransferFunction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将core Image filters(滤镜)应用于指定asset的每个视频帧</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoComposition</span> (<span class="title">AVVideoCompositionFiltering</span>)</span></span><br><span class="line">+ (<span class="built_in">AVVideoComposition</span> *)videoCompositionWithAsset:(<span class="built_in">AVAsset</span> *)asset</span><br><span class="line">			               applyingCIFiltersWithHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAsynchronousCIImageFilteringRequest</span> *request))applier;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoComposition</span> : <span class="title">AVVideoComposition</span></span></span><br><span class="line">  <span class="comment">//.... 继承AVVideoComposition的所有属性</span></span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoComposition;</span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoCompositionWithPropertiesOfAsset:(<span class="built_in">AVAsset</span> *)asset;</span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoCompositionWithPropertiesOfAsset:(<span class="built_in">AVAsset</span> *)asset prototypeInstruction:(<span class="built_in">AVVideoCompositionInstruction</span> *)prototypeInstruction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoComposition</span> (<span class="title">AVMutableVideoCompositionColorimetery</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *colorPrimaries;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *colorYCbCrMatrix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">nullable</span>) <span class="built_in">NSString</span> *colorTransferFunction;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoComposition</span> (<span class="title">AVMutableVideoCompositionFiltering</span>)</span></span><br><span class="line">+ (<span class="built_in">AVMutableVideoComposition</span> *)videoCompositionWithAsset:(<span class="built_in">AVAsset</span> *)asset</span><br><span class="line">			 applyingCIFiltersWithHandler:(<span class="keyword">void</span> (^)(<span class="built_in">AVAsynchronousCIImageFilteringRequest</span> *request))applier;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="3-视频合成指令类"><a href="#3-视频合成指令类" class="headerlink" title="3. 视频合成指令类"></a>3. 视频合成指令类</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoCompositionInstruction</span> : <span class="title">AVVideoCompositionInstruction</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionInstruction;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CMTimeRange</span> timeRange;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">nullable</span>)<span class="built_in">CGColorRef</span> backgroundColor;</span><br><span class="line"><span class="comment">// 指定如何从源tracks分层、合成视频帧的指令。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCompositionLayerInstruction</span> *&gt; *layerInstructions;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">BOOL</span> enablePostProcessing;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *requiredSourceSampleDataTrackIDs;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoCompositionLayerInstruction</span> : <span class="title">NSObject</span> &lt;<span class="title">NSSecureCoding</span>, <span class="title">NSCopying</span>, <span class="title">NSMutableCopying</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getTransformRampForTime:(<span class="built_in">CMTime</span>)time startTransform:(<span class="built_in">CGAffineTransform</span> *)startTransform endTransform:(<span class="built_in">CGAffineTransform</span> *)endTransform timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getOpacityRampForTime:(<span class="built_in">CMTime</span>)time startOpacity:(<span class="keyword">float</span> *)startOpacity endOpacity:(<span class="keyword">float</span> *)endOpacity timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line">- (<span class="built_in">BOOL</span>)getCropRectangleRampForTime:(<span class="built_in">CMTime</span>)time startCropRectangle:(<span class="built_in">CGRect</span> *)startCropRectangle endCropRectangle:(<span class="built_in">CGRect</span> *)endCropRectangle timeRange:(<span class="built_in">CMTimeRange</span> *)timeRange;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置transform、opacity等属性</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVMutableVideoCompositionLayerInstruction</span> : <span class="title">AVVideoCompositionLayerInstruction</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionLayerInstructionWithAssetTrack:(<span class="built_in">AVAssetTrack</span> *)track;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionLayerInstruction;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">CMPersistentTrackID</span> trackID;</span><br><span class="line">- (<span class="keyword">void</span>)setTransformRampFromStartTransform:(<span class="built_in">CGAffineTransform</span>)startTransform toEndTransform:(<span class="built_in">CGAffineTransform</span>)endTransform timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setTransform:(<span class="built_in">CGAffineTransform</span>)transform atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line">- (<span class="keyword">void</span>)setOpacityRampFromStartOpacity:(<span class="keyword">float</span>)startOpacity toEndOpacity:(<span class="keyword">float</span>)endOpacity timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setOpacity:(<span class="keyword">float</span>)opacity atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line">- (<span class="keyword">void</span>)setCropRectangleRampFromStartCropRectangle:(<span class="built_in">CGRect</span>)startCropRectangle toEndCropRectangle:(<span class="built_in">CGRect</span>)endCropRectangle timeRange:(<span class="built_in">CMTimeRange</span>)timeRange;</span><br><span class="line">- (<span class="keyword">void</span>)setCropRectangle:(<span class="built_in">CGRect</span>)cropRectangle atTime:(<span class="built_in">CMTime</span>)time;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h4 id="4-核心动画工具"><a href="#4-核心动画工具" class="headerlink" title="4. 核心动画工具"></a>4. 核心动画工具</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVVideoCompositionCoreAnimationTool</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionCoreAnimationToolWithAdditionalLayer:(<span class="built_in">CALayer</span> *)layer asTrackID:(<span class="built_in">CMPersistentTrackID</span>)trackID;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:(<span class="built_in">CALayer</span> *)videoLayer inLayer:(<span class="built_in">CALayer</span> *)animationLayer;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayers:(<span class="built_in">NSArray</span>&lt;<span class="built_in">CALayer</span> *&gt; *)videoLayers inLayer:(<span class="built_in">CALayer</span> *)animationLayer;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-示例-自定义视频处理"><a href="#3-3-2-示例-自定义视频处理" class="headerlink" title="3.3.2 示例: 自定义视频处理"></a>3.3.2 示例: 自定义视频处理</h3><p>与音频混合一样，可以使用 <code>AVMutableVideoComposition</code> 对象可以对 composition 中的 video tracks 执行所有自定义处理操作。比如指定尺寸、缩放比例、以及帧率。</p>
<h4 id="1-设置-Composition-的背景色"><a href="#1-设置-Composition-的背景色" class="headerlink" title="1. 设置 Composition 的背景色"></a>1. 设置 Composition 的背景色</h4><p>Video compositions 必须包含一个 AVVideoCompositionInstruction 对象的数组，其中至少包含一个 video composition instruction。</p>
<p>使用 AVMutableVideoCompositionInstruction 可以创建自定义的视频合成指令(video composition instructions)。使用视频合成指令，来修改composition的背景颜色、指定是否需要后期处理、设置图层的指令等。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *mutableVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line">mutableVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, mutableComposition.duration);</span><br><span class="line">mutableVideoCompositionInstruction.backgroundColor = [[<span class="built_in">UIColor</span> redColor] <span class="built_in">CGColor</span>];</span><br></pre></td></tr></table></figure>

<h4 id="2-设置-track-切换时的透明度渐变"><a href="#2-设置-track-切换时的透明度渐变" class="headerlink" title="2. 设置 track 切换时的透明度渐变"></a>2. 设置 track 切换时的透明度渐变</h4><p>AVMutableVideoCompositionLayerInstruction 可以用来设置 video track 的 transforms、transforms 渐变、opacity、opacity 渐变。</p>
<p>AVMutableVideoCompositionInstruction 的属性 layerInstructions 中指令的顺序，决定了在该合成指令的持续时间内，应如何对来自源 track 的视频帧进行分层和合成。</p>
<p>下面的代码片段展示了如何在第二个视频出现之前为第一个视频增加一个透明度淡出效果:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *firstVideoAssetTrack  = &lt;#<span class="built_in">AVAssetTrack</span> representing the first video segment played <span class="keyword">in</span> the composition#&gt;;</span><br><span class="line"><span class="built_in">AVAsset</span> *secondVideoAssetTrack = &lt;#<span class="built_in">AVAssetTrack</span> representing the second video segment played <span class="keyword">in</span> the composition#&gt;;</span><br><span class="line"><span class="comment">// 创建第一个视频合成指令</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *firstVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 将timeRange设置为跨越第一个视频track的持续时间</span></span><br><span class="line">firstVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第一个图层指令，然后与视频track，相关联</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *firstVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack: mutableCompositionVideoTrack];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不透明度渐变以在整个持续时间内淡出第一个视频轨道。</span></span><br><span class="line">[firstVideoLayerInstruction setOpacityRampFromStartOpacity:<span class="number">1.</span>f toEndOpacity:<span class="number">0.</span>f timeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二个视频合成指令，使第二个视频轨道不透明</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *secondVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 将其时间范围设置为跨越第二个视频轨道的持续时间。</span></span><br><span class="line">secondVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(firstVideoAssetTrack.timeRange.duration, <span class="built_in">CMTimeAdd</span>(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));</span><br><span class="line"><span class="comment">// 创建第二个图层指令并将其与视频track相关联。</span></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *secondVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack:mutableCompositionVideoTrack];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach the first layer instruction to the first video composition instruction.</span></span><br><span class="line">firstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];</span><br><span class="line"><span class="comment">// Attach the second layer instruction to the second video composition instruction.</span></span><br><span class="line">secondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Attach both of the video composition instructions to the video composition.</span></span><br><span class="line"><span class="built_in">AVMutableVideoComposition</span> *mutableVideoComposition = [<span class="built_in">AVMutableVideoComposition</span> videoComposition];</span><br><span class="line">mutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];</span><br></pre></td></tr></table></figure>

<h4 id="3-结合-Core-Animation"><a href="#3-结合-Core-Animation" class="headerlink" title="3. 结合 Core Animation"></a>3. 结合 Core Animation</h4><p>Video composition 的 animationTool 属性可以在 composition 中展示 Core Animation 框架的强大能力，例如视频水印、视频标题、动画遮罩等。</p>
<p>在 Video compositions 中 Core Animatio 有两种不同的使用方式：</p>
<ul>
<li>添加一个 Core Animation layer 作为独立的 composition track；</li>
<li>使用 Core Animation layer 将核心动画的效果直接渲染到视频帧中。</li>
</ul>
<p>下面的代码展示了后面一种使用方式，在视频区域的中心添加水印：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CALayer</span> *watermarkLayer = &lt;#<span class="built_in">CALayer</span> representing your desired watermark image#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CALayer</span> *parentLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line"><span class="built_in">CALayer</span> *videoLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">parentLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);</span><br><span class="line">videoLayer.frame = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, mutableVideoComposition.renderSize.width, mutableVideoComposition.renderSize.height);</span><br><span class="line">[parentLayer addSublayer:videoLayer];</span><br><span class="line"></span><br><span class="line">watermarkLayer.position = <span class="built_in">CGPointMake</span>(mutableVideoComposition.renderSize.width/<span class="number">2</span>, mutableVideoComposition.renderSize.height/<span class="number">4</span>);</span><br><span class="line">[parentLayer addSublayer:watermarkLayer];</span><br><span class="line"></span><br><span class="line">mutableVideoComposition.animationTool = [<span class="built_in">AVVideoCompositionCoreAnimationTool</span> videoCompositionCoreAnimationToolWithPostProcessingAsVideoLayer:videoLayer inLayer:parentLayer];</span><br></pre></td></tr></table></figure>

<h2 id="3-4-音视频组合-AVAssetExportSession"><a href="#3-4-音视频组合-AVAssetExportSession" class="headerlink" title="3.4 音视频组合(AVAssetExportSession)"></a>3.4 音视频组合(AVAssetExportSession)</h2><p>如下图所示，要对音视频进行组合，可以使用 AVAssetExportSession。使用 composition 初始化一个 export session，然后分别其设置 <code>audioMix</code> 和 <code>videoComposition</code> 属性。</p>
<img src="/images/avf/puttingitalltogether_2x.png" style="zoom:70%;" />

<h2 id="3-5-示例-多个asset的合成与导出"><a href="#3-5-示例-多个asset的合成与导出" class="headerlink" title="3.5 示例: 多个asset的合成与导出"></a>3.5 示例: 多个asset的合成与导出</h2><p>下面的代码简要的展示了如何合并两个 video asset tracks 和一个 audio asset track 为一个视频文件。 包括:</p>
<ul>
<li>创建 AVMutableComposition 对象, 并添加多个 AVMutableCompositionTrack 对象</li>
<li>在 composition tracks 中添加 AVAssetTrack 对象的时间范围</li>
<li>检查 video asset track 的 preferredTransform 属性，判断视频方向</li>
<li>使用 AVMutableVideoCompositionLayerInstruction 对象进行 transform 变换</li>
<li>设置 video composition 的 renderSize 和 frameDuration 属性</li>
<li>导出视频文件</li>
<li>保存视频文件到相册</li>
</ul>
<blockquote>
<p>提示：为了展示核心代码，这份示例省略了某些内容，比如内存管理和通知的移除等。使用 AV Foundation 之前，你最好已经拥有 Cocoa 框架的使用经验。</p>
</blockquote>
<h3 id="1-创建-Composition"><a href="#1-创建-Composition" class="headerlink" title="1. 创建 Composition"></a>1. 创建 Composition</h3><p>使用<code>AVMutableComposition</code>对象组合多个 assets 中的 tracks。下面的代码创建了一个 composition，并向其添加了一个 audio track 和一个 video track。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableComposition</span> *mutableComposition = [<span class="built_in">AVMutableComposition</span> composition];</span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *videoCompositionTrack = [mutableComposition addMutableTrackWithMediaType: <span class="built_in">AVMediaTypeVideo</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br><span class="line"><span class="built_in">AVMutableCompositionTrack</span> *audioCompositionTrack = [mutableComposition addMutableTrackWithMediaType: <span class="built_in">AVMediaTypeAudio</span> preferredTrackID:kCMPersistentTrackID_Invalid];</span><br></pre></td></tr></table></figure>

<h3 id="2-添加-Assets"><a href="#2-添加-Assets" class="headerlink" title="2. 添加 Assets"></a>2. 添加 Assets</h3><p>向 composition 添加两个 video asset tracks 和一个 audio asset track。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAssetTrack</span> *firstVideoAssetTrack = [[firstVideoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *secondVideoAssetTrack = [[secondVideoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line">[videoCompositionTrack insertTimeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration)</span><br><span class="line">                               ofTrack: firstVideoAssetTrack </span><br><span class="line">                                atTime: kCMTimeZero </span><br><span class="line">                                 error: <span class="literal">nil</span>];</span><br><span class="line">[videoCompositionTrack insertTimeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, secondVideoAssetTrack.timeRange.duration) </span><br><span class="line">                               ofTrack: secondVideoAssetTrack </span><br><span class="line">                                atTime: firstVideoAssetTrack.timeRange.duration </span><br><span class="line">                                 error: <span class="literal">nil</span>];</span><br><span class="line">[audioCompositionTrack insertTimeRange: <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, <span class="built_in">CMTimeAdd</span>(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration)) </span><br><span class="line">                               ofTrack: [[audioAsset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] objectAtIndex:<span class="number">0</span>] </span><br><span class="line">                                atTime: kCMTimeZero </span><br><span class="line">                                 error: <span class="literal">nil</span>];</span><br></pre></td></tr></table></figure>

<h3 id="3-判断视频方向"><a href="#3-判断视频方向" class="headerlink" title="3. 判断视频方向"></a>3. 判断视频方向</h3><p>一旦在 composition 中添加了 audio tracks 和 videotracks，必须确保其中所有的 video tracks 的视频方向都是正确的。</p>
<p>默认情况下，video tracks 默认为横屏模式，如果 video track 是在竖屏模式下采集的，那么导出视频时会出现方向错误。同理，也不能将一个横向的视频和一个纵向的视频进行合并后导出。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BOOL</span> isFirstVideoPortrait = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">CGAffineTransform</span> firstTransform = firstVideoAssetTrack.preferredTransform;</span><br><span class="line"><span class="comment">// 对比video track的preferredTransform，判断是否以纵向模式录制。</span></span><br><span class="line"><span class="keyword">if</span> (firstTransform.a == <span class="number">0</span> &amp;&amp; firstTransform.d == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    (firstTransform.b == <span class="number">1.0</span> || firstTransform.b == <span class="number">-1.0</span>) &amp;&amp; </span><br><span class="line">    (firstTransform.c == <span class="number">1.0</span> || firstTransform.c == <span class="number">-1.0</span>)) &#123;</span><br><span class="line">    isFirstVideoPortrait = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">BOOL</span> isSecondVideoPortrait = <span class="literal">NO</span>;</span><br><span class="line"><span class="built_in">CGAffineTransform</span> secondTransform = secondVideoAssetTrack.preferredTransform;</span><br><span class="line"><span class="keyword">if</span> (secondTransform.a == <span class="number">0</span> &amp;&amp; secondTransform.d == <span class="number">0</span> &amp;&amp; </span><br><span class="line">    (secondTransform.b == <span class="number">1.0</span> || secondTransform.b == <span class="number">-1.0</span>) &amp;&amp; </span><br><span class="line">    (secondTransform.c == <span class="number">1.0</span> || secondTransform.c == <span class="number">-1.0</span>)) &#123;</span><br><span class="line">    isSecondVideoPortrait = <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ((isFirstVideoAssetPortrait &amp;&amp; !isSecondVideoAssetPortrait) || </span><br><span class="line">    (!isFirstVideoAssetPortrait &amp;&amp; isSecondVideoAssetPortrait)) &#123;</span><br><span class="line">    <span class="built_in">UIAlertView</span> *incompatibleVideoOrientationAlert = [[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@&quot;Error!&quot;</span> message:<span class="string">@&quot;Cannot combine a video shot in portrait mode with a video shot in landscape mode.&quot;</span> delegate:<span class="keyword">self</span> cancelButtonTitle:<span class="string">@&quot;Dismiss&quot;</span> otherButtonTitles:<span class="literal">nil</span>];</span><br><span class="line">    [incompatibleVideoOrientationAlert show];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的 <code>AVAssetTrack</code> 对象都有一个 <code>preferredTransform</code> 属性，包含了 asset track 的方向信息。这个 transform 会在 asset track 在屏幕上展示时被应用。在下面一节的代码中，会将 layer instruction 的 transform 设置为 asset track 的 transform，这样便于修改了视频尺寸时，新的 composition 中的视频也能正确的进行展示。</p>
<h3 id="4-设置视频合成图层指令"><a href="#4-设置视频合成图层指令" class="headerlink" title="4. 设置视频合成图层指令"></a>4. 设置视频合成图层指令</h3><p>一旦确认了视频方向，就可以对每个视频设置必要的 layer instructions，并将这些 layer instructions 添加到 video composition 中去.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> *firstVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 将第一个图层指令的时间范围设置为跨越第一个视频轨道的持续时间。</span></span><br><span class="line">firstVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(kCMTimeZero, firstVideoAssetTrack.timeRange.duration);</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionInstruction</span> * secondVideoCompositionInstruction = [<span class="built_in">AVMutableVideoCompositionInstruction</span> videoCompositionInstruction];</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line">secondVideoCompositionInstruction.timeRange = <span class="built_in">CMTimeRangeMake</span>(firstVideoAssetTrack.timeRange.duration, <span class="built_in">CMTimeAdd</span>(firstVideoAssetTrack.timeRange.duration, secondVideoAssetTrack.timeRange.duration));</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *firstVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack: videoCompositionTrack];</span><br><span class="line"><span class="comment">// 将第一个video track的首选transform 赋值给 第一个图层指令的transform</span></span><br><span class="line">Set the transform of the first layer instruction to the preferred transform of the first video track.</span><br><span class="line">[firstVideoLayerInstruction setTransform:firstTransform atTime:kCMTimeZero];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableVideoCompositionLayerInstruction</span> *secondVideoLayerInstruction = [<span class="built_in">AVMutableVideoCompositionLayerInstruction</span> videoCompositionLayerInstructionWithAssetTrack: videoCompositionTrack];</span><br><span class="line"><span class="comment">// 同上</span></span><br><span class="line">[secondVideoLayerInstruction setTransform:secondTransform atTime:firstVideoAssetTrack.timeRange.duration];</span><br><span class="line"></span><br><span class="line">firstVideoCompositionInstruction.layerInstructions = @[firstVideoLayerInstruction];</span><br><span class="line">secondVideoCompositionInstruction.layerInstructions = @[secondVideoLayerInstruction];</span><br><span class="line"><span class="built_in">AVMutableVideoComposition</span> *mutableVideoComposition = [<span class="built_in">AVMutableVideoComposition</span> videoComposition];</span><br><span class="line">mutableVideoComposition.instructions = @[firstVideoCompositionInstruction, secondVideoCompositionInstruction];</span><br></pre></td></tr></table></figure>

<h3 id="5-设置渲染尺寸和帧率"><a href="#5-设置渲染尺寸和帧率" class="headerlink" title="5. 设置渲染尺寸和帧率"></a>5. 设置渲染尺寸和帧率</h3><p>要修正视频方向，还必须对 renderSize 属性进行调整。同时也需要设置一个合理的帧持续时间 frameDuration，比如 1/30 秒(30FPS)。默认情况下，renderScale 值为 1.0。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CGSize</span> naturalSizeFirst, naturalSizeSecond;</span><br><span class="line"><span class="comment">// 如果第一个视频资源是在纵向模式下拍摄的，那么如果我们在这里制作第二个视频资源也是如此。</span></span><br><span class="line"><span class="keyword">if</span> (isFirstVideoAssetPortrait) &#123;</span><br><span class="line">    <span class="comment">// 反转video track的宽度和高度以确保它们正确显示。</span></span><br><span class="line">    naturalSizeFirst = <span class="built_in">CGSizeMake</span>(firstVideoAssetTrack.naturalSize.height, firstVideoAssetTrack.naturalSize.width);</span><br><span class="line">    naturalSizeSecond = <span class="built_in">CGSizeMake</span>(secondVideoAssetTrack.naturalSize.height, secondVideoAssetTrack.naturalSize.width);</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果视频不是以纵向模式拍摄的，我们可以使用它们的自然尺寸。</span></span><br><span class="line">    naturalSizeFirst = firstVideoAssetTrack.naturalSize;</span><br><span class="line">    naturalSizeSecond = secondVideoAssetTrack.naturalSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">float</span> renderWidth, renderHeight;</span><br><span class="line"><span class="comment">// 将 renderWidth 和 renderHeight 设置为两个视频宽度和高度的最大值。</span></span><br><span class="line"><span class="keyword">if</span> (naturalSizeFirst.width &gt; naturalSizeSecond.width) &#123;</span><br><span class="line">    renderWidth = naturalSizeFirst.width;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    renderWidth = naturalSizeSecond.width;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (naturalSizeFirst.height &gt; naturalSizeSecond.height) &#123;</span><br><span class="line">    renderHeight = naturalSizeFirst.height;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    renderHeight = naturalSizeSecond.height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mutableVideoComposition.renderSize = <span class="built_in">CGSizeMake</span>(renderWidth, renderHeight);</span><br><span class="line"><span class="comment">// 将帧持续时间设置为适当的值（每秒30帧）</span></span><br><span class="line">mutableVideoComposition.frameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>,<span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<h3 id="6-导出-Composition"><a href="#6-导出-Composition" class="headerlink" title="6. 导出 Composition"></a>6. 导出 Composition</h3><p>最后一步是导出 composition 到一个视频文件中，并将视频文件保存到用户相册中。使用 AVAssetExportSession 创建一个新的视频文件，并指定要输出的文件目录的 URL。使用 ALAssetsLibrary 可以将生成的视频文件保存到用户相册中。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个staic dataFormatter</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">NSDateFormatter</span> *kDateFormatter;</span><br><span class="line"><span class="keyword">if</span> (!kDateFormatter) &#123;</span><br><span class="line">    kDateFormatter = [[<span class="built_in">NSDateFormatter</span> alloc] init];</span><br><span class="line">    kDateFormatter.dateStyle = <span class="built_in">NSDateFormatterMediumStyle</span>;</span><br><span class="line">    kDateFormatter.timeStyle = <span class="built_in">NSDateFormatterShortStyle</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 composition 创建导出会话，并将预设preset设置为最高质量。</span></span><br><span class="line"><span class="built_in">AVAssetExportSession</span> *exporter = [[<span class="built_in">AVAssetExportSession</span> alloc] initWithAsset:mutableComposition presetName:<span class="built_in">AVAssetExportPresetHighestQuality</span>];</span><br><span class="line"><span class="comment">// 设置输出URL</span></span><br><span class="line">exporter.outputURL = [[[[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:@YES error:<span class="literal">nil</span>] URLByAppendingPathComponent:[kDateFormatter stringFromDate:[<span class="built_in">NSDate</span> date]]] URLByAppendingPathExtension:<span class="built_in">CFBridgingRelease</span>(UTTypeCopyPreferredTagWithClass((<span class="built_in">CFStringRef</span>)<span class="built_in">AVFileTypeQuickTimeMovie</span>, kUTTagClassFilenameExtension))];</span><br><span class="line"><span class="comment">// 设置输出文件类型为 QuickTime movie.</span></span><br><span class="line">exporter.outputFileType = <span class="built_in">AVFileTypeQuickTimeMovie</span>;</span><br><span class="line">exporter.shouldOptimizeForNetworkUse = <span class="literal">YES</span>;</span><br><span class="line">exporter.videoComposition = mutableVideoComposition;</span><br><span class="line"><span class="comment">// 异步导出composition到一个视频文件，导出完成后，保存到相机胶卷</span></span><br><span class="line">[exporter exportAsynchronouslyWithCompletionHandler:^&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        <span class="keyword">if</span> (exporter.status == <span class="built_in">AVAssetExportSessionStatusCompleted</span>) &#123;</span><br><span class="line">            ALAssetsLibrary *assetsLibrary = [[ALAssetsLibrary alloc] init];</span><br><span class="line">            <span class="keyword">if</span> ([assetsLibrary videoAtPathIsCompatibleWithSavedPhotosAlbum:exporter.outputURL]) &#123;</span><br><span class="line">                [assetsLibrary writeVideoAtPathToSavedPhotosAlbum:exporter.outputURL completionBlock:<span class="literal">NULL</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h1 id="四、静态图片和视频捕捉"><a href="#四、静态图片和视频捕捉" class="headerlink" title="四、静态图片和视频捕捉"></a>四、静态图片和视频捕捉</h1><h2 id="核心类概述-1"><a href="#核心类概述-1" class="headerlink" title="核心类概述"></a>核心类概述</h2><p>通过输入 (inputs) 和输出 (outputs) 对象对设备 (比如摄像头或麦克风) 采集到的数据进行管理。使用 AVCaptureSession 对象协调 inputs 和 outputs 之间的数据流。</p>
<ul>
<li>AVCaptureDevice 代表输入设备，比如摄像头和麦克风。</li>
<li>AVCaptureInput 的子类用来对输入设备进行配置。</li>
<li>AVCaptureOutput 的子类用来管理输出的数据（输出结果为图片或者视频）。</li>
<li>AVCaptureSession 用来协调 inputs 和 outputs 之间的数据流<ul>
<li>可以为单个session配置多个输入和输出，即使这个会话正在运行时也可以。</li>
<li>可以向会话发送消息以启动和停止数据流。</li>
</ul>
</li>
<li>AVCaptureVideoPreviewLayer预览图层(CALayer 的子类)，可以展示摄像头正在采集的画面预览。</li>
</ul>
<p>对于一个 session，可以配置多个 inputs 和 outputs，如图所示：</p>
<img src="/images/avf/captureOverview_2x.png" alt="captureOverview_2x" style="zoom:70%;" />

<p>对于大部分的应用而言，这已经足够了。但是有些情况下，会涉及到如何表示一个 inputs 的多个端口 (ports)，以及这些 ports 如何连接到 outputs。</p>
<p>Capture session 中：</p>
<ul>
<li>一个 Inputs(AVCaptureInput实例) 包含一个或多个 input ports(AVCaptureInputPort)。比如输入设备可能同时提供音频和视频数据。</li>
<li>一个 Outputs(AVCaptureOutput实例) 可以从一个或多个源接收数据，比如 AVCaptureMovieFileOutput 可以同时接收视频和音频数据。</li>
<li>使用 AVCaptureConnection 对象来定义一组 AVCaptureInputPort 对象和单个 AVCaptureOutput 之间的映射。</li>
</ul>
<p>如下图所示，当在 session 中添加一个 input 或 output 时，session 会为所有可匹配的 inputs 和 outputs 之前生成 connections(AVCaptureConnection)。</p>
<img src="/images/avf/captureDetail_2x.png" alt="captureDetail_2x" style="zoom:70%;" />

<p>可以使用一个 connection 来开启或关闭一个 input 或 output 数据流。也可以使用 connection 监控一个 audio 频道的功率平均值和峰值。</p>
<blockquote>
<p>注意：媒体捕获不支持同时使用呢 iOS 设备上的前置和后置摄像头捕获。</p>
</blockquote>
<h2 id="4-1-使用AVCaptureSession协调数据流"><a href="#4-1-使用AVCaptureSession协调数据流" class="headerlink" title="4.1 使用AVCaptureSession协调数据流"></a>4.1 使用AVCaptureSession协调数据流</h2><p>AVCaptureSession 对象是管理数据捕获的中央协调对象，协调从输入设备到输出的数据流。</p>
<h3 id="4-1-1-AVCaptureSession-类"><a href="#4-1-1-AVCaptureSession-类" class="headerlink" title="4.1.1 AVCaptureSession 类"></a>4.1.1 AVCaptureSession 类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureSession</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">BOOL</span>)canSetSessionPreset:(<span class="built_in">AVCaptureSessionPreset</span>)preset;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVCaptureSessionPreset</span> sessionPreset;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inputs 操作</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">AVCaptureInput</span> *&gt; *inputs; <span class="comment">//__kindof表示可以是当前类或子类</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddInput:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)addInput:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)removeInput:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ouputs 操作</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">AVCaptureOutput</span> *&gt; *outputs;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddOutput:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">void</span>)addOutput:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">void</span>)removeOutput:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)addInputWithNoConnections:(<span class="built_in">AVCaptureInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)addOutputWithNoConnections:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line"></span><br><span class="line"><span class="comment">// connections 操作</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *connections;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)addConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)removeConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置Capture Session</span></span><br><span class="line">- (<span class="keyword">void</span>)beginConfiguration;</span><br><span class="line">- (<span class="keyword">void</span>)commitConfiguration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isRunning) <span class="built_in">BOOL</span> running;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isInterrupted) <span class="built_in">BOOL</span> interrupted;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> usesApplicationAudioSession;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyConfiguresApplicationAudioSession;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyConfiguresCaptureDeviceForWideColor;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)startRunning;</span><br><span class="line">- (<span class="keyword">void</span>)stopRunning;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMClockRef</span> masterClock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>在 session 中添加采集设备并对 output 进行配置之后，可以向 session 发送 startRunning 消息开始采集, 发送 stopRunning 消息停止采集。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line"><span class="comment">// Add inputs and outputs.</span></span><br><span class="line">[session startRunning];</span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-配置-Capture-Session"><a href="#4-1-2-配置-Capture-Session" class="headerlink" title="4.1.2 配置 Capture Session"></a>4.1.2 配置 Capture Session</h3><p>使用 session 的 <code>sessionPreset</code> 属性指定图片质量和分辨率，perset是一个常数，系统定义了多种配置，需注意，有些配置只有在特定设备上才生效。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSessionPresetHigh</span>      <span class="comment">// 最高级别, 最终效果根据设备不同有所差异</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPresetMedium</span>    <span class="comment">// 中等, 适合 Wi-Fi 分享. 最终效果根据设备不同有所差异</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPresetLow</span>       <span class="comment">// 低, 适合 3G 分享, 最终效果根据设备不同有所差异</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPreset640x480</span>   <span class="comment">// 640x480, VGA</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPreset1280x720</span>  <span class="comment">// 1280x720, 720p HD</span></span><br><span class="line"><span class="built_in">AVCaptureSessionPresetPhoto</span>     <span class="comment">// 全屏照片, 不能用来作为输出视频</span></span><br></pre></td></tr></table></figure>

<p>在设置一个 preset 之前，需要判断设备是否支持该 preset 值:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([session canSetSessionPreset:<span class="built_in">AVCaptureSessionPreset1280x720</span>]) &#123;</span><br><span class="line">    session.sessionPreset = <span class="built_in">AVCaptureSessionPreset1280x720</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the failure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果需要设置一个更高分辨率的 preset，或者在 session 运行时修改一些配置，需要在 beginConfiguration 和 commitConfiguration 之间完成修改。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[session beginConfiguration];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Remove an existing capture device.移除一个采集设备</span></span><br><span class="line"><span class="comment">// Add a new capture device.         添加一个采集设备</span></span><br><span class="line"><span class="comment">// Reset the preset.                 修改sessionPreset属性</span></span><br><span class="line"><span class="comment">// 单独配置 input 和 output 的属性</span></span><br><span class="line"></span><br><span class="line">[session commitConfiguration]; <span class="comment">// 在调用commitConfiguration 方法之后，改变会一起生效。</span></span><br></pre></td></tr></table></figure>

<p>beginConfiguration 和 commitConfiguration 方法确保所有的修改作为一个group被整体应用，减少对预览状态的影响。</p>
<h3 id="4-1-3-监听-Capture-Session-的状态"><a href="#4-1-3-监听-Capture-Session-的状态" class="headerlink" title="4.1.3 监听 Capture Session 的状态"></a>4.1.3 监听 Capture Session 的状态</h3><p>可以监听 session 的状态，例如何时开始运行、停止运行、被中断等。</p>
<ul>
<li>当发生运行时错误，会发送 AVCaptureSessionRuntimeErrorNotification 通知。</li>
<li>可以使用Session的<code>running</code>属性判断当前的运行状态，<code>interrupted</code>属性则可以判断当前是否中断。这两者都可以通过 KVO 进行监听，并且通知都在主线程中发送。</li>
</ul>
<h3 id="4-1-4-补充-AVCaptureConnection-类"><a href="#4-1-4-补充-AVCaptureConnection-类" class="headerlink" title="4.1.4 补充: AVCaptureConnection 类"></a>4.1.4 补充: AVCaptureConnection 类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureConnection</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)connectionWithInputPorts:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *)ports output:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)connectionWithInputPort:(<span class="built_in">AVCaptureInputPort</span> *)port videoPreviewLayer:(<span class="built_in">AVCaptureVideoPreviewLayer</span> *)layer;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithInputPorts:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *)ports output:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithInputPort:(<span class="built_in">AVCaptureInputPort</span> *)port videoPreviewLayer:(<span class="built_in">AVCaptureVideoPreviewLayer</span> *)layer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *inputPorts;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureOutput</span> *output;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureVideoPreviewLayer</span> *videoPreviewLayer;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> active;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureAudioChannel</span> *&gt; *audioChannels;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mirroring镜像</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoMirroring;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> videoMirrored;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyAdjustsVideoMirroring;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持更改方向</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoOrientation;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureVideoOrientation</span> videoOrientation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指示应如何处理流经过connect的隔行扫描的视频</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoFieldMode;   </span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVVideoFieldMode</span> videoFieldMode; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 视频最大的尺寸和裁剪因子</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CGFloat</span> videoMaxScaleAndCropFactor;</span><br><span class="line"><span class="comment">// 此属性仅适用于涉及视频的连接。可以将此属性设置为介于 1.0 到 videoMaxScaleAndCropFactor 值之间的值。以1.0为因子，图像是其原始大小。系数大于 1.0 时，图像按系数缩放并中心裁剪为其原始尺寸。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGFloat</span> videoScaleAndCropFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 稳定模式。此属性仅适用于涉及视频的 AVCaptureConnection 实例。启用视频稳定会在视频捕获管道中引入额外的延迟，并且可能会消耗更多的系统内存，具体取决于稳定模式和格式。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> supportsVideoStabilization;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureVideoStabilizationMode</span> preferredVideoStabilizationMode;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureVideoStabilizationMode</span> activeVideoStabilizationMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置捕获管道以传递相机内在信息(如成像参数等)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> cameraIntrinsicMatrixDeliverySupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> cameraIntrinsicMatrixDeliveryEnabled;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h2 id="4-2-使用AVCaptureDevice表示输入设备"><a href="#4-2-使用AVCaptureDevice表示输入设备" class="headerlink" title="4.2 使用AVCaptureDevice表示输入设备"></a>4.2 使用AVCaptureDevice表示输入设备</h2><p><a target="_blank" rel="noopener" href="https://developer.apple.com/reference/avfoundation/avcapturedevice">AVCaptureDevice</a> 是对实际的物理捕捉设备的抽象，物体捕捉设备向 <code>AVCaptureSession</code> 提供数据。每个 <code>AVCaptureDevice</code> 对象代表一个实际的输入设备，例如前摄像头或后摄像头、或麦克风。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="comment">// 获取当前可用的捕捉设备，而且可以获取捕捉设备的设备特性</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureDevice</span> *&gt; *)devices API_DEPRECATED(<span class="string">&quot;Use AVCaptureDeviceDiscoverySession instead.&quot;</span>;</span><br><span class="line"><span class="comment">// 找出对应类型的可用设备</span></span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureDevice</span> *&gt; *)devicesWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">AVCaptureDevice</span> *)defaultDeviceWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">                                                       </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDeviceDiscoverySession</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureDevice</span> *&gt; *devices;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>当前的可用设备的状态可能会发生改变：</p>
<ul>
<li>当前使用的输入设备可能会变为不可用状态 (如果设备被另外一个应用使用)；</li>
<li>也可能会有新的设备变为可用状态 (被其他应用释放)。</li>
</ul>
<p>注册接收 <code>AVCaptureDeviceWasConnectedNotification</code> 和 <code>AVCaptureDeviceWasDisconnectedNotification</code> 通知可以得知可用设备列表的变化。</p>
<p>使用捕捉输入(AVCaptureInput)将输入设备添加到 capture session 中。</p>
<h3 id="4-2-1-设备特性"><a href="#4-2-1-设备特性" class="headerlink" title="4.2.1 设备特性"></a>4.2.1 设备特性</h3><p>可以获取一个设备的设备特性，比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每个可用的捕获设备都有一个唯一的 ID</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *uniqueID;</span><br><span class="line"><span class="comment">// 型号ID，同一型号的所有设备具有相同的、唯一的标识符。例如，两个相同的iPhone机型内置的摄像头的型号ID将是相同的。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *modelID;</span><br><span class="line"><span class="comment">// 本地化、人类可读的名称。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *localizedName;</span><br><span class="line"><span class="comment">// 制造商名称</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSString</span> *manufacturer;</span><br><span class="line"><span class="comment">// 传输类型(e.g. USB, PCI, etc).</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) int32_t transportType;</span><br><span class="line"><span class="comment">// 设备是否能捕捉 给定类型的媒体。如是否能采集音频、视频等</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)hasMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line"><span class="comment">// 设备是否可以在使用给定预设配置的capture Session中使用</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)supportsAVCaptureSessionPreset:(<span class="built_in">AVCaptureSessionPreset</span>)preset;</span><br></pre></td></tr></table></figure>

<p>当要提供一个可用的捕捉设备列表给用户进行选择时，获取展示出设备的位置以及名称 (比如前摄像头或后摄像头) 拥有更好的用户体验。</p>
<p>下图展示了前摄像头 (<code>AVCaptureDevicePositionFront</code>) 和后摄像头 (<code>AVCaptureDevicePositionBack</code>):</p>
<blockquote>
<p>注意：媒体捕获不支持同时捕获 iOS 设备上的前置和后置摄像头。</p>
</blockquote>
<img src="/images/avf/cameras_2x.png" alt="img" style="zoom:70%;" />

<p>下面的代码遍历了所有的可用设备并打印其名称，如果是视频设备，则打印其位置:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devices];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;Device name: %@&quot;</span>, [device localizedName]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ([device hasMediaType:<span class="built_in">AVMediaTypeVideo</span>]) &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> ([device position] == <span class="built_in">AVCaptureDevicePositionBack</span>) &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Device position : back&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(<span class="string">@&quot;Device position : front&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，还可以获取设备的 model ID 以及 unique ID。</p>
<h3 id="4-2-2-设备捕捉时的参数设置"><a href="#4-2-2-设备捕捉时的参数设置" class="headerlink" title="4.2.2 设备捕捉时的参数设置"></a>4.2.2 设备捕捉时的参数设置</h3><p>不同的设备之间具备不同的能力，比如一些设备支持不同的对焦或闪光灯模式，某些设备还支持兴趣点对焦。</p>
<p>下面的代码示例了如何找出一个具有手电筒模式和并支持给定capture session preset 的视频输入设备：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span> *devices = [<span class="built_in">AVCaptureDevice</span> devicesWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"><span class="built_in">NSMutableArray</span> *torchDevices = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVCaptureDevice</span> *device <span class="keyword">in</span> devices) &#123;</span><br><span class="line">    [<span class="keyword">if</span> ([device hasTorch] &amp;&amp;</span><br><span class="line">         [device supportsAVCaptureSessionPreset:<span class="built_in">AVCaptureSessionPreset640x480</span>]) &#123;</span><br><span class="line">        [torchDevices addObject:device];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果找到了多个符合要求的设备，你可能需要让用户选择其中的某一个设备，这时可以使用 localizedName 属性获取设备的描述信息.</p>
<p>可以用类似的方式实现各种不同的捕捉设置。框架预定义了一些常量用来代表特定的捕捉模式，你可以使用这些常量以便于判断设备是否支持特定的模式。</p>
<p>在大部分情况下，可以通过属性值的监听，获悉设备特性的变化。</p>
<p>任何情况下，在改变设备的捕捉参数配置之前，都应该先锁定设备，详见下节设备的配置。</p>
<blockquote>
<p>兴趣点对焦模式和兴趣点曝光模式是互斥的，正如对焦模式和曝光模式也是互斥的一样</p>
</blockquote>
<h4 id="1-对焦模式-Focus分类"><a href="#1-对焦模式-Focus分类" class="headerlink" title="1. 对焦模式(Focus分类)"></a>1. 对焦模式(Focus分类)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceFocus</span>)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> lockingFocusWithCustomLensPositionSupported;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断设备是否支持给定的对焦模式，然后设置属性 focusMode 改变对焦模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFocusModeSupported:(<span class="built_in">AVCaptureFocusMode</span>)focusMode;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 三种对焦模式：</span></span><br><span class="line"><span class="comment">    AVCaptureFocusModeLocked: 固定焦点</span></span><br><span class="line"><span class="comment">    AVCaptureFocusModeAutoFocus: 自动对焦然后锁定焦点</span></span><br><span class="line"><span class="comment">    AVCaptureFocusModeContinuousAutoFocus: 根据需要连续自动对焦</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureFocusMode</span> focusMode;</span><br><span class="line"><span class="comment">// 此外, 一些设备还支持兴趣点对焦模式. 通过下面方法判断是否支持该模式, 然后使用属性 focusPointOfInterest 设置焦点. </span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> focusPointOfInterestSupported;</span><br><span class="line"><span class="comment">// 赋值CGPoint。无论设备是横屏 (Home 键靠右) 或竖屏模式, CGPoint&#123;0,0&#125;代表设备左上角, CGPoint&#123;1,1&#125;代表设备右下角.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGPoint</span> focusPointOfInterest;</span><br><span class="line"><span class="comment">// 判断当前设备是否正在对焦中。可以使用 KVO 监听该属性获取对焦开始与结束的通知。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> adjustingFocus;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> autoFocusRangeRestrictionSupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureAutoFocusRangeRestriction</span> autoFocusRangeRestriction;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> smoothAutoFocusSupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> smoothAutoFocusEnabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> lensPosition;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">AVCaptureLensPositionCurrent</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setFocusModeLockedWithLensPosition:(<span class="keyword">float</span>)lensPosition completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> syncTime))handler;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSInteger</span> minimumFocusDistance;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>设置对焦模式的示例代码如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([currentDevice isFocusModeSupported:<span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>]) &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> autofocusPoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</span><br><span class="line">    [currentDevice setFocusPointOfInterest:autofocusPoint];</span><br><span class="line">    [currentDevice setFocusMode:<span class="built_in">AVCaptureFocusModeContinuousAutoFocus</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-曝光模式-Exposure分类"><a href="#2-曝光模式-Exposure分类" class="headerlink" title="2. 曝光模式(Exposure分类)"></a>2. 曝光模式(Exposure分类)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceExposure</span>)</span></span><br><span class="line"><span class="comment">// 判断设备是否支持给定的曝光模式，然后设置属性 exposureMode 改变曝光模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isExposureModeSupported:(<span class="built_in">AVCaptureExposureMode</span>)exposureMode;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 两种曝光模式:</span></span><br><span class="line"><span class="comment">    AVCaptureExposureModeContinuousAutoExposure: 自动调整曝光等级</span></span><br><span class="line"><span class="comment">    AVCaptureExposureModeLocked: 固定曝光等级</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureExposureMode</span> exposureMode;</span><br><span class="line"><span class="comment">// 此外, 一些设备还支持兴趣点曝光模式. 通过下面的方法判断是否支持该模式, 然后使用属性 exposurePointOfInterest 设置曝光点.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> exposurePointOfInterestSupported;</span><br><span class="line"><span class="comment">// 无论设备是横屏 (Home 键靠右) 或竖屏模式, CGPoint&#123;0,0&#125;代表设备左上角, CGPoint&#123;1,1&#125;代表设备右下角.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CGPoint</span> exposurePointOfInterest;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> activeMaxExposureDuration;</span><br><span class="line"><span class="comment">// 判断当前设备是否正在改变曝光设置中. 可以使用 KVO 监听该属性获取开始设置曝光模式与结束设置曝光模式的通知.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> adjustingExposure;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> lensAperture;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> exposureDuration;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> ISO;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="built_in">CMTime</span> <span class="built_in">AVCaptureExposureDurationCurrent</span>;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">AVCaptureISOCurrent</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setExposureModeCustomWithDuration:(<span class="built_in">CMTime</span>)duration ISO:(<span class="keyword">float</span>)ISO completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> syncTime))handler;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> exposureTargetOffset;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> exposureTargetBias;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> minExposureTargetBias;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> maxExposureTargetBias;</span><br><span class="line"><span class="built_in">AVF_EXPORT</span> <span class="keyword">const</span> <span class="keyword">float</span> <span class="built_in">AVCaptureExposureTargetBiasCurrent</span>;</span><br><span class="line">- (<span class="keyword">void</span>)setExposureTargetBias:(<span class="keyword">float</span>)bias completionHandler:(<span class="keyword">nullable</span> <span class="keyword">void</span> (^)(<span class="built_in">CMTime</span> syncTime))handler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>设置曝光模式的示例代码如下:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([currentDevice isExposureModeSupported:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>]) &#123;</span><br><span class="line">    <span class="built_in">CGPoint</span> exposurePoint = <span class="built_in">CGPointMake</span>(<span class="number">0.5</span>f, <span class="number">0.5</span>f);</span><br><span class="line">    [currentDevice setExposurePointOfInterest:exposurePoint];</span><br><span class="line">    [currentDevice setExposureMode:<span class="built_in">AVCaptureExposureModeContinuousAutoExposure</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-闪光模式-Flash分类"><a href="#3-闪光模式-Flash分类" class="headerlink" title="3. 闪光模式(Flash分类)"></a>3. 闪光模式(Flash分类)</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceFlash</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个设备是否有闪光灯</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> hasFlash;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFlashAvailable) <span class="built_in">BOOL</span> flashAvailable API_AVAILABLE(macos(<span class="number">10.15</span>), ios(<span class="number">5.0</span>), macCatalyst(<span class="number">14.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">getter</span>=isFlashActive) <span class="built_in">BOOL</span> flashActive API_DEPRECATED(<span class="string">&quot;Use AVCapturePhotoOutput&#x27;s -isFlashScene instead.&quot;</span>, ios(<span class="number">5.0</span>, <span class="number">10.0</span>)) API_UNAVAILABLE(macos) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="comment">// 判断是否支持某个闪光模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isFlashModeSupported:(<span class="built_in">AVCaptureFlashMode</span>)flashMode API_DEPRECATED(<span class="string">&quot;Use AVCapturePhotoOutput&#x27;s -supportedFlashModes instead.&quot;</span>, ios(<span class="number">4.0</span>, <span class="number">10.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置闪光灯模式</span></span><br><span class="line"><span class="comment"> 三种闪光模式:</span></span><br><span class="line"><span class="comment">    AVCaptureFlashModeOff: 关闭</span></span><br><span class="line"><span class="comment">    AVCaptureFlashModeOn: 打开</span></span><br><span class="line"><span class="comment">    AVCaptureFlashModeAuto: 根据环境亮度自动开启或关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureFlashMode</span> flashMode API_DEPRECATED(<span class="string">&quot;Use AVCapturePhotoSettings.flashMode instead.&quot;</span>, ios(<span class="number">4.0</span>, <span class="number">10.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h4 id="4-手电筒模式-Torch分类"><a href="#4-手电筒模式-Torch分类" class="headerlink" title="4. 手电筒模式(Torch分类)"></a>4. 手电筒模式(Torch分类)</h4><p>手电筒模式下，闪光灯会一直处于开启状态，用于视频捕捉。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDevice</span> (<span class="title">AVCaptureDeviceTorch</span>)</span></span><br><span class="line"><span class="comment">// 判断一个设备是否有闪光灯</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> hasTorch;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> torchAvailable;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> torchActive;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> torchLevel;</span><br><span class="line"><span class="comment">// 判断是否支持某个手电筒模式</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)isTorchModeSupported:(<span class="built_in">AVCaptureTorchMode</span>)torchMode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 设置手电筒模式，三种手电筒模式:</span></span><br><span class="line"><span class="comment">    AVCaptureTorchModeOff: 关闭</span></span><br><span class="line"><span class="comment">    AVCaptureTorchModeOn: 打开</span></span><br><span class="line"><span class="comment">    AVCaptureTorchModeAuto: 根据需要自动开启或关闭</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">AVCaptureTorchMode</span> torchMode;</span><br><span class="line">- (<span class="built_in">BOOL</span>)setTorchModeOnWithLevel:(<span class="keyword">float</span>)torchLevel error:(<span class="built_in">NSError</span> ** _Nullable)outError;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>对于一个有手电筒的设备，手电筒只有在设备与一个运行中的 capture session 进行了关联后才可以设置为开启。</p>
<h4 id="5-白平衡-WhiteBalance分类"><a href="#5-白平衡-WhiteBalance分类" class="headerlink" title="5. 白平衡(WhiteBalance分类)"></a>5. 白平衡(WhiteBalance分类)</h4><p>有两种白平衡模式:</p>
<ul>
<li><code>AVCaptureWhiteBalanceModeLocked</code>: 固定参数的白平衡</li>
<li><code>AVCaptureWhiteBalanceModeContinuousAutoWhiteBalance</code>: 由相机自动调整白平衡参数</li>
</ul>
<p>使用方法 isWhiteBalanceModeSupported: 判断设备是否支持给定的白平衡模式，然后通过属性 whiteBalanceMode 设置白平衡模式。</p>
<p>使用属性 adjustingWhiteBalance 判断当前是否正在修改白平衡模式。可以使用 KVO 监听该属性获取开始设置白平衡模式与结束设置白平衡模式的通知。</p>
<h4 id="6-视频稳定性-AVCaptureConnection"><a href="#6-视频稳定性-AVCaptureConnection" class="headerlink" title="6. 视频稳定性(AVCaptureConnection)"></a>6. 视频稳定性(AVCaptureConnection)</h4><p>依赖于某些特殊的硬件设备，视频会有更好的稳定性。但并不支持所有的视频格式和分辨率。</p>
<p>开启电影视频稳定性特性在捕捉视频时可能会增加延迟。</p>
<p>使用属性 videoStabilizationEnabled 可以判断当前是否使用了视频稳定性特性。</p>
<p>属性 enablesVideoStabilizationWhenAvailable 可以在设备支持的情况下自动开启视频稳定性特性，该属性默认为关闭状态。</p>
<h4 id="7-设置设备方向-AVCaptureConnection"><a href="#7-设置设备方向-AVCaptureConnection" class="headerlink" title="7. 设置设备方向(AVCaptureConnection)"></a>7. 设置设备方向(AVCaptureConnection)</h4><p>可以在<code>AVCaptureConnection</code>上指定期望的设备方向，用来设置输出时<code>AVCaptureOutput</code>(<code>AVCaptureMovieFileOutput</code>、<code>AVCaptureStillImageOutput</code>和<code>AVCaptureVideoDataOutput</code>) 的设备方向。</p>
<p>使用属性<code>AVCaptureConnectionsupportsVideoOrientation</code>判断设备是否支持修改视频方向，使用属性<code>videoOrientation</code>指定一个方向。下面的代码将<code>AVCaptureConnection</code>的方向设置为<code>AVCaptureVideoOrientationLandscapeLeft</code>：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureConnection</span> *captureConnection = &lt;#A capture connection#&gt;;</span><br><span class="line"><span class="keyword">if</span> ([captureConnection isVideoOrientationSupported]) &#123;</span><br><span class="line">    <span class="built_in">AVCaptureVideoOrientation</span> orientation = <span class="built_in">AVCaptureVideoOrientationLandscapeLeft</span>;</span><br><span class="line">    [captureConnection setVideoOrientation:orientation];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-设备配置"><a href="#4-2-3-设备配置" class="headerlink" title="4.2.3 设备配置"></a>4.2.3 设备配置</h3><p>要修改设备的捕捉参数相关的属性，首先需要使用方法 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/avfoundation/avcapturedevice/1387810-lockforconfiguration">lockForConfiguration:</a> 锁定设备，这样可以避免与其他应用的设置产生冲突。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ([device isFocusModeSupported:<span class="built_in">AVCaptureFocusModeLocked</span>]) &#123;</span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> ([device lockForConfiguration:&amp;error]) &#123;</span><br><span class="line">        device.focusMode = <span class="built_in">AVCaptureFocusModeLocked</span>;</span><br><span class="line">        [device unlockForConfiguration];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Respond to the failure as appropriate.</span></span><br></pre></td></tr></table></figure>

<p>只有当你需要设备属性保持不变时，您应该保持设备锁定。不必要地保持设备锁定可能会降低共享设备的其他应用程序的捕获质量。</p>
<h3 id="4-2-4-切换设备"><a href="#4-2-4-切换设备" class="headerlink" title="4.2.4 切换设备"></a>4.2.4 切换设备</h3><p>某些场景下可能需要允许用户切换输入设备，比如前后摄像头。为了避免卡顿，可以重新配置正在运行的 session，使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/avfoundation/avcapturesession/1389174-beginconfiguration">beginConfiguration</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/avfoundation/avcapturesession/1388173-commitconfiguration">commitConfiguration</a> 方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *session = &lt;#A capture session#&gt;;</span><br><span class="line">[session beginConfiguration];</span><br><span class="line"></span><br><span class="line">[session removeInput:frontFacingCameraDeviceInput];</span><br><span class="line">[session addInput:backFacingCameraDeviceInput];</span><br><span class="line"></span><br><span class="line">[session commitConfiguration];</span><br></pre></td></tr></table></figure>

<p>当最后的<code>commitConfiguration</code>方法被调用时，所有的设置变化会一起执行，确保了切换的流畅性.</p>
<h2 id="4-3-使用AVCaptureInput添加输入设备"><a href="#4-3-使用AVCaptureInput添加输入设备" class="headerlink" title="4.3 使用AVCaptureInput添加输入设备"></a>4.3 使用AVCaptureInput添加输入设备</h2><p>要把一个 capture device 添加到 capture session 中，需要使用 AVCaptureDeviceInput(抽象类<code>AVCaptureInput</code>的子类)。</p>
<p>Capture device input 管理设备的端口。</p>
<h3 id="4-3-1-AVCaptureInput-与-Port"><a href="#4-3-1-AVCaptureInput-与-Port" class="headerlink" title="4.3.1 AVCaptureInput 与 Port"></a>4.3.1 AVCaptureInput 与 Port</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureInputPort</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureInput</span> *input;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMFormatDescriptionRef</span> formatDescription;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isEnabled) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMClockRef</span> clock;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureDeviceType</span> sourceDeviceType;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureDevicePosition</span> sourceDevicePosition;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureInput</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *ports;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureDeviceInput</span> : <span class="title">AVCaptureInput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)deviceInputWithDevice:(<span class="built_in">AVCaptureDevice</span> *)device error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithDevice:(<span class="built_in">AVCaptureDevice</span> *)device error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>)<span class="built_in">AVCaptureDevice</span> *device;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> unifiedAutoExposureDefaultsEnabled;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureInputPort</span> *&gt; *)portsWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType </span><br><span class="line">                     sourceDeviceType:(<span class="built_in">AVCaptureDeviceType</span>)sourceDeviceType </span><br><span class="line">                 sourceDevicePosition:(<span class="built_in">AVCaptureDevicePosition</span>)sourceDevicePosition;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> videoMinFrameDurationOverride;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-添加输入设备-AVCaptureSession"><a href="#4-3-2-添加输入设备-AVCaptureSession" class="headerlink" title="4.3.2 添加输入设备(AVCaptureSession)"></a>4.3.2 添加输入设备(AVCaptureSession)</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="built_in">AVCaptureDeviceInput</span> *input =</span><br><span class="line">        [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</span><br><span class="line"><span class="keyword">if</span> (!input) &#123;</span><br><span class="line">    <span class="comment">// Handle the error appropriately.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 addInput: 添加输入，使用 canAddInput: 判断该设备是否可以被添加到 session 中。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#Get a capture session#&gt;;</span><br><span class="line"><span class="built_in">AVCaptureDeviceInput</span> *captureDeviceInput = &lt;#Get a capture device input#&gt;;</span><br><span class="line"><span class="keyword">if</span> ([captureSession canAddInput:captureDeviceInput]) &#123;</span><br><span class="line">    [captureSession addInput:captureDeviceInput];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the failure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个<code>AVCaptureInput</code>对象包含一个或多个数据流。例如，输入设备可能同时提供音频和视频数据。</p>
<p>每个 AVCaptureInputPort 对象代表一个媒体数据流。</p>
<p>Capture session 使用一个<code>AVCaptureConnection</code> 对象定义一组 <code>AVCaptureInputPort</code> 和一个 <code>AVCaptureOutput</code> 之间的映射关系。</p>
<h2 id="4-4-使用AVCaptureOutput输出数据"><a href="#4-4-使用AVCaptureOutput输出数据" class="headerlink" title="4.4 使用AVCaptureOutput输出数据"></a>4.4 使用AVCaptureOutput输出数据</h2><p>要从 capture session 中输出数据，可以向其添加一个或多个 outputs(AVCaptureOutput 的子类)，比如:</p>
<ul>
<li>AVCaptureFileOutput: 输出为文件</li>
<li>AVCaptureMovieFileOutput 电影文件<ul>
<li>AVCaptureAudioFileOutput 音频文件</li>
</ul>
</li>
<li>AVCaptureVideoDataOutput: 可以逐帧处理捕捉到的视频</li>
<li>AVCaptureAudioDataOutput: 可以处理捕捉到的音频数据</li>
<li>AVCaptureStillImageOutput: 输出为静态图片</li>
<li>…等</li>
</ul>
<p>使用方法 addOutput: 在 capture session 中添加 outputs。使用方法 canAddOutput: 判断是否可以添加一个给定的 output。可以根据需要在 session 运行过程中添加或移除一个 output。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#Get a capture session#&gt;;</span><br><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *movieOutput = &lt;#Create and configure a movie output#&gt;;</span><br><span class="line"><span class="keyword">if</span> ([captureSession canAddOutput:movieOutput]) &#123;</span><br><span class="line">    [captureSession addOutput:movieOutput];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Handle the failure.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-1-输出为视频文件-AVCaptureFileOutput"><a href="#4-4-1-输出为视频文件-AVCaptureFileOutput" class="headerlink" title="4.4.1 输出为视频文件(AVCaptureFileOutput)"></a>4.4.1 输出为视频文件(AVCaptureFileOutput)</h3><p>使用 AVCaptureMovieFileOutput 将视频数据保存为一个本地文件（AVCaptureMovieFileOutput 是 AVCaptureFileOutput 的一个具体子类，它定义了许多基本行为）。</p>
<h4 id="1-三个输出文件类"><a href="#1-三个输出文件类" class="headerlink" title="1. 三个输出文件类"></a>1. 三个输出文件类</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件输出</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureFileOutput</span> : <span class="title">AVCaptureOutput</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="keyword">id</span>&lt;<span class="built_in">AVCaptureFileOutputDelegate</span>&gt; delegate;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *outputFileURL;</span><br><span class="line">- (<span class="keyword">void</span>)startRecordingToOutputFileURL:(<span class="built_in">NSURL</span> *)outputFileURL recordingDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">AVCaptureFileOutputRecordingDelegate</span>&gt;)delegate;</span><br><span class="line">- (<span class="keyword">void</span>)stopRecording;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> recording;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> recordingPaused __IOS_PROHIBITED __TVOS_PROHIBITED __WATCHOS_PROHIBITED;</span><br><span class="line">- (<span class="keyword">void</span>)pauseRecording __IOS_PROHIBITED __TVOS_PROHIBITED __WATCHOS_PROHIBITED;</span><br><span class="line">- (<span class="keyword">void</span>)resumeRecording __IOS_PROHIBITED __TVOS_PROHIBITED __WATCHOS_PROHIBITED;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMTime</span> recordedDuration;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) int64_t recordedFileSize;</span><br><span class="line"><span class="comment">// 最大录制时长</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> maxRecordedDuration;  </span><br><span class="line"><span class="comment">// 最大的录制文件大小</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) int64_t maxRecordedFileSize;</span><br><span class="line"><span class="comment">// 磁盘应保持的最低容量。当达到限制时停止录制，并且调用 captureOutput:didFinishRecordingToOutputFileAtURL:fromConnections:error: 委托方法，传出错误。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) int64_t minFreeDiskSpaceLimit;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出为视频文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureMovieFileOutput</span> : <span class="title">AVCaptureFileOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> movieFragmentInterval;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *availableVideoCodecTypes;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *)supportedOutputSettingsKeysForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettingsForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)setOutputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings forConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="built_in">BOOL</span>)recordsVideoOrientationAndMirroringChangesAsMetadataTrackForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)setRecordsVideoOrientationAndMirroringChanges:(<span class="built_in">BOOL</span>)doRecordChanges asMetadataTrackForConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isPrimaryConstituentDeviceSwitchingBehaviorForRecordingEnabled) <span class="built_in">BOOL</span> primaryConstituentDeviceSwitchingBehaviorForRecordingEnabled;</span><br><span class="line">- (<span class="keyword">void</span>)setPrimaryConstituentDeviceSwitchingBehaviorForRecording:(<span class="built_in">AVCapturePrimaryConstituentDeviceSwitchingBehavior</span>)switchingBehavior restrictedSwitchingBehaviorConditions:(<span class="built_in">AVCapturePrimaryConstituentDeviceRestrictedSwitchingBehaviorConditions</span>)restrictedSwitchingBehaviorConditions;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCapturePrimaryConstituentDeviceSwitchingBehavior</span> primaryConstituentDeviceSwitchingBehaviorForRecording;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCapturePrimaryConstituentDeviceRestrictedSwitchingBehaviorConditions</span> primaryConstituentDeviceRestrictedSwitchingBehaviorConditionsForRecording;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 输出为音频文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureAudioFileOutput</span> : <span class="title">AVCaptureFileOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line">+ (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVFileType</span>&gt; *)availableOutputFileTypes;</span><br><span class="line">- (<span class="keyword">void</span>)startRecordingToOutputFileURL:(<span class="built_in">NSURL</span> *)outputFileURL outputFileType:(<span class="built_in">AVFileType</span>)fileType recordingDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">AVCaptureFileOutputRecordingDelegate</span>&gt;)delegate;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *audioSettings;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>可以对 movie file output 的参数进行配置，比如最大的录制时长、最大的录制文件大小。如果设备磁盘空间不足的话，还可以阻止用户进行视频录制。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = [[<span class="built_in">AVCaptureMovieFileOutput</span> alloc] init];</span><br><span class="line"><span class="built_in">CMTime</span> maxDuration = &lt;#Create a <span class="built_in">CMTime</span> to represent the maximum duration#&gt;;</span><br><span class="line">aMovieFileOutput.maxRecordedDuration = maxDuration;</span><br><span class="line">aMovieFileOutput.minFreeDiskSpaceLimit = &lt;#An appropriate minimum given the quality of the movie format and the duration#&gt;;</span><br></pre></td></tr></table></figure>

<p>输出的分辨率和码率依赖于 capture session 的<code>sessionPreset</code> 属性，常用的视频编码格式是 H.264，音频编码格式是 AAC。实际的编码格式可能由于设备不同有所差异。</p>
<h4 id="2-两个协议"><a href="#2-两个协议" class="headerlink" title="2. 两个协议"></a>2. 两个协议</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件录制协议。在单个文件记录过程中的各个阶段，通知外部。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVCaptureFileOutputRecordingDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didStartRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didPauseRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didResumeRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output willFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)fileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections error:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)outputFileURL fromConnections:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVCaptureConnection</span> *&gt; *)connections error:(<span class="built_in">NSError</span> *)error;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 文件输出协议。用于监听和控制媒体文件输出的方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVCaptureFileOutputDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@required</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)captureOutputShouldProvideSampleAccurateRecordingStart:(<span class="built_in">AVCaptureOutput</span> *)output;</span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)output didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h4 id="3-简单示例"><a href="#3-简单示例" class="headerlink" title="3. 简单示例"></a>3. 简单示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 开始录制</span></span><br><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = &lt;#Get a movie file output#&gt;;</span><br><span class="line"><span class="built_in">NSURL</span> *fileURL = &lt;#A file URL that identifies the output location#&gt;;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 使用方法下面的方法开始录制一段 QuickTime 视频，方法需要传入一个本地文件的 URL 和一个录制的 delegate。</span></span><br><span class="line"><span class="comment"> - 传入的本地 URL 不能是已经存在的文件，因为 movie file output 不会对已存在的文件进行重写，而且对传入的文件路径，程序必须有写入权限。</span></span><br><span class="line"><span class="comment"> - 传入的 delegate 必须遵循 AVCaptureFileOutputRecordingDelegate 协议，且必须实现其require方法。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">[aMovieFileOutput startRecordingToOutputFileURL:fileURL recordingDelegate:&lt;#The delegate#&gt;];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 确保文件写入成功，在下面协议方法中不仅需要检测 error, 还需要对 error 中的 user info 字典中的 AVErrorRecordingSuccessfullyFinishedKey进行判断。</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureFileOutput</span> *)captureOutput</span><br><span class="line">        didFinishRecordingToOutputFileAtURL:(<span class="built_in">NSURL</span> *)outputFileURL</span><br><span class="line">        fromConnections:(<span class="built_in">NSArray</span> *)connections</span><br><span class="line">        error:(<span class="built_in">NSError</span> *)error &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">BOOL</span> recordedSuccessfully = <span class="literal">YES</span>;</span><br><span class="line">    <span class="keyword">if</span> ([error code] != noErr) &#123;</span><br><span class="line">        <span class="comment">// A problem occurred: Find out if the recording was successful.</span></span><br><span class="line">        <span class="keyword">id</span> value = [[error userInfo] objectForKey:<span class="built_in">AVErrorRecordingSuccessfullyFinishedKey</span>];</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            recordedSuccessfully = [value boolValue];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Continue as appropriate...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之所以需要对<code>AVErrorRecordingSuccessfullyFinishedKey</code>进行判断，是因为即使写入过程中抛出了一个 error，文件也可能被成功写入了。抛出的 error 可能是因为：</p>
<ul>
<li>达到了一些设置的限制约束条件，比如：<ul>
<li>AVErrorMaximumDurationReached</li>
<li>AVErrorMaximumFileSizeReached</li>
</ul>
</li>
<li>其他可能导致录制中断的情况如下:<ul>
<li>磁盘已满 - AVErrorDiskFull</li>
<li>与录制的设备的连接断开 - AVErrorDeviceWasDisconnected</li>
<li>session 中断 (比如有电话接入) - AVErrorSessionWasInterrupted</li>
</ul>
</li>
</ul>
<h4 id="4-在文件中添加元数据-AVMetadataItem"><a href="#4-在文件中添加元数据-AVMetadataItem" class="headerlink" title="4. 在文件中添加元数据(AVMetadataItem)"></a>4. 在文件中添加元数据(AVMetadataItem)</h4><p>可在任何时刻对文件的元数据 (metadata) 进行设置，哪怕是在录制过程中。一个 file output 的 metadata 由一个 AVMetadataItem 对象的数组来表示。可以使用其可变子类 AVMutableMetadataItem 创建自定义的 metadata。</p>
<img src="/images/avf/avmetadataItem.jpg" alt="avmetadataItem" style="zoom:75%;" />

<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureMovieFileOutput</span> *aMovieFileOutput = &lt;#Get a movie file output#&gt;;</span><br><span class="line"><span class="built_in">NSArray</span> *existingMetadataArray = aMovieFileOutput.metadata;</span><br><span class="line"><span class="built_in">NSMutableArray</span> *newMetadataArray = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">if</span> (existingMetadataArray) &#123;</span><br><span class="line">    newMetadataArray = [existingMetadataArray mutableCopy];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    newMetadataArray = [[<span class="built_in">NSMutableArray</span> alloc] init];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVMutableMetadataItem</span> *item = [[<span class="built_in">AVMutableMetadataItem</span> alloc] init];</span><br><span class="line">item.keySpace = <span class="built_in">AVMetadataKeySpaceCommon</span>;</span><br><span class="line">item.key = <span class="built_in">AVMetadataCommonKeyLocation</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">CLLocation</span> *location - &lt;#The location to set#&gt;;</span><br><span class="line">item.value = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%+08.4lf%+09.4lf/&quot;</span></span><br><span class="line">    location.coordinate.latitude, location.coordinate.longitude];</span><br><span class="line"></span><br><span class="line">[newMetadataArray addObject:item];</span><br><span class="line"></span><br><span class="line">aMovieFileOutput.metadata = newMetadataArray;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-2-处理视频帧-AVCaptureVideoDataOutput"><a href="#4-4-2-处理视频帧-AVCaptureVideoDataOutput" class="headerlink" title="4.4.2 处理视频帧(AVCaptureVideoDataOutput)"></a>4.4.2 处理视频帧(AVCaptureVideoDataOutput)</h3><h4 id="1-AVCaptureVideoDataOutput类"><a href="#1-AVCaptureVideoDataOutput类" class="headerlink" title="1. AVCaptureVideoDataOutput类"></a>1. AVCaptureVideoDataOutput类</h4><p>AVCaptureVideoDataOutput 使用代理模式来对视频帧进行处理。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureVideoDataOutput</span> : <span class="title">AVCaptureOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置代理，此外还需要传入代理方法被调用的队列。</span></span><br><span class="line"><span class="comment">// 必须使用串行队列确保视频帧按照录制顺序被传递到代理方法中。</span></span><br><span class="line">- (<span class="keyword">void</span>)setSampleBufferDelegate:(<span class="keyword">id</span>&lt;<span class="built_in">AVCaptureVideoDataOutputSampleBufferDelegate</span>&gt;)sampleBufferDelegate queue:(<span class="built_in">dispatch_queue_t</span>)sampleBufferCallbackQueue;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span>&lt;<span class="built_in">AVCaptureVideoDataOutputSampleBufferDelegate</span>&gt; sampleBufferDelegate;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">dispatch_queue_t</span> sampleBufferCallbackQueue;</span><br><span class="line"><span class="comment">// 自定义输出格式. videoSettings属性是一个字典类型, 目前只支持kCVPixelBufferPixelFormatTypeKey.</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">null_resettable</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *videoSettings;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)recommendedVideoSettingsForAssetWriterWithOutputFileType:(<span class="built_in">AVFileType</span>)outputFileType;</span><br><span class="line">- (<span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *)availableVideoCodecTypesForAssetWriterWithOutputFileType:(<span class="built_in">AVFileType</span>)outputFileType;</span><br><span class="line">- (<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)recommendedVideoSettingsForVideoCodecType:(<span class="built_in">AVVideoCodecType</span>)videoCodecType assetWriterOutputFileType:(<span class="built_in">AVFileType</span>)outputFileType;</span><br><span class="line"><span class="comment">// 获取支持的视频像素格式。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *availableVideoCVPixelFormatTypes;</span><br><span class="line"><span class="comment">// 获取支持的视频编解码格式。</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *availableVideoCodecTypes;</span><br><span class="line"><span class="comment">// 最小帧率。降低帧率来确保有足够的时间对视频帧进行处理</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">CMTime</span> minFrameDuration API_DEPRECATED(<span class="string">&quot;Use AVCaptureConnection&#x27;s videoMinFrameDuration property instead.&quot;</span>;</span><br><span class="line"><span class="comment">// 如果data output queue is阻塞，是否丢弃帧(当我们处理静止图像时)</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> alwaysDiscardsLateVideoFrames;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyConfiguresOutputBufferDimensions;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> deliversPreviewSizedOutputBuffers;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从video data输出样本缓冲区，并监控其状态的方法。</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVCaptureVideoDataOutputSampleBufferDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line"><span class="comment">// 通知已写入新的视频帧。视频帧由 CMSampleBufferRef 类型表示。默认情况下，buffers 被设置为当前设备相机效率最高的格式。</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)output didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection;</span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)output didDropSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection API_AVAILABLE(ios(<span class="number">6.0</span>), macCatalyst(<span class="number">14.0</span>)) API_UNAVAILABLE(tvos);</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>设置队列时，可以使用队列修改视频帧传递处理的优先级，参见示例 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/samplecode/SquareCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40011190">SquareCam</a>。</p>
<p>Core Graphics 和 OpenGL 都很好的兼容了<code>BGRA</code>格式。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureVideoDataOutput</span> *videoDataOutput = [<span class="built_in">AVCaptureVideoDataOutput</span> new];</span><br><span class="line"><span class="built_in">NSDictionary</span> *newSettings =</span><br><span class="line">                @&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;;</span><br><span class="line">videoDataOutput.videoSettings = newSettings;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 如果data output queue is阻塞，则丢弃(当我们处理静止图像时)</span></span><br><span class="line">[videoDataOutput setAlwaysDiscardsLateVideoFrames:<span class="literal">YES</span>];)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建串行队列</span></span><br><span class="line">videoDataOutputQueue = dispatch_queue_create(<span class="string">&quot;VideoDataOutputQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">[videoDataOutput setSampleBufferDelegate:<span class="keyword">self</span> queue:videoDataOutputQueue];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#The Capture Session#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ( [captureSession canAddOutput:videoDataOutput] )</span><br><span class="line">     [captureSession addOutput:videoDataOutput];</span><br></pre></td></tr></table></figure>

<h4 id="2-视频处理时的性能考虑"><a href="#2-视频处理时的性能考虑" class="headerlink" title="2. 视频处理时的性能考虑"></a>2. 视频处理时的性能考虑</h4><p>导出视频应当尽可能的使用低分辨率，高分辨率会消耗额外的 CPU 和电量。</p>
<p>确保在代理方法 <code>captureOutput:didOutputSampleBuffer:fromConnection:</code> 中处理 sample buffer 时不要使用耗时操作，如果处理占用时间过长，AV Foundation 会停止向代理方法中传递视频帧，而且会停止其他的输出，比如 preview layer 上的预览。</p>
<p>可以设置 capture video data 的属性 minFrameDuration 通过降低帧率来确保有足够的时间对视频帧进行处理。</p>
<p>将属性 alwaysDiscardsLateVideoFrames 设置为<code>YES</code>(默认值) 的话，后面的视频帧将会被丢弃，而不是排队等待处理。如果你并不介意延迟，而且需要处理所有的视频帧，也可以将<code>alwaysDiscardsLateVideoFrames</code>设置为<code>NO</code>(即使如此, 也可能会出现掉帧的情况)。</p>
<h3 id="4-4-3-捕捉静态图像-AVCaptureStillImageOutput"><a href="#4-4-3-捕捉静态图像-AVCaptureStillImageOutput" class="headerlink" title="4.4.3 捕捉静态图像(AVCaptureStillImageOutput)"></a>4.4.3 捕捉静态图像(AVCaptureStillImageOutput)</h3><p>使用 AVCaptureStillImageOutput 捕捉带元数据的静态图像。图片的分辨率依赖于 session 的 preset 设置和具体的硬件设备。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureStillImageOutput</span> : <span class="title">AVCaptureOutput</span></span></span><br><span class="line">- (<span class="keyword">instancetype</span>)init;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)new;</span><br><span class="line"><span class="comment">// 可以指定需要的图片格式等</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *outputSettings;</span><br><span class="line"><span class="comment">// ouput支持的图像像素格式</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSNumber</span> *&gt; *availableImageDataCVPixelFormatTypes;</span><br><span class="line"><span class="comment">// ouput支持的图像编解码格式</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVVideoCodecType</span>&gt; *availableImageDataCodecTypes;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> stillImageStabilizationSupported;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> automaticallyEnablesStillImageStabilizationWhenAvailable;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> stillImageStabilizationActive;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> highResolutionStillImageOutputEnabled;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">readonly</span>) <span class="built_in">BOOL</span> capturingStillImage;</span><br><span class="line">- (<span class="keyword">void</span>)captureStillImageAsynchronouslyFromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">CMSampleBufferRef</span> _Nullable imageDataSampleBuffer, <span class="built_in">NSError</span> * _Nullable error))handler <span class="built_in">NS_SWIFT_DISABLE_ASYNC</span>;</span><br><span class="line">+ (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)jpegStillImageNSDataRepresentation:(<span class="built_in">CMSampleBufferRef</span>)jpegSampleBuffer;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h4 id="1-像素和编码格式"><a href="#1-像素和编码格式" class="headerlink" title="1. 像素和编码格式"></a>1. 像素和编码格式</h4><p>不同的设备支持不同的图片格式。</p>
<p>可以使用 availableImageDataCVPixelFormatTypes、availableImageDataCodecTypes 查询。使用outputSettings 设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AVCaptureStillImageOutput *stillImageOutput &#x3D; [[AVCaptureStillImageOutput alloc] init];</span><br><span class="line">NSDictionary *outputSettings &#x3D; @&#123; AVVideoCodecKey : AVVideoCodecJPEG&#125;;</span><br><span class="line">[stillImageOutput setOutputSettings:outputSettings];</span><br></pre></td></tr></table></figure>

<p>如果需要的是 JPEG 图片，则不要指定压缩格式。相反，应该让 still image output 进行压缩 (因为它是硬件加速的)。可以使用 jpegStillImageNSDataRepresentation: 获取 NSData对象，且无需重新压缩数据，即使你修改了图像的元数据。</p>
<h4 id="2-捕捉图片"><a href="#2-捕捉图片" class="headerlink" title="2. 捕捉图片"></a>2. 捕捉图片</h4><p>使用方法 captureStillImageAsynchronouslyFromConnection:completionHandler: 捕捉图片。</p>
<ul>
<li>第一个参数是需要捕捉的 connection，需要判断当前的 connection 中哪个 input 正在采集视频。</li>
<li>第二个参数是一个有两个参数的<code>block</code>：<ul>
<li>一个包含图像数据的<code>CMSampleBuffer</code>类型</li>
<li>一个是 NSError 对象。Sample buffer 自身包含了元数据，比如 EXIF 信息字典，可以对这些元数据进行修改。</li>
</ul>
</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureConnection</span> *videoConnection = <span class="literal">nil</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">AVCaptureConnection</span> *connection <span class="keyword">in</span> stillImageOutput.connections) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVCaptureInputPort</span> *port <span class="keyword">in</span> [connection inputPorts]) &#123;</span><br><span class="line">        <span class="keyword">if</span> ([[port mediaType] isEqual:<span class="built_in">AVMediaTypeVideo</span>] ) &#123;</span><br><span class="line">            videoConnection = connection;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (videoConnection) &#123; <span class="keyword">break</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[stillImageOutput captureStillImageAsynchronouslyFromConnection:videoConnection completionHandler:</span><br><span class="line">    ^(<span class="built_in">CMSampleBufferRef</span> imageSampleBuffer, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">        <span class="built_in">CFDictionaryRef</span> exifAttachments =</span><br><span class="line">            <span class="built_in">CMGetAttachment</span>(imageSampleBuffer, kCGImagePropertyExifDictionary, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (exifAttachments) &#123;</span><br><span class="line">            <span class="comment">// Do something with the attachments.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Continue as appropriate.</span></span><br><span class="line">    &#125;];</span><br></pre></td></tr></table></figure>

<h2 id="4-5-录制预览"><a href="#4-5-录制预览" class="headerlink" title="4.5 录制预览"></a>4.5 录制预览</h2><p>可以提供给用户一个 preview，用来展示正在通过摄像头录制的内容 (使用 preview layer)，或者正在通过麦克风记录的音频内容 (通过监听 audio channel)。</p>
<h3 id="4-5-1-视频预览-AVCaptureVideoPreviewLayer"><a href="#4-5-1-视频预览-AVCaptureVideoPreviewLayer" class="headerlink" title="4.5.1 视频预览(AVCaptureVideoPreviewLayer)"></a>4.5.1 视频预览(AVCaptureVideoPreviewLayer)</h3><h4 id="1-AVCaptureVideoPreviewLayer类"><a href="#1-AVCaptureVideoPreviewLayer类" class="headerlink" title="1. AVCaptureVideoPreviewLayer类"></a>1. AVCaptureVideoPreviewLayer类</h4><p>使用 AVCaptureVideoPreviewLayer 可以进行视频预览。 <code>AVCaptureVideoPreviewLayer</code>是<code>CALayer</code>的子类. 进行视频预览不需要设置任何的 output 对象。</p>
<p>大体上，video preview layer 的性质与<code>CALayer</code>类似。你可以对图像进行缩放，向操作其他任何 layer 一样进行 transformations，rotations 等操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureVideoPreviewLayer</span> : <span class="title">CALayer</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)layerWithSession:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSession:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)layerWithSessionWithNoConnection:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithSessionWithNoConnection:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>) <span class="built_in">AVCaptureSession</span> *session;</span><br><span class="line">- (<span class="keyword">void</span>)setSessionWithNoConnection:(<span class="built_in">AVCaptureSession</span> *)session;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVCaptureConnection</span> *connection;</span><br><span class="line"><span class="comment">/* 指示图层如何在其范围内显示视频内容。(为啥叫重力模式？)</span></span><br><span class="line"><span class="comment">   Preview layer 支持三种重力模式</span></span><br><span class="line"><span class="comment">      AVLayerVideoGravityResizeAspect: 保持视频款高比, 当视频内容不能铺满屏幕时, 不足的部分使用黑色背景进行填充.</span></span><br><span class="line"><span class="comment">      AVLayerVideoGravityResizeAspectFill: 保持视频款高比, 但是会铺满整个屏幕, 必要时会对视频内容进行裁剪.</span></span><br><span class="line"><span class="comment">      AVLayerVideoGravityResize: 拉伸视频内容铺满屏幕, 可能导致图像变形.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">copy</span>) <span class="built_in">AVLayerVideoGravity</span> videoGravity;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> previewing;</span><br><span class="line">- (<span class="built_in">CGPoint</span>)captureDevicePointOfInterestForPoint:(<span class="built_in">CGPoint</span>)pointInLayer;</span><br><span class="line">- (<span class="built_in">CGPoint</span>)pointForCaptureDevicePointOfInterest:(<span class="built_in">CGPoint</span>)captureDevicePointOfInterest;</span><br><span class="line">- (<span class="built_in">CGRect</span>)metadataOutputRectOfInterestForRect:(<span class="built_in">CGRect</span>)rectInLayerCoordinates;</span><br><span class="line">- (<span class="built_in">CGRect</span>)rectForMetadataOutputRectOfInterest:(<span class="built_in">CGRect</span>)rectInMetadataOutputCoordinates;</span><br><span class="line">- (<span class="keyword">nullable</span> <span class="built_in">AVMetadataObject</span> *)transformedMetadataObjectForMetadataObject:(<span class="built_in">AVMetadataObject</span> *)metadataObject;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用 AVCaptureVideoDataOutput 类可以在视频展示给用户预览之前对视频进行处理。</p>
<p>与 capture output 不同，一个 video preview layer 会强引用与其相关联的 session。这是为了确保在进行视频预览时 session 不会被销毁。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureSession</span> *captureSession = &lt;#Get a capture session#&gt;;</span><br><span class="line"><span class="built_in">CALayer</span> *viewLayer = &lt;#Get a layer from the view <span class="keyword">in</span> which you want to present the preview#&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVCaptureVideoPreviewLayer</span> *captureVideoPreviewLayer = [[<span class="built_in">AVCaptureVideoPreviewLayer</span> alloc] initWithSession:captureSession];</span><br><span class="line">[viewLayer addSublayer:captureVideoPreviewLayer];</span><br></pre></td></tr></table></figure>

<h4 id="2-预览时使用点击聚焦功能"><a href="#2-预览时使用点击聚焦功能" class="headerlink" title="2. 预览时使用点击聚焦功能"></a>2. 预览时使用点击聚焦功能</h4><p>在 preview layer 上实现点击聚焦功能时，需要注意视频方向、视频重力模式以及可能预览设置了视频镜像。参见代码示例 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/content/samplecode/AVCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010112">AVCam-iOS: Using AVFoundation to Capture Images and Movies</a>.</p>
<h3 id="4-5-2-展示声音等级-AVCaptureAudioChannel"><a href="#4-5-2-展示声音等级-AVCaptureAudioChannel" class="headerlink" title="4.5.2 展示声音等级(AVCaptureAudioChannel)"></a>4.5.2 展示声音等级(AVCaptureAudioChannel)</h3><p>要在 capture connection 中检测声音的均值和峰值，可以使用 AVCaptureAudioChannel 对象。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVCaptureAudioChannel</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> averagePowerLevel;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">float</span> peakHoldLevel;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="keyword">float</span> volume;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>, <span class="keyword">getter</span>=isEnabled) <span class="built_in">BOOL</span> enabled;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>声音等级不能使用 KVO 的方式获取，所以需要根据界面更新的需求定时进行轮询 (比如每秒 10 次)。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVCaptureAudioDataOutput</span> *audioDataOutput = &lt;#Get the audio data output#&gt;;</span><br><span class="line"><span class="built_in">NSArray</span> *connections = audioDataOutput.connections;</span><br><span class="line"><span class="keyword">if</span> ([connections count] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// There should be only one connection to an AVCaptureAudioDataOutput.</span></span><br><span class="line">    <span class="built_in">AVCaptureConnection</span> *connection = [connections objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSArray</span> *audioChannels = connection.audioChannels;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">AVCaptureAudioChannel</span> *channel <span class="keyword">in</span> audioChannels) &#123;</span><br><span class="line">        <span class="keyword">float</span> avg = channel.averagePowerLevel;</span><br><span class="line">        <span class="keyword">float</span> peak = channel.peakHoldLevel;</span><br><span class="line">        <span class="comment">// Update the level meter user interface.</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-6-示例-捕捉视频帧为UIImage对象"><a href="#4-6-示例-捕捉视频帧为UIImage对象" class="headerlink" title="4.6 示例: 捕捉视频帧为UIImage对象"></a>4.6 示例: 捕捉视频帧为UIImage对象</h2><p>接下来的代码简单示例了如何捕捉视频，并将捕捉到的视频帧转换为 UIImage 对象:</p>
<ul>
<li>创建<code>AVCaptureSession</code>对象</li>
<li>找到合适类型的<code>AVCaptureDevice</code>对象进行输入</li>
<li>为设备创建<code>AVCaptureDeviceInput</code>对象</li>
<li>创建<code>AVCaptureVideoDataOutput</code>对象获取视频帧</li>
<li>实现<code>AVCaptureVideoDataOutput</code>的代理</li>
<li>实现一个方法将接收到的<code>CMSampleBuffer</code>转换为<code>UIImage</code></li>
</ul>
<blockquote>
<p>提示：为了展示核心代码，这份示例省略了某些内容，比如内存管理和通知的移除等。使用 AV Foundation 之前，你最好已经拥有 Cocoa 框架的使用经验。</p>
</blockquote>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)config &#123;</span><br><span class="line">    <span class="comment">// 1. 创建和配置 Capture Session，用来协调 input 和 output 之间的数据流。</span></span><br><span class="line">    <span class="built_in">AVCaptureSession</span> *session = [[<span class="built_in">AVCaptureSession</span> alloc] init];</span><br><span class="line">    session.sessionPreset = <span class="built_in">AVCaptureSessionPresetMedium</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 创建和配置 Device 和 Device Input。AVCaptureDevic表示采集设备，AVCaptureInput用来配置 采集设备的端口(一台设备有一个或多个端口)。通常使用默认配置的capture input</span></span><br><span class="line">    <span class="built_in">AVCaptureDevice</span> *device =</span><br><span class="line">            [<span class="built_in">AVCaptureDevice</span> defaultDeviceWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">NSError</span> *error = <span class="literal">nil</span>;</span><br><span class="line">    <span class="built_in">AVCaptureDeviceInput</span> *input =  <span class="comment">//如果找不到合适的设备，error不为空</span></span><br><span class="line">            [<span class="built_in">AVCaptureDeviceInput</span> deviceInputWithDevice:device error:&amp;error];</span><br><span class="line">    <span class="keyword">if</span> (!input) &#123;</span><br><span class="line">        <span class="comment">// Handle the error appropriately.</span></span><br><span class="line">    &#125;</span><br><span class="line">    [session addInput:input];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 创建和配置 Video Data Output。使用 AVCaptureVideoDataOutput处理未压缩的视频帧。</span></span><br><span class="line">    <span class="built_in">AVCaptureVideoDataOutput</span> *output = [[<span class="built_in">AVCaptureVideoDataOutput</span> alloc] init];</span><br><span class="line">    [session addOutput:output];</span><br><span class="line">    output.videoSettings =</span><br><span class="line">                    @&#123; (<span class="built_in">NSString</span> *)kCVPixelBufferPixelFormatTypeKey : @(kCVPixelFormatType_32BGRA) &#125;; <span class="comment">//配置像素格式</span></span><br><span class="line">    output.minFrameDuration = <span class="built_in">CMTimeMake</span>(<span class="number">1</span>, <span class="number">15</span>); <span class="comment">//最小帧率。将帧率限制为15fps（1/15 sec）</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">dispatch_queue_t</span> queue = dispatch_queue_create(<span class="string">&quot;MyQueue&quot;</span>, <span class="literal">NULL</span>); <span class="comment">// 提供串行队列. 在此队列上回调</span></span><br><span class="line">    [output setSampleBufferDelegate:<span class="keyword">self</span> queue:queue];</span><br><span class="line">    dispatch_release(queue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 实现 Sample Buffer 代理方法。注意该方法是在指定的队列上调用的。如果要更新UI，必须在主线程上。</span></span><br><span class="line">- (<span class="keyword">void</span>)captureOutput:(<span class="built_in">AVCaptureOutput</span> *)captureOutput</span><br><span class="line">         didOutputSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer</span><br><span class="line">         fromConnection:(<span class="built_in">AVCaptureConnection</span> *)connection &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将转换为 UIImage 的操作代码参见 [Converting CMSampleBuffer to a UIImage Object](https://developer.apple.com/library/content/documentation/AudioVideo/Conceptual/AVFoundationPG/Articles/06_MediaRepresentations.html#//apple_ref/doc/uid/TP40010188-CH2-SW4).</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = imageFromSampleBuffer(sampleBuffer);</span><br><span class="line">    <span class="comment">// Add your code here that uses the image.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 配置 capture session 之后，需要确保应用有访问相机的权限.</span></span><br><span class="line">- (<span class="keyword">void</span>)checkAccess &#123;</span><br><span class="line">  <span class="built_in">NSString</span> *mediaType = <span class="built_in">AVMediaTypeVideo</span>;</span><br><span class="line">  [<span class="built_in">AVCaptureDevice</span> requestAccessForMediaType:mediaType completionHandler:^(<span class="built_in">BOOL</span> granted) &#123;</span><br><span class="line">      <span class="keyword">if</span> (granted)&#123;</span><br><span class="line">          <span class="comment">//Granted access to mediaType</span></span><br><span class="line">          [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">YES</span>];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//Not granted access to mediaType</span></span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">          [[[<span class="built_in">UIAlertView</span> alloc] initWithTitle:<span class="string">@&quot;AVCam!&quot;</span></span><br><span class="line">                                      message:<span class="string">@&quot;AVCam doesn&#x27;t have permission to use Camera, please change privacy settings&quot;</span></span><br><span class="line">                                     delegate:<span class="keyword">self</span></span><br><span class="line">                            cancelButtonTitle:<span class="string">@&quot;OK&quot;</span></span><br><span class="line">                            otherButtonTitles:<span class="literal">nil</span>] show];</span><br><span class="line">                  [<span class="keyword">self</span> setDeviceAuthorized:<span class="literal">NO</span>];</span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6. 开始和停止</span></span><br><span class="line"><span class="comment">// 当获取到相应的访问权限之后，可以使用 startRunning 方法开始录制。startRunning 会阻塞线程，所以需要异步调用，以免阻塞主线程。</span></span><br><span class="line">[session startRunning];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 stopRunning 可以停止录制.</span></span><br><span class="line">[session stopRunning];</span><br></pre></td></tr></table></figure>

<h2 id="4-7-高帧率视频捕捉"><a href="#4-7-高帧率视频捕捉" class="headerlink" title="4.7 高帧率视频捕捉"></a>4.7 高帧率视频捕捉</h2><p>iOS 7.0 在选定的硬件上引入了高帧率视频捕获支持（也称为“SloMo”视频）。完整的 AVFoundation 框架支持高帧率内容。</p>
<p>可以使用 AVCaptureDeviceFormat 类确定设备的捕获能力。此类具有返回支持的媒体类型、帧速率、视野、最大缩放系数、是否支持视频稳定等的方法。</p>
<ul>
<li>捕捉：支持每秒 60 帧 (fps) 、720p（1280 x 720 像素）分辨率，包括视频稳定和可丢弃的 P 帧（H264 编码电影的一项功能，即使在较慢和较旧的硬件上也可以流畅地播放电影。 )</li>
<li>播放：增强了对慢速和快速播放的音频支持，允许音频的时间音高可以在更慢或更快的速度下保存。</li>
<li>编辑：完全支持可变 compositions 中的缩放编辑。</li>
<li>导出：支持 60 fps 影片时，导出提供两个选项。可以保留可变帧速率、慢动作或快动作，或者将电影转换为任意较慢的帧速率，例如每秒 30 帧。</li>
</ul>
<p>SloPoke 示例代码演示了 AVFoundation 对快速视频捕获的支持、确定硬件是否支持高帧率视频捕获、使用各种速率和时间间距算法进行播放以及编辑（包括为部分合成设置时间比例）。</p>
<h3 id="4-7-1-播放"><a href="#4-7-1-播放" class="headerlink" title="4.7.1 播放"></a>4.7.1 播放</h3><p>AVPlayer 的实例通过设置 setRate: 方法值自动管理大部分播放速度。该值用作播放速度的乘数。值 1.0 会导致正常播放，0.5 会以半速播放，5.0 会比正常播放快五倍，依此类推。</p>
<p>AVPlayerItem 对象支持 audioTimePitchAlgorithm 属性（指示缩放音频编辑时，音频音高的处理算法）。此属性允许您使用 Time Pitch Algorithm Settings 常量指定在以各种帧速率播放电影时如何播放音频。</p>
<p>下表显示了支持的时间音高算法、质量、算法是否导致音频匹配特定的帧速率，以及每种算法支持的帧速率范围。</p>
<table>
<thead>
<tr>
<th align="left">Time pitch algorithm</th>
<th align="left">Quality</th>
<th align="left">Snaps to specific frame rate</th>
<th align="left">Rate range</th>
</tr>
</thead>
<tbody><tr>
<td align="left">AVAudioTimePitchAlgorithmLowQualityZeroLatency(低质量零延迟)</td>
<td align="left">低质量，适用于快进、快退或低质量语音。</td>
<td align="left"><code>YES</code></td>
<td align="left">0.5, 0.666667, 0.8, 1.0, 1.25, 1.5, 2.0 rates.</td>
</tr>
<tr>
<td align="left">AVAudioTimePitchAlgorithmTimeDomain(时域)</td>
<td align="left">质量适中，计算成本较低，适用于语音。</td>
<td align="left"><code>NO</code></td>
<td align="left">0.5–2x rates.</td>
</tr>
<tr>
<td align="left">AVAudioTimePitchAlgorithmSpectral(光谱)</td>
<td align="left">最高质量，最昂贵的计算，保留原始项目的音高。</td>
<td align="left"><code>NO</code></td>
<td align="left">1/32–32 rates.</td>
</tr>
<tr>
<td align="left">AVAudioTimePitchAlgorithmVarispeed(变速)</td>
<td align="left">无需音高校正的高质量播放。</td>
<td align="left"><code>NO</code></td>
<td align="left">1/32–32 rates.</td>
</tr>
</tbody></table>
<h3 id="4-7-2-编辑"><a href="#4-7-2-编辑" class="headerlink" title="4.7.2 编辑"></a>4.7.2 编辑</h3><p>编辑时，您使用 AVMutableComposition 类来构建临时编辑。</p>
<ul>
<li>使用类方法 composition 创建一个新的 AVMutableComposition 实例。</li>
<li>使用 insertTimeRange:ofAsset:atTime:error: 方法插入视频资产。</li>
<li>使用 scaleTimeRange:toDuration: 设置部分 composition 的时间比例。</li>
</ul>
<h3 id="4-7-3-导出"><a href="#4-7-3-导出" class="headerlink" title="4.7.3 导出"></a>4.7.3 导出</h3><p>导出 60 fps 视频使用 AVAssetExportSession 类来导出资产。可以使用两种技术导出内容：</p>
<ul>
<li>使用 AVAssetExportPresetPassthrough 预设来避免重新编码电影。它使用标记为 60 fps 部分、减速部分或加速部分的媒体部分重新定时媒体。</li>
<li>使用恒定帧速率导出以获得最大的播放兼容性。将视频合成的 frameDuration 属性设置为 30 fps。还可以通过设置导出会话的 audioTimePitchAlgorithm 属性来指定时间音高。</li>
</ul>
<h3 id="4-7-4-录制"><a href="#4-7-4-录制" class="headerlink" title="4.7.4 录制"></a>4.7.4 录制</h3><p>使用 AVCaptureMovieFileOutput 类捕获高帧率视频，该类自动支持高帧率录制。它将自动选择正确的 H264 音高电平和比特率。</p>
<p>要进行自定义录制，您必须使用 AVAssetWriter 类，这需要一些额外的设置。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">assetWriterInput.expectsMediaDataInRealTime=<span class="literal">YES</span>；<span class="comment">// input是否应针对实时源调整其对媒体数据的处理</span></span><br></pre></td></tr></table></figure>

<p>此设置确保捕获可以跟上传入的数据。</p>
<h1 id="五、Asset的读、写、重编码"><a href="#五、Asset的读、写、重编码" class="headerlink" title="五、Asset的读、写、重编码"></a>五、Asset的读、写、重编码</h1><blockquote>
<p>Asset  → AssetReader → AssetReaderOutput → 内存 → AssetWriteInput → AssetWrite → 文件URL</p>
</blockquote>
<p>可以使用AVAssetExportSession 、 <em>AVAssetReader</em> 、<em>AVAssetWriter</em> 对象，完成一些的音视频资源操作需求，比如：</p>
<ul>
<li>可以通过一个导出会话 (<em>export session</em>)，将一个已存在的 asset 进行重新编码为，一些已经预设置好的常用格式 (commonly-used presets)。</li>
<li>协同使用 <em>AVAssetReader</em> 和 <em>AVAssetWriter</em> 对象，可以实现更多的自定义设置，如可以选择将哪些 track 输出到文件中，对资源进行修改。<ul>
<li>在需要对 asset 内容进行操作时使用<code>AVAssetReader</code>。例如，需要读取 audio track 绘制音频波形图.。</li>
<li>在需要将媒体 (比如 sample buffers 或者静态图像) 转换为一个 asset 时，使用<code>AVAssetWriter</code>。</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ul>
<li>这两个类不适用于实时处理。</li>
<li><code>AVAssetReader</code>不能用来读取 HTTP 直播流这样的实时资源。</li>
<li>如果在实时数据处理 (比如 AVCaptureOutput) 中使用了<code>AVAssetWriter</code>，需要将<code>AVAssetWriter</code>的属性 expectsMediaDataInRealTime 设置为<code>YES</code>，这样可以保证以正确的顺序写入文件。</li>
</ul>
<h2 id="5-1-读取Asset-AVAssetReader"><a href="#5-1-读取Asset-AVAssetReader" class="headerlink" title="5.1 读取Asset(AVAssetReader)"></a>5.1 读取Asset(AVAssetReader)</h2><h3 id="AVAssetReader-和-Output-类"><a href="#AVAssetReader-和-Output-类" class="headerlink" title="AVAssetReader 和 Output 类"></a>AVAssetReader 和 Output 类</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReader</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderWithAsset:(<span class="built_in">AVAsset</span> *)asset error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAsset:(<span class="built_in">AVAsset</span> *)asset error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">retain</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAsset</span> *asset;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">AVAssetReaderStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">CMTimeRange</span> timeRange;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetReaderOutput</span> *&gt; *outputs;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddOutput:(<span class="built_in">AVAssetReaderOutput</span> *)output;</span><br><span class="line">- (<span class="keyword">void</span>)addOutput:(<span class="built_in">AVAssetReaderOutput</span> *)output;</span><br><span class="line"><span class="comment">//开始读取</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)startReading;</span><br><span class="line">- (<span class="keyword">void</span>)cancelReading;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>每个<code>AVAssetReader</code>对象只能被关联到一个 asset，但是这个 asset 可能包含多个 track。因此，在开始读取之前，需要为 asset reader配置一个 AVAssetReaderOutput 的子类来设置媒体数据的读取方式。</p>
<p><code>AVAssetReaderOutput</code>有三个子类可以用来读取 asset：AVAssetReaderTrackOutput、AVAssetReaderAudioMixOutput、AVAssetReaderVideoCompositionOutput。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从 AVAssetReader 读取通用媒体类型</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderOutput</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="comment">// 是否输出样本数据的副本。默认值为YES。</span></span><br><span class="line"><span class="comment">// 可以通过将值设置为 NO 来禁用默认行为，注意此时只能引用，而不能修改它们，因为修改共享缓冲区的行为是未定义的。</span></span><br><span class="line"><span class="comment">// 如果不需要修改样本数据，禁用复制可能会提高性能。如果你打算修改它返回的有样本数据，置为YES是合适的。</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> alwaysCopiesSampleData;</span><br><span class="line"><span class="comment">// 复制下一个样本缓冲区</span></span><br><span class="line">- (<span class="built_in">CMSampleBufferRef</span>)copyNextSampleBuffer <span class="built_in">CF_RETURNS_RETAINED</span>;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderOutput</span> (<span class="title">AVAssetReaderOutputRandomAccess</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> supportsRandomAccess;</span><br><span class="line">- (<span class="keyword">void</span>)resetForReadingTimeRanges:(<span class="built_in">NSArray</span>&lt;<span class="built_in">NSValue</span> *&gt; *)timeRanges;</span><br><span class="line">- (<span class="keyword">void</span>)markConfigurationAsFinal;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从 AVAssetReader 的 AVAsset 的单个 AVAssetTrack 读取媒体数据。</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderTrackOutput</span> : <span class="title">AVAssetReaderOutput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderTrackOutputWithTrack:(<span class="built_in">AVAssetTrack</span> *)track outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithTrack:(<span class="built_in">AVAssetTrack</span> *)track outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVAssetTrack</span> *track;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *outputSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取由 AVAssetReader 的 AVAsset 的一个或多个 AVAssetTrack 中的音频混合产生的音频样本。</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderAudioMixOutput</span> : <span class="title">AVAssetReaderOutput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderAudioMixOutputWithAudioTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)audioTracks audioSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)audioSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithAudioTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)audioTracks audioSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)audioSettings <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *audioTracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *audioSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioMix</span> *audioMix;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVAudioTimePitchAlgorithm</span> audioTimePitchAlgorithm;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取已从 AVAssetReader 的 AVAsset 的一个或多个 AVAssetTracks 中的帧合成在一起的视频帧。</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetReaderVideoCompositionOutput</span> : <span class="title">AVAssetReaderOutput</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetReaderVideoCompositionOutputWithVideoTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)videoTracks videoSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)videoSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithVideoTracks:(<span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *)videoTracks videoSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)videoSettings <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetTrack</span> *&gt; *videoTracks;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *videoSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">AVVideoComposition</span> *videoComposition;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="keyword">id</span> &lt;<span class="built_in">AVVideoCompositing</span>&gt; customVideoCompositor;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="5-1-1-创建-AVAssetReader"><a href="#5-1-1-创建-AVAssetReader" class="headerlink" title="5.1.1 创建 AVAssetReader"></a>5.1.1 创建 AVAssetReader</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 AVAssetReader 对象需要一个 asset 对象</span></span><br><span class="line"><span class="built_in">NSError</span> *outError;</span><br><span class="line"><span class="built_in">AVAsset</span> *someAsset = &lt;#<span class="built_in">AVAsset</span> that you want to read#&gt;;</span><br><span class="line"><span class="built_in">AVAssetReader</span> *assetReader = [<span class="built_in">AVAssetReader</span> assetReaderWithAsset:someAsset error:&amp;outError];</span><br><span class="line"><span class="comment">// 需要检查 assetReader 是否创建成功, 如果失败, error 会包含相关的错误信息.</span></span><br><span class="line"><span class="built_in">BOOL</span> success = (assetReader != <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-设置-AVAssetReaderOutput"><a href="#5-1-2-设置-AVAssetReaderOutput" class="headerlink" title="5.1.2 设置 AVAssetReaderOutput"></a>5.1.2 设置 AVAssetReaderOutput</h3><p>成功创建 assetReader 后，至少需要设置一个 output 来接收读取的媒体数据。确保 output 的属性 alwaysCopiesSampleData 被设置为<code>NO</code>，这样能提升性能。本章所有的实例代码中，该属性都设置为<code>NO</code>。</p>
<h4 id="1-AVAssetReaderTrackOutput"><a href="#1-AVAssetReaderTrackOutput" class="headerlink" title="1. AVAssetReaderTrackOutput"></a>1. AVAssetReaderTrackOutput</h4><p>如果只是需要从一个或多个 track 中读取数据并修改其格式，那么可以使用<code>AVAssetReaderTrackOutput</code>。</p>
<p>要解压一个 audio track 为 Linear PCM，需要进行如下设置:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *localAsset = assetReader.asset;</span><br><span class="line"><span class="comment">// Get the audio track to read.</span></span><br><span class="line"><span class="built_in">AVAssetTrack</span> *audioTrack = [[localAsset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line"><span class="comment">// Decompression settings for Linear PCM</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line"><span class="comment">// Create the output with the audio track and decompression settings.</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *trackOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:audioTrack outputSettings:decompressionAudioSettings];</span><br><span class="line"><span class="comment">// Add the output to the reader if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:trackOutput])</span><br><span class="line">    [assetReader addOutput:trackOutput];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>要以存储时的格式读取数据，将参数<code>outputSettings</code>设置为<code>nil</code>.</p>
</blockquote>
<h4 id="2-AVAssetReaderAudioMixOutput"><a href="#2-AVAssetReaderAudioMixOutput" class="headerlink" title="2. AVAssetReaderAudioMixOutput"></a>2. AVAssetReaderAudioMixOutput</h4><p>对于使用 AVAudioMix 和 AVVideoComposition 处理过的 asset，需要使用<code>AVAssetReaderAudioMixOutput</code> 和 <code>AVAssetReaderVideoCompositionOutput</code>进行读取。</p>
<p>通常，当从 AVComposition 对象中读取数据时，会使用到这些 output 对象。</p>
<p>使用一个<code>AVAssetReaderAudioMixOutput</code>对象，可以读取 asset 中的多个 audio track。下面的代码展示了如何使用 asset 中所有的 audio track 创建一个<code>AVAssetReaderAudioMixOutput</code>对象，解压缩 audio track 为 Linear PCM，并为 output 设置音频混合方式 (audio mix)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAudioMix</span> *audioMix = &lt;#<span class="string">&quot;一个 AVAudioMix，指定如何混合来自 AVAsset 的音轨&quot;</span>#&gt;;</span><br><span class="line"><span class="comment">// 假设assetReader 是用一个AVComposition 对象初始化的。</span></span><br><span class="line"><span class="built_in">AVComposition</span> *composition = (<span class="built_in">AVComposition</span> *)assetReader.asset;</span><br><span class="line"><span class="comment">// 获取要读取的音轨</span></span><br><span class="line"><span class="built_in">NSArray</span> *audioTracks = [composition tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>];</span><br><span class="line"><span class="comment">// 获取线性 PCM 的解压设置</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line"><span class="comment">// 使用音轨和解压缩设置创建音频混合输出。</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *audioMixOutput = [<span class="built_in">AVAssetReaderAudioMixOutput</span> assetReaderAudioMixOutputWithAudioTracks:audioTracks audioSettings:decompressionAudioSettings];</span><br><span class="line"><span class="comment">// 关联</span></span><br><span class="line">audioMixOutput.audioMix = audioMix;</span><br><span class="line"><span class="comment">// 将output添加到reader</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:audioMixOutput])</span><br><span class="line">    [assetReader addOutput:audioMixOutput];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>设置参数<code>audioSettings</code> 为 <code>nil</code>，将返回未被压缩的样本数据。对<code>AVAssetReaderVideoCompositionOutput</code>也一样。</p>
</blockquote>
<h4 id="3-AVAssetReaderVideoCompositionOutput"><a href="#3-AVAssetReaderVideoCompositionOutput" class="headerlink" title="3. AVAssetReaderVideoCompositionOutput"></a>3. AVAssetReaderVideoCompositionOutput</h4><p><code>AVAssetReaderVideoCompositionOutput</code> 的使用方法大致与<code>AVAssetReaderAudioMixOutput</code> 相同，可以从 asset 中读取多个 video track。下面的代码示例了如何从多个 video track 中读取数据，并解压为 ARGB:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVVideoComposition</span> *videoComposition = &lt;#<span class="string">&quot;一个 AVVideoComposition，指定如何合成来自 AVAsset 的视频轨道&quot;</span>#&gt;;</span><br><span class="line"><span class="comment">// 假设assetReader 是用一个AVComposition 初始化的</span></span><br><span class="line"><span class="built_in">AVComposition</span> *composition = (<span class="built_in">AVComposition</span> *)assetReader.asset;</span><br><span class="line"><span class="comment">// 获取要读取的视频轨道。</span></span><br><span class="line"><span class="built_in">NSArray</span> *videoTracks = [composition tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line"><span class="comment">// ARGB 的解压设置</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *decompressionVideoSettings = @&#123; (<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kCVPixelFormatType_32ARGB], (<span class="keyword">id</span>)kCVPixelBufferIOSurfacePropertiesKey : [<span class="built_in">NSDictionary</span> dictionary] &#125;;</span><br><span class="line"><span class="comment">// 使用视频轨道和解压缩设置创建视频合成输出</span></span><br><span class="line"><span class="built_in">AVAssetReaderOutput</span> *videoCompositionOutput = [<span class="built_in">AVAssetReaderVideoCompositionOutput</span> assetReaderVideoCompositionOutputWithVideoTracks:videoTracks videoSettings:decompressionVideoSettings];</span><br><span class="line"><span class="comment">// 关联</span></span><br><span class="line">videoCompositionOutput.videoComposition = videoComposition;</span><br><span class="line"><span class="comment">// Add the output to the reader if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetReader canAddOutput:videoCompositionOutput])</span><br><span class="line">    [assetReader addOutput:videoCompositionOutput];</span><br></pre></td></tr></table></figure>

<h3 id="5-1-3-读取-Asset-中的媒体数据"><a href="#5-1-3-读取-Asset-中的媒体数据" class="headerlink" title="5.1.3 读取 Asset 中的媒体数据"></a>5.1.3 读取 Asset 中的媒体数据</h3><p>按需设置 outputs 之后，调用 asset reader 的方法 startReading 开始读取数据。然后使用方法 copyNextSampleBuffer 从 output 中开始检索、获取媒体数据。示例如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Start the asset reader up.</span></span><br><span class="line">[<span class="keyword">self</span>.assetReader startReading];</span><br><span class="line"><span class="built_in">BOOL</span> done = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">while</span> (!done)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Copy the next sample buffer from the reader output.</span></span><br><span class="line">  <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderOutput copyNextSampleBuffer];</span><br><span class="line">  <span class="keyword">if</span> (sampleBuffer)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Do something with sampleBuffer here.</span></span><br><span class="line">    <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">    sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// Find out why the asset reader output couldn&#x27;t copy another sample buffer.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.assetReader.status == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetReader.error;</span><br><span class="line">      <span class="comment">// Handle the error here.</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// The asset reader output has read all of its samples.</span></span><br><span class="line">      done = <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-写入Asset-AVAssetWriter"><a href="#5-2-写入Asset-AVAssetWriter" class="headerlink" title="5.2 写入Asset(AVAssetWriter)"></a>5.2 写入Asset(AVAssetWriter)</h2><h3 id="AVAssetWriter-和-Input-类"><a href="#AVAssetWriter-和-Input-类" class="headerlink" title="AVAssetWriter 和 Input 类"></a>AVAssetWriter 和 Input 类</h3><p><a target="_blank" rel="noopener" href="https://developer.apple.com/reference/avfoundation/avassetwriter">AVAssetWriter</a> 将多个来源的数据以指定格式写入到单个文件中。Asset writer 并不与一个特定的 asset 相关联，但必须与要创建的输出文件相关联。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetWriter</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWriterWithURL:(<span class="built_in">NSURL</span> *)outputURL fileType:(<span class="built_in">AVFileType</span>)outputFileType error:(<span class="built_in">NSError</span> **)outError;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithURL:(<span class="built_in">NSURL</span> *)outputURL fileType:(<span class="built_in">AVFileType</span>)outputFileType error:(<span class="built_in">NSError</span> **)outError <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithContentType:(UTType *)outputContentType <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">NSURL</span> *outputURL;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>) <span class="built_in">AVFileType</span> outputFileType;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMediaType</span>&gt; *availableMediaTypes;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">AVAssetWriterStatus</span> status;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSError</span> *error;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldOptimizeForNetworkUse;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSURL</span> *directoryForTemporaryFiles;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVAssetWriterInput</span> *&gt; *inputs;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canApplyOutputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings forMediaType:(<span class="built_in">AVMediaType</span>)mediaType;</span><br><span class="line">- (<span class="built_in">BOOL</span>)canAddInput:(<span class="built_in">AVAssetWriterInput</span> *)input;</span><br><span class="line">- (<span class="keyword">void</span>)addInput:(<span class="built_in">AVAssetWriterInput</span> *)input;</span><br><span class="line">- (<span class="built_in">BOOL</span>)startWriting;</span><br><span class="line">- (<span class="keyword">void</span>)startSessionAtSourceTime:(<span class="built_in">CMTime</span>)startTime;</span><br><span class="line">- (<span class="keyword">void</span>)endSessionAtSourceTime:(<span class="built_in">CMTime</span>)endTime;</span><br><span class="line">- (<span class="keyword">void</span>)cancelWriting;</span><br><span class="line">- (<span class="built_in">BOOL</span>)finishWriting API_DEPRECATED_WITH_REPLACEMENT(<span class="string">&quot;finishWritingWithCompletionHandler:&quot;</span>;</span><br><span class="line">- (<span class="keyword">void</span>)finishWritingWithCompletionHandler:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))handler;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//.....还有一些分类，此处不再列出.....</span></span><br><span class="line">                                                      </span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">AVAssetWriterDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"><span class="keyword">@optional</span></span><br><span class="line">- (<span class="keyword">void</span>)assetWriter:(<span class="built_in">AVAssetWriter</span> *)writer didOutputSegmentData:(<span class="built_in">NSData</span> *)segmentData segmentType:(<span class="built_in">AVAssetSegmentType</span>)segmentType segmentReport:(<span class="built_in">AVAssetSegmentReport</span> *)segmentReport;</span><br><span class="line">- (<span class="keyword">void</span>)assetWriter:(<span class="built_in">AVAssetWriter</span> *)writer didOutputSegmentData:(<span class="built_in">NSData</span> *)segmentData segmentType:(<span class="built_in">AVAssetSegmentType</span>)segmentType;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>由于一个 asset writer 可以从多个来源获取数据，所以需要为每个要写入的 track 创建对应的 AVAssetWriterInput 对象。</p>
<ul>
<li>接收 CMSampleBufferRef 类型的数据，使用<code>AVAssetWriterInput</code>对象</li>
<li>如果想要添加 CVPixelBufferRef 类型的数据，可以使用 AVAssetWriterInputPixelBufferAdaptor。</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">AVAssetWriterInput</span> : <span class="title">NSObject</span></span></span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWriterInputWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings;</span><br><span class="line">+ (<span class="keyword">instancetype</span>)assetWriterInputWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings sourceFormatHint:(<span class="built_in">CMFormatDescriptionRef</span>)sourceFormatHint;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings;</span><br><span class="line">- (<span class="keyword">instancetype</span>)initWithMediaType:(<span class="built_in">AVMediaType</span>)mediaType outputSettings:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *)outputSettings sourceFormatHint:(<span class="built_in">CMFormatDescriptionRef</span>)sourceFormatHint;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">AVMediaType</span> mediaType;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *outputSettings;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">CMFormatDescriptionRef</span> sourceFormatHint;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">AVMetadataItem</span> *&gt; *metadata;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>) <span class="built_in">BOOL</span> readyForMoreMediaData;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> expectsMediaDataInRealTime;</span><br><span class="line">- (<span class="keyword">void</span>)requestMediaDataWhenReadyOnQueue:(<span class="built_in">dispatch_queue_t</span>)queue usingBlock:(<span class="keyword">void</span> (^)(<span class="keyword">void</span>))block;</span><br><span class="line">- (<span class="built_in">BOOL</span>)appendSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>)sampleBuffer;</span><br><span class="line">- (<span class="keyword">void</span>)markAsFinished;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-1-创建-AVAssetWriter"><a href="#5-2-1-创建-AVAssetWriter" class="headerlink" title="5.2.1 创建 AVAssetWriter"></a>5.2.1 创建 AVAssetWriter</h3><p>创建 AVAssetWriter 对象需要指定一个文件 URL 和文件格式。下面的代码示例了如何初始化一个 AVAssetWriter 用来创建 QuickTime 电影.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSError</span> *outError;</span><br><span class="line"><span class="built_in">NSURL</span> *outputURL = &lt;#<span class="string">&quot;NSURL对象，表示您要保存视频的URL&quot;</span>#&gt;;</span><br><span class="line"><span class="built_in">AVAssetWriter</span> *assetWriter = [<span class="built_in">AVAssetWriter</span> assetWriterWithURL:outputURL</span><br><span class="line">                                                      fileType:<span class="built_in">AVFileTypeQuickTimeMovie</span></span><br><span class="line">                                                         error:&amp;outError];</span><br><span class="line"><span class="built_in">BOOL</span> success = (assetWriter != <span class="literal">nil</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-2-2-设置-AVAssetWriterInput"><a href="#5-2-2-设置-AVAssetWriterInput" class="headerlink" title="5.2.2 设置 AVAssetWriterInput"></a>5.2.2 设置 AVAssetWriterInput</h3><p>要让 AVAssetWriter 能写入媒体数据，必须至少设置一个 asset writer input。</p>
<h4 id="1-AVAssetWriterInput"><a href="#1-AVAssetWriterInput" class="headerlink" title="1. AVAssetWriterInput"></a>1. AVAssetWriterInput</h4><p>例如要写入<code>CMSampleBufferRef</code>类型的数据，需要使用<code>AVAssetWriterInput</code>。下面的代码示例了将压缩的音频数据写入为 128 kbps 的 AAC 格式:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// // 将通道布局(channel layout)配置为立体声</span></span><br><span class="line">AudioChannelLayout stereoChannelLayout = &#123;</span><br><span class="line">    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,</span><br><span class="line">    .mChannelBitmap = <span class="number">0</span>,</span><br><span class="line">    .mNumberChannelDescriptions = <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 channel layout 对象转换为 NSData 对象</span></span><br><span class="line"><span class="built_in">NSData</span> *channelLayoutAsData = [<span class="built_in">NSData</span> dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 128 kbps AAC 的压缩设置</span></span><br><span class="line"><span class="built_in">NSDictionary</span> *compressionAudioSettings = @&#123;</span><br><span class="line">    <span class="built_in">AVFormatIDKey</span>         : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatMPEG4AAC],</span><br><span class="line">    <span class="built_in">AVEncoderBitRateKey</span>   : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">128000</span>],</span><br><span class="line">    <span class="built_in">AVSampleRateKey</span>       : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">44100</span>],</span><br><span class="line">    <span class="built_in">AVChannelLayoutKey</span>    : channelLayoutAsData,</span><br><span class="line">    <span class="built_in">AVNumberOfChannelsKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInteger:<span class="number">2</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用压缩设置创建asset writer input，并将媒体类型指定为音频。</span></span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *assetWriterInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeAudio</span> outputSettings:compressionAudioSettings];</span><br><span class="line"><span class="comment">// Add the input to the writer if possible.</span></span><br><span class="line"><span class="keyword">if</span> ([assetWriter canAddInput:assetWriterInput])</span><br><span class="line">    [assetWriter addInput:assetWriterInput];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有 asset writer 初始化时<code>fileType</code>为 AVFileTypeQuickTimeMovie，参数<code>outputSettings</code>才能为 nil，意味着写入的文件格式为 QuickTime movie。</p>
</blockquote>
<p>使用属性 metadata 和 transform 可以为指定的 track 设置 metadata 和 transform。<em>（注意，需要在开始写入之前设置这两个属性才会生效）</em></p>
<p>当输入源为 video track 时，可以通过如下方式持有 video track 的原始 transform:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVAsset</span> *videoAsset = &lt;#<span class="string">&quot;具有至少一个视频轨道的 AVAsset&quot;</span>#&gt;;</span><br><span class="line"><span class="built_in">AVAssetTrack</span> *videoAssetTrack = [[videoAsset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>] objectAtIndex:<span class="number">0</span>];</span><br><span class="line">assetWriterInput.transform = videoAssetTrack.preferredTransform</span><br></pre></td></tr></table></figure>

<h4 id="2-AVAssetWriterInputPixelBufferAdaptor"><a href="#2-AVAssetWriterInputPixelBufferAdaptor" class="headerlink" title="2. AVAssetWriterInputPixelBufferAdaptor"></a>2. AVAssetWriterInputPixelBufferAdaptor</h4><p>在写入文件时，有时候可能会需要分配一个 pixel buffer，这时可以使用<code>AVAssetWriterInputPixelBufferAdaptor</code>类。为了提高效率，可以直接使用 pixel buffer adaptor 提供的 pixel buffer pool。下面的代码示例了创建了一个 pixel buffer 对象处理 RGB 色域:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSDictionary</span> *pixelBufferAttributes = @&#123;</span><br><span class="line">     kCVPixelBufferCGImageCompatibilityKey : [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>],</span><br><span class="line">     kCVPixelBufferCGBitmapContextCompatibilityKey : [<span class="built_in">NSNumber</span> numberWithBool:<span class="literal">YES</span>],</span><br><span class="line">     kCVPixelBufferPixelFormatTypeKey : [<span class="built_in">NSNumber</span> numberWithInt:kCVPixelFormatType_32ARGB]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">AVAssetWriterInputPixelBufferAdaptor</span> *inputPixelBufferAdaptor = [<span class="built_in">AVAssetWriterInputPixelBufferAdaptor</span> assetWriterInputPixelBufferAdaptorWithAssetWriterInput:<span class="keyword">self</span>.assetWriterInput sourcePixelBufferAttributes:pixelBufferAttributes];</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，所有的<code>AVAssetWriterInputPixelBufferAdaptor</code>对象都必须与一个 asset writer input 相关联 。这个 asset writer input 对象必须接收<code>AVMediaTypeVideo</code>类型的数据。</p>
</blockquote>
<h3 id="5-2-3-写入媒体数据"><a href="#5-2-3-写入媒体数据" class="headerlink" title="5.2.3 写入媒体数据"></a>5.2.3 写入媒体数据</h3><p>当配置完 asset writer 之后，就可以开始写入数据了。</p>
<p>下面的代码示例了从一个输入源读取数据并写入所有读取到的数据:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Prepare the asset writer for writing.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动写入过程</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriter startWriting];</span><br><span class="line"><span class="comment">// 开启一个写入会话 (sample-writing session)。</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">  Asset writer 的所有写入过程都通过这个 session 完成，并且 sesion 的时间范围决定了源媒体数据中哪个时间范围内的数据会被写入到文件中</span></span><br><span class="line"><span class="comment">  例如，只写入源数据的后一半的示例代码如下:</span></span><br><span class="line"><span class="comment">  CMTime halfAssetDuration = CMTimeMultiplyByFloat64(self.asset.duration, 0.5);</span></span><br><span class="line"><span class="comment">  [self.assetWriter startSessionAtSourceTime:halfAssetDuration];</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:kCMTimeZero];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当asset writer准备好接收媒体数据时，指定block、调用它的队列。</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriterInput requestMediaDataWhenReadyOnQueue:myInputSerialQueue usingBlock:^&#123;</span><br><span class="line">     <span class="comment">// 表示input是否准备好接受媒体数据。</span></span><br><span class="line">     <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterInput isReadyForMoreMediaData])</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 获取下一个样本缓冲区。</span></span><br><span class="line">          <span class="comment">// copyNextSampleBufferToWrite方法只是一个stub(桩代码/存根)。此存根的位置是您需要插入一些逻辑以返回表示你要写入的媒体数据的 CMSampleBufferRef 对象的位置。Sample buffers 可能来源于一个 asset reader output.</span></span><br><span class="line">          <span class="built_in">CMSampleBufferRef</span> nextSampleBuffer = [<span class="keyword">self</span> copyNextSampleBufferToWrite];</span><br><span class="line">          <span class="keyword">if</span> (nextSampleBuffer)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// 如果存在，则将下一个样本缓冲区附加到输出文件。</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterInput appendSampleBuffer:nextSampleBuffer];</span><br><span class="line">               <span class="built_in">CFRelease</span>(nextSampleBuffer);</span><br><span class="line">               nextSampleBuffer = <span class="literal">nil</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// 假设没有下一个样本缓冲区，意味着样本缓冲区源没有样本并将输入标记为已完成。</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterInput markAsFinished];</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>一般情况下，方法 endSessionAtSourceTime: 用来结束写入会话。但是如果文件已经写入完毕，则可以方法 finishWriting 结束写入会话。</p>
<h2 id="5-3-重编码Assets"><a href="#5-3-重编码Assets" class="headerlink" title="5.3 重编码Assets"></a>5.3 重编码Assets</h2><p>可以搭配使用 asset reader 和 asset writer 进行 asset 之间的转换。相比于使用<code>AVAssetExportSession</code>，使用这些对象可以更好的控制转换细节。例如：</p>
<ul>
<li>可以选择导出哪个 track</li>
<li>可以指定导出的文件格式</li>
<li>可以在转换过程中修改asset，如指定导出的时间范围。</li>
</ul>
<p>下面的代码片段示例了如何从一个 asset reader output 读取数据，并使用 asset writer input 写入这些数据.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *serializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个用于读写的串行队列</span></span><br><span class="line"><span class="built_in">dispatch_queue_t</span> serializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当asset writer准备好接收媒体数据时，指定block、调用它的队列。</span></span><br><span class="line">[<span class="keyword">self</span>.assetWriterInput requestMediaDataWhenReadyOnQueue:serializationQueue usingBlock:^&#123;</span><br><span class="line">     <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterInput isReadyForMoreMediaData])</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 获取asset reader output的下一个样本缓冲区</span></span><br><span class="line">          <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderOutput copyNextSampleBuffer];</span><br><span class="line">          <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If it exists, append this sample buffer to the output file.</span></span><br><span class="line">               <span class="built_in">BOOL</span> success = [<span class="keyword">self</span>.assetWriterInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">               <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">               sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">               <span class="comment">// Check for errors that may have occurred when appending the new sample buffer.</span></span><br><span class="line">               <span class="keyword">if</span> (!success &amp;&amp; <span class="keyword">self</span>.assetWriter.status == <span class="built_in">AVAssetWriterStatusFailed</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetWriter.error;</span><br><span class="line">                    <span class="comment">//Handle the error.</span></span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">//如果下一个样本缓冲区不存在， 定位asset reader output 无法提供另一个样本缓冲区的原因。</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">self</span>.assetReader.status == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSError</span> *failureError = <span class="keyword">self</span>.assetReader.error;</span><br><span class="line">                    <span class="comment">//Handle the error here.</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// The asset reader output已经听过所有数据，标记为已完成 </span></span><br><span class="line">                    [<span class="keyword">self</span>.assetWriterInput markAsFinished];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">               &#125;</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<h2 id="5-4-示例-Asset-Reader和Writer-重编码-Asset"><a href="#5-4-示例-Asset-Reader和Writer-重编码-Asset" class="headerlink" title="5.4 示例: Asset Reader和Writer 重编码 Asset"></a>5.4 示例: Asset Reader和Writer 重编码 Asset</h2><p>下面的代码简要示例了使用 asset reader 和 writer 对一个 asset 中的第一个 video 和 audio track 进行重新编码并将结果数据写入到一个新文件中.</p>
<blockquote>
<p>提示: 为了将注意力集中在核心代码上，这份示例省略了某些内容.</p>
</blockquote>
<h3 id="5-4-1-初始化设置"><a href="#5-4-1-初始化设置" class="headerlink" title="5.4.1 初始化设置"></a>5.4.1 初始化设置</h3><p>在创建和配置 asset reader 和 writer 之前，需要进行一些初始化设置。首先需要为读写过程创建三个串行队列.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSString</span> *serializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create the main serialization queue. 用于 asset reader 和 writer 的启动、停止和取消。</span></span><br><span class="line"><span class="keyword">self</span>.mainSerializationQueue = dispatch_queue_create([serializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSString</span> *rwAudioSerializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ rw audio serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个队列：读、写音频数据</span></span><br><span class="line"><span class="keyword">self</span>.rwAudioSerializationQueue = dispatch_queue_create([rwAudioSerializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">NSString</span> *rwVideoSerializationQueueDescription = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@&quot;%@ rw video serialization queue&quot;</span>, <span class="keyword">self</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个队列：读、写视频数据</span></span><br><span class="line"><span class="keyword">self</span>.rwVideoSerializationQueue = dispatch_queue_create([rwVideoSerializationQueueDescription UTF8String], <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<h3 id="5-4-2-加载-asset-中的-track，并开始重编码"><a href="#5-4-2-加载-asset-中的-track，并开始重编码" class="headerlink" title="5.4.2 加载 asset 中的 track，并开始重编码."></a>5.4.2 加载 asset 中的 track，并开始重编码.</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.asset = &lt;#<span class="built_in">AVAsset</span> that you want to reencode#&gt;;</span><br><span class="line"><span class="keyword">self</span>.cancelled = <span class="literal">NO</span>;</span><br><span class="line"><span class="keyword">self</span>.outputURL = &lt;#<span class="built_in">NSURL</span> representing desired output URL <span class="keyword">for</span> file generated by asset writer#&gt;;</span><br><span class="line"><span class="comment">// Asynchronously load the tracks of the asset you want to read.</span></span><br><span class="line">[<span class="keyword">self</span>.asset loadValuesAsynchronouslyForKeys:@[<span class="string">@&quot;tracks&quot;</span>] completionHandler:^&#123;</span><br><span class="line">     <span class="comment">// Once the tracks have finished loading, dispatch the work to the main serialization queue.</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">          <span class="comment">// Due to asynchronous nature, check to see if user has already cancelled.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.cancelled)</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">          <span class="built_in">BOOL</span> success = <span class="literal">YES</span>;</span><br><span class="line">          <span class="built_in">NSError</span> *localError = <span class="literal">nil</span>;</span><br><span class="line">          <span class="comment">// Check for success of loading the assets tracks.</span></span><br><span class="line">          success = ([<span class="keyword">self</span>.asset statusOfValueForKey:<span class="string">@&quot;tracks&quot;</span> error:&amp;localError] == <span class="built_in">AVKeyValueStatusLoaded</span>);</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If the tracks loaded successfully, make sure that no file exists at the output path for the asset writer.</span></span><br><span class="line">               <span class="built_in">NSFileManager</span> *fm = [<span class="built_in">NSFileManager</span> defaultManager];</span><br><span class="line">               <span class="built_in">NSString</span> *localOutputPath = [<span class="keyword">self</span>.outputURL path];</span><br><span class="line">               <span class="keyword">if</span> ([fm fileExistsAtPath:localOutputPath])</span><br><span class="line">                    success = [fm removeItemAtPath:localOutputPath error:&amp;localError];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">               success = [<span class="keyword">self</span> setupAssetReaderAndAssetWriter:&amp;localError];</span><br><span class="line">          <span class="keyword">if</span> (success)</span><br><span class="line">               success = [<span class="keyword">self</span> startAssetReaderAndWriter:&amp;localError];</span><br><span class="line">          <span class="keyword">if</span> (!success)</span><br><span class="line">               [<span class="keyword">self</span> readingAndWritingDidFinishSuccessfully:success withError:localError];</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>

<p>剩下的工作就是实现取消的处理，并实现三个自定义方法.</p>
<h3 id="5-4-3-初始化-Asset-Reader-和-Writer"><a href="#5-4-3-初始化-Asset-Reader-和-Writer" class="headerlink" title="5.4.3 初始化 Asset Reader 和 Writer"></a>5.4.3 初始化 Asset Reader 和 Writer</h3><p>自定义方法 <code>setupAssetReaderAndAssetWriter</code> 实现了 asset Reader 和 writer 的初始化和配置。在这个示例中：</p>
<ul>
<li>audio 先被 asset reader 解压为 Linear PCM，然后被 asset write 压缩为 128 kbps AAC。</li>
<li>video 被 asset reader 解压为 YUV，然后被 asset writer 压缩为 H.264:</li>
</ul>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)setupAssetReaderAndAssetWriter:(<span class="built_in">NSError</span> **)outError</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Create and initialize the asset reader.</span></span><br><span class="line">     <span class="keyword">self</span>.assetReader = [[<span class="built_in">AVAssetReader</span> alloc] initWithAsset:<span class="keyword">self</span>.asset error:outError];</span><br><span class="line">     <span class="built_in">BOOL</span> success = (<span class="keyword">self</span>.assetReader != <span class="literal">nil</span>);</span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the asset reader was successfully initialized, do the same for the asset writer.</span></span><br><span class="line">          <span class="keyword">self</span>.assetWriter = [[<span class="built_in">AVAssetWriter</span> alloc] initWithURL:<span class="keyword">self</span>.outputURL fileType:<span class="built_in">AVFileTypeQuickTimeMovie</span> error:outError];</span><br><span class="line">          success = (<span class="keyword">self</span>.assetWriter != <span class="literal">nil</span>);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the reader and writer were successfully initialized, grab the audio and video asset tracks that will be used.</span></span><br><span class="line">          <span class="built_in">AVAssetTrack</span> *assetAudioTrack = <span class="literal">nil</span>, *assetVideoTrack = <span class="literal">nil</span>;</span><br><span class="line">          <span class="built_in">NSArray</span> *audioTracks = [<span class="keyword">self</span>.asset tracksWithMediaType:<span class="built_in">AVMediaTypeAudio</span>];</span><br><span class="line">          <span class="keyword">if</span> ([audioTracks count] &gt; <span class="number">0</span>)</span><br><span class="line">               assetAudioTrack = [audioTracks objectAtIndex:<span class="number">0</span>];</span><br><span class="line">          <span class="built_in">NSArray</span> *videoTracks = [<span class="keyword">self</span>.asset tracksWithMediaType:<span class="built_in">AVMediaTypeVideo</span>];</span><br><span class="line">          <span class="keyword">if</span> ([videoTracks count] &gt; <span class="number">0</span>)</span><br><span class="line">               assetVideoTrack = [videoTracks objectAtIndex:<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (assetAudioTrack)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is an audio track to read, set the decompression settings to Linear PCM and create the asset reader output.</span></span><br><span class="line">               <span class="built_in">NSDictionary</span> *decompressionAudioSettings = @&#123; <span class="built_in">AVFormatIDKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatLinearPCM] &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetReaderAudioOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:assetAudioTrack outputSettings:decompressionAudioSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetReader addOutput:<span class="keyword">self</span>.assetReaderAudioOutput];</span><br><span class="line">               <span class="comment">// Then, set the compression settings to 128kbps AAC and create the asset writer input.</span></span><br><span class="line">               AudioChannelLayout stereoChannelLayout = &#123;</span><br><span class="line">                    .mChannelLayoutTag = kAudioChannelLayoutTag_Stereo,</span><br><span class="line">                    .mChannelBitmap = <span class="number">0</span>,</span><br><span class="line">                    .mNumberChannelDescriptions = <span class="number">0</span></span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="built_in">NSData</span> *channelLayoutAsData = [<span class="built_in">NSData</span> dataWithBytes:&amp;stereoChannelLayout length:offsetof(AudioChannelLayout, mChannelDescriptions)];</span><br><span class="line">               <span class="built_in">NSDictionary</span> *compressionAudioSettings = @&#123;</span><br><span class="line">                    <span class="built_in">AVFormatIDKey</span>         : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kAudioFormatMPEG4AAC],</span><br><span class="line">                    <span class="built_in">AVEncoderBitRateKey</span>   : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">128000</span>],</span><br><span class="line">                    <span class="built_in">AVSampleRateKey</span>       : [<span class="built_in">NSNumber</span> numberWithInteger:<span class="number">44100</span>],</span><br><span class="line">                    <span class="built_in">AVChannelLayoutKey</span>    : channelLayoutAsData,</span><br><span class="line">                    <span class="built_in">AVNumberOfChannelsKey</span> : [<span class="built_in">NSNumber</span> numberWithUnsignedInteger:<span class="number">2</span>]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetWriterAudioInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:[assetAudioTrack mediaType] outputSettings:compressionAudioSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetWriter addInput:<span class="keyword">self</span>.assetWriterAudioInput];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (assetVideoTrack)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is a video track to read, set the decompression settings for YUV and create the asset reader output.</span></span><br><span class="line">               <span class="built_in">NSDictionary</span> *decompressionVideoSettings = @&#123;</span><br><span class="line">                    (<span class="keyword">id</span>)kCVPixelBufferPixelFormatTypeKey     : [<span class="built_in">NSNumber</span> numberWithUnsignedInt:kCVPixelFormatType_422YpCbCr8],</span><br><span class="line">                    (<span class="keyword">id</span>)kCVPixelBufferIOSurfacePropertiesKey : [<span class="built_in">NSDictionary</span> dictionary]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="keyword">self</span>.assetReaderVideoOutput = [<span class="built_in">AVAssetReaderTrackOutput</span> assetReaderTrackOutputWithTrack:assetVideoTrack outputSettings:decompressionVideoSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetReader addOutput:<span class="keyword">self</span>.assetReaderVideoOutput];</span><br><span class="line">               <span class="built_in">CMFormatDescriptionRef</span> formatDescription = <span class="literal">NULL</span>;</span><br><span class="line">               <span class="comment">// Grab the video format descriptions from the video track and grab the first one if it exists.</span></span><br><span class="line">               <span class="built_in">NSArray</span> *videoFormatDescriptions = [assetVideoTrack formatDescriptions];</span><br><span class="line">               <span class="keyword">if</span> ([videoFormatDescriptions count] &gt; <span class="number">0</span>)</span><br><span class="line">                    formatDescription = (__bridge <span class="built_in">CMFormatDescriptionRef</span>)[formatDescriptions objectAtIndex:<span class="number">0</span>];</span><br><span class="line">               <span class="built_in">CGSize</span> trackDimensions = &#123;</span><br><span class="line">                    .width = <span class="number">0.0</span>,</span><br><span class="line">                    .height = <span class="number">0.0</span>,</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="comment">// If the video track had a format description, grab the track dimensions from there. Otherwise, grab them direcly from the track itself.</span></span><br><span class="line">               <span class="keyword">if</span> (formatDescription)</span><br><span class="line">                    trackDimensions = <span class="built_in">CMVideoFormatDescriptionGetPresentationDimensions</span>(formatDescription, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">                    trackDimensions = [assetVideoTrack naturalSize];</span><br><span class="line">               <span class="built_in">NSDictionary</span> *compressionSettings = <span class="literal">nil</span>;</span><br><span class="line">               <span class="comment">// If the video track had a format description, attempt to grab the clean aperture settings and pixel aspect ratio used by the video.</span></span><br><span class="line">               <span class="keyword">if</span> (formatDescription)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *cleanAperture = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="built_in">NSDictionary</span> *pixelAspectRatio = <span class="literal">nil</span>;</span><br><span class="line">                    <span class="built_in">CFDictionaryRef</span> cleanApertureFromCMFormatDescription = <span class="built_in">CMFormatDescriptionGetExtension</span>(formatDescription, kCMFormatDescriptionExtension_CleanAperture);</span><br><span class="line">                    <span class="keyword">if</span> (cleanApertureFromCMFormatDescription)</span><br><span class="line">                    &#123;</span><br><span class="line">                         cleanAperture = @&#123;</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureWidthKey</span>            : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureWidth),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureHeightKey</span>           : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHeight),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureHorizontalOffsetKey</span> : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureHorizontalOffset),</span><br><span class="line">                              <span class="built_in">AVVideoCleanApertureVerticalOffsetKey</span>   : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(cleanApertureFromCMFormatDescription, kCMFormatDescriptionKey_CleanApertureVerticalOffset)</span><br><span class="line">                         &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">CFDictionaryRef</span> pixelAspectRatioFromCMFormatDescription = <span class="built_in">CMFormatDescriptionGetExtension</span>(formatDescription, kCMFormatDescriptionExtension_PixelAspectRatio);</span><br><span class="line">                    <span class="keyword">if</span> (pixelAspectRatioFromCMFormatDescription)</span><br><span class="line">                    &#123;</span><br><span class="line">                         pixelAspectRatio = @&#123;</span><br><span class="line">                              <span class="built_in">AVVideoPixelAspectRatioHorizontalSpacingKey</span> : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing),</span><br><span class="line">                              <span class="built_in">AVVideoPixelAspectRatioVerticalSpacingKey</span>   : (<span class="keyword">id</span>)<span class="built_in">CFDictionaryGetValue</span>(pixelAspectRatioFromCMFormatDescription, kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing)</span><br><span class="line">                         &#125;;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Add whichever settings we could grab from the format description to the compression settings dictionary.</span></span><br><span class="line">                    <span class="keyword">if</span> (cleanAperture || pixelAspectRatio)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="built_in">NSMutableDictionary</span> *mutableCompressionSettings = [<span class="built_in">NSMutableDictionary</span> dictionary];</span><br><span class="line">                         <span class="keyword">if</span> (cleanAperture)</span><br><span class="line">                              [mutableCompressionSettings setObject:cleanAperture forKey:<span class="built_in">AVVideoCleanApertureKey</span>];</span><br><span class="line">                         <span class="keyword">if</span> (pixelAspectRatio)</span><br><span class="line">                              [mutableCompressionSettings setObject:pixelAspectRatio forKey:<span class="built_in">AVVideoPixelAspectRatioKey</span>];</span><br><span class="line">                         compressionSettings = mutableCompressionSettings;</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Create the video settings dictionary for H.264.</span></span><br><span class="line">               <span class="built_in">NSMutableDictionary</span> *videoSettings = (<span class="built_in">NSMutableDictionary</span> *) @&#123;</span><br><span class="line">                    <span class="built_in">AVVideoCodecKey</span>  : <span class="built_in">AVVideoCodecH264</span>,</span><br><span class="line">                    <span class="built_in">AVVideoWidthKey</span>  : [<span class="built_in">NSNumber</span> numberWithDouble:trackDimensions.width],</span><br><span class="line">                    <span class="built_in">AVVideoHeightKey</span> : [<span class="built_in">NSNumber</span> numberWithDouble:trackDimensions.height]</span><br><span class="line">               &#125;;</span><br><span class="line">               <span class="comment">// Put the compression settings into the video settings dictionary if we were able to grab them.</span></span><br><span class="line">               <span class="keyword">if</span> (compressionSettings)</span><br><span class="line">                    [videoSettings setObject:compressionSettings forKey:<span class="built_in">AVVideoCompressionPropertiesKey</span>];</span><br><span class="line">               <span class="comment">// Create the asset writer input and add it to the asset writer.</span></span><br><span class="line">               <span class="keyword">self</span>.assetWriterVideoInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:[videoTrack mediaType] outputSettings:videoSettings];</span><br><span class="line">               [<span class="keyword">self</span>.assetWriter addInput:<span class="keyword">self</span>.assetWriterVideoInput];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-4-重编码-Asset"><a href="#5-4-4-重编码-Asset" class="headerlink" title="5.4.4 重编码 Asset"></a>5.4.4 重编码 Asset</h3><p>方法<code>startAssetReaderAndWriter</code>负责读取和写入 asset：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)startAssetReaderAndWriter:(<span class="built_in">NSError</span> **)outError</span><br><span class="line">&#123;</span><br><span class="line">     <span class="built_in">BOOL</span> success = <span class="literal">YES</span>;</span><br><span class="line">     <span class="comment">// Attempt to start the asset reader.</span></span><br><span class="line">     success = [<span class="keyword">self</span>.assetReader startReading];</span><br><span class="line">     <span class="keyword">if</span> (!success)</span><br><span class="line">          *outError = [<span class="keyword">self</span>.assetReader error];</span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the reader started successfully, attempt to start the asset writer.</span></span><br><span class="line">          success = [<span class="keyword">self</span>.assetWriter startWriting];</span><br><span class="line">          <span class="keyword">if</span> (!success)</span><br><span class="line">               *outError = [<span class="keyword">self</span>.assetWriter error];</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// If the asset reader and writer both started successfully, create the dispatch group where the reencoding will take place and start a sample-writing session.</span></span><br><span class="line">          <span class="keyword">self</span>.dispatchGroup = dispatch_group_create();</span><br><span class="line">          [<span class="keyword">self</span>.assetWriter startSessionAtSourceTime:kCMTimeZero];</span><br><span class="line">          <span class="keyword">self</span>.audioFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.videoFinished = <span class="literal">NO</span>;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterAudioInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If there is audio to reencode, enter the dispatch group before beginning the work.</span></span><br><span class="line">               dispatch_group_enter(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               <span class="comment">// Specify the block to execute when the asset writer is ready for audio media data, and specify the queue to call it on.</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterAudioInput requestMediaDataWhenReadyOnQueue:<span class="keyword">self</span>.rwAudioSerializationQueue usingBlock:^&#123;</span><br><span class="line">                    <span class="comment">// Because the block is called asynchronously, check to see whether its task is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.audioFinished)</span><br><span class="line">                         <span class="keyword">return</span>;</span><br><span class="line">                    <span class="built_in">BOOL</span> completedOrFailed = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="comment">// If the task isn&#x27;t complete yet, make sure that the input is actually ready for more media data.</span></span><br><span class="line">                    <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterAudioInput isReadyForMoreMediaData] &amp;&amp; !completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Get the next audio sample buffer, and append it to the output file.</span></span><br><span class="line">                         <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderAudioOutput copyNextSampleBuffer];</span><br><span class="line">                         <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              <span class="built_in">BOOL</span> success = [<span class="keyword">self</span>.assetWriterAudioInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">                              <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">                              sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                              completedOrFailed = !success;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                         &#123;</span><br><span class="line">                              completedOrFailed = <span class="literal">YES</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Mark the input as finished, but only if we haven&#x27;t already done so, and then leave the dispatch group (since the audio work has finished).</span></span><br><span class="line">                         <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.audioFinished;</span><br><span class="line">                         <span class="keyword">self</span>.audioFinished = <span class="literal">YES</span>;</span><br><span class="line">                         <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              [<span class="keyword">self</span>.assetWriterAudioInput markAsFinished];</span><br><span class="line">                         &#125;</span><br><span class="line">                         dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;];</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterVideoInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// If we had video to reencode, enter the dispatch group before beginning the work.</span></span><br><span class="line">               dispatch_group_enter(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               <span class="comment">// Specify the block to execute when the asset writer is ready for video media data, and specify the queue to call it on.</span></span><br><span class="line">               [<span class="keyword">self</span>.assetWriterVideoInput requestMediaDataWhenReadyOnQueue:<span class="keyword">self</span>.rwVideoSerializationQueue usingBlock:^&#123;</span><br><span class="line">                    <span class="comment">// Because the block is called asynchronously, check to see whether its task is complete.</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.videoFinished)</span><br><span class="line">                         <span class="keyword">return</span>;</span><br><span class="line">                    <span class="built_in">BOOL</span> completedOrFailed = <span class="literal">NO</span>;</span><br><span class="line">                    <span class="comment">// If the task isn&#x27;t complete yet, make sure that the input is actually ready for more media data.</span></span><br><span class="line">                    <span class="keyword">while</span> ([<span class="keyword">self</span>.assetWriterVideoInput isReadyForMoreMediaData] &amp;&amp; !completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Get the next video sample buffer, and append it to the output file.</span></span><br><span class="line">                         <span class="built_in">CMSampleBufferRef</span> sampleBuffer = [<span class="keyword">self</span>.assetReaderVideoOutput copyNextSampleBuffer];</span><br><span class="line">                         <span class="keyword">if</span> (sampleBuffer != <span class="literal">NULL</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              <span class="built_in">BOOL</span> success = [<span class="keyword">self</span>.assetWriterVideoInput appendSampleBuffer:sampleBuffer];</span><br><span class="line">                              <span class="built_in">CFRelease</span>(sampleBuffer);</span><br><span class="line">                              sampleBuffer = <span class="literal">NULL</span>;</span><br><span class="line">                              completedOrFailed = !success;</span><br><span class="line">                         &#125;</span><br><span class="line">                         <span class="keyword">else</span></span><br><span class="line">                         &#123;</span><br><span class="line">                              completedOrFailed = <span class="literal">YES</span>;</span><br><span class="line">                         &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (completedOrFailed)</span><br><span class="line">                    &#123;</span><br><span class="line">                         <span class="comment">// Mark the input as finished, but only if we haven&#x27;t already done so, and then leave the dispatch group (since the video work has finished).</span></span><br><span class="line">                         <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.videoFinished;</span><br><span class="line">                         <span class="keyword">self</span>.videoFinished = <span class="literal">YES</span>;</span><br><span class="line">                         <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                         &#123;</span><br><span class="line">                              [<span class="keyword">self</span>.assetWriterVideoInput markAsFinished];</span><br><span class="line">                         &#125;</span><br><span class="line">                         dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;];</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Set up the notification that the dispatch group will send when the audio and video work have both finished.</span></span><br><span class="line">          dispatch_group_notify(<span class="keyword">self</span>.dispatchGroup, <span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">               <span class="built_in">BOOL</span> finalSuccess = <span class="literal">YES</span>;</span><br><span class="line">               <span class="built_in">NSError</span> *finalError = <span class="literal">nil</span>;</span><br><span class="line">               <span class="comment">// Check to see if the work has finished due to cancellation.</span></span><br><span class="line">               <span class="keyword">if</span> (<span class="keyword">self</span>.cancelled)</span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// If so, cancel the reader and writer.</span></span><br><span class="line">                    [<span class="keyword">self</span>.assetReader cancelReading];</span><br><span class="line">                    [<span class="keyword">self</span>.assetWriter cancelWriting];</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">else</span></span><br><span class="line">               &#123;</span><br><span class="line">                    <span class="comment">// If cancellation didn&#x27;t occur, first make sure that the asset reader didn&#x27;t fail.</span></span><br><span class="line">                    <span class="keyword">if</span> ([<span class="keyword">self</span>.assetReader status] == <span class="built_in">AVAssetReaderStatusFailed</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         finalSuccess = <span class="literal">NO</span>;</span><br><span class="line">                         finalError = [<span class="keyword">self</span>.assetReader error];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// If the asset reader didn&#x27;t fail, attempt to stop the asset writer and check for any errors.</span></span><br><span class="line">                    <span class="keyword">if</span> (finalSuccess)</span><br><span class="line">                    &#123;</span><br><span class="line">                         finalSuccess = [<span class="keyword">self</span>.assetWriter finishWriting];</span><br><span class="line">                         <span class="keyword">if</span> (!finalSuccess)</span><br><span class="line">                              finalError = [<span class="keyword">self</span>.assetWriter error];</span><br><span class="line">                    &#125;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// Call the method to handle completion, and pass in the appropriate parameters to indicate whether reencoding was successful.</span></span><br><span class="line">               [<span class="keyword">self</span> readingAndWritingDidFinishSuccessfully:finalSuccess withError:finalError];</span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// Return success here to indicate whether the asset reader and writer were started successfully.</span></span><br><span class="line">     <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在重编码过程中，为了提升性能，音频处理和视频处理在两个不同队列中进行。但这两个队列在一个 dispatchGroup 中，当每个队列的任务都完成后，会发送通知。判断重新编码结果是否成功。</p>
<p>最后调用<code>readingAndWritingDidFinishSuccessfully:</code>。</p>
<h3 id="5-4-5-处理编码结果"><a href="#5-4-5-处理编码结果" class="headerlink" title="5.4.5 处理编码结果"></a>5.4.5 处理编码结果</h3><p>对重编码的结果进行处理并同步到 UI:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)readingAndWritingDidFinishSuccessfully:(<span class="built_in">BOOL</span>)success withError:(<span class="built_in">NSError</span> *)error</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (!success)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// 如果重新编码过程未成功完成，则asset reader、asset writer都将被取消</span></span><br><span class="line">          [<span class="keyword">self</span>.assetReader cancelReading];</span><br><span class="line">          [<span class="keyword">self</span>.assetWriter cancelWriting];</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="comment">// Handle any UI tasks here related to failure.</span></span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">     &#123;</span><br><span class="line">          <span class="comment">// Reencoding was successful, reset booleans.</span></span><br><span class="line">          <span class="keyword">self</span>.cancelled = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.videoFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="keyword">self</span>.audioFinished = <span class="literal">NO</span>;</span><br><span class="line">          <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">               <span class="comment">// Handle any UI tasks here related to success.</span></span><br><span class="line">          &#125;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-6-取消重编码"><a href="#5-4-6-取消重编码" class="headerlink" title="5.4.6 取消重编码"></a>5.4.6 取消重编码</h3><p>使用多个串行队列，可以很轻松的取消对 asset 的重编码。</p>
<ul>
<li>在主序列化队列上，消息被异步发送到每个 asset 重新编码序列化队列，以取消它们的读取和写入。</li>
<li>当这两个序列化队列完成取消时，调度组向主序列化队列发送通知，其中取消属性设置为 YES。</li>
</ul>
<p>可以将下面的代码与 UI 上的 “取消” 按钮关联起来:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)cancel</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// Handle cancellation asynchronously, but serialize it with the main queue.</span></span><br><span class="line">     <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.mainSerializationQueue, ^&#123;</span><br><span class="line">          <span class="comment">// If we had audio data to reencode, we need to cancel the audio work.</span></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterAudioInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// Handle cancellation asynchronously again, but this time serialize it with the audio queue.</span></span><br><span class="line">               <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.rwAudioSerializationQueue, ^&#123;</span><br><span class="line">                    <span class="comment">// Update the Boolean property indicating the task is complete and mark the input as finished if it hasn&#x27;t already been marked as such.</span></span><br><span class="line">                    <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.audioFinished;</span><br><span class="line">                    <span class="keyword">self</span>.audioFinished = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         [<span class="keyword">self</span>.assetWriterAudioInput markAsFinished];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Leave the dispatch group since the audio work is finished now.</span></span><br><span class="line">                    dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="keyword">self</span>.assetWriterVideoInput)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="comment">// Handle cancellation asynchronously again, but this time serialize it with the video queue.</span></span><br><span class="line">               <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.rwVideoSerializationQueue, ^&#123;</span><br><span class="line">                    <span class="comment">// Update the Boolean property indicating the task is complete and mark the input as finished if it hasn&#x27;t already been marked as such.</span></span><br><span class="line">                    <span class="built_in">BOOL</span> oldFinished = <span class="keyword">self</span>.videoFinished;</span><br><span class="line">                    <span class="keyword">self</span>.videoFinished = <span class="literal">YES</span>;</span><br><span class="line">                    <span class="keyword">if</span> (oldFinished == <span class="literal">NO</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                         [<span class="keyword">self</span>.assetWriterVideoInput markAsFinished];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// Leave the dispatch group, since the video work is finished now.</span></span><br><span class="line">                    dispatch_group_leave(<span class="keyword">self</span>.dispatchGroup);</span><br><span class="line">               &#125;);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// Set the cancelled Boolean property to YES to cancel any work on the main queue as well.</span></span><br><span class="line">          <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-5-AVOutputSettingsAssistant介绍"><a href="#5-5-AVOutputSettingsAssistant介绍" class="headerlink" title="5.5 AVOutputSettingsAssistant介绍"></a>5.5 AVOutputSettingsAssistant介绍</h2><p><a target="_blank" rel="noopener" href="https://developer.apple.com/reference/avfoundation/avoutputsettingsassistant">AVOutputSettingsAssistant</a> 类的功能是为 asset reader 或 writer 创建设置信息。这使得设置更简单，特别是在对于具有许多特定预设的高帧率的 H264 视频进行参数设置时。</p>
<p>下面的代码是<code>AVOutputSettingsAssistant</code>的使用示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AVOutputSettingsAssistant</span> *outputSettingsAssistant = [<span class="built_in">AVOutputSettingsAssistant</span> outputSettingsAssistantWithPreset:&lt;some preset&gt;];</span><br><span class="line"><span class="built_in">CMFormatDescriptionRef</span> audioFormat = [<span class="keyword">self</span> getAudioFormat];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (audioFormat != <span class="literal">NULL</span>)</span><br><span class="line">    [outputSettingsAssistant setSourceAudioFormat:(<span class="built_in">CMAudioFormatDescriptionRef</span>)audioFormat];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMFormatDescriptionRef</span> videoFormat = [<span class="keyword">self</span> getVideoFormat];</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (videoFormat != <span class="literal">NULL</span>)</span><br><span class="line">    [outputSettingsAssistant setSourceVideoFormat:(<span class="built_in">CMVideoFormatDescriptionRef</span>)videoFormat];</span><br><span class="line"></span><br><span class="line"><span class="built_in">CMTime</span> assetMinVideoFrameDuration = [<span class="keyword">self</span> getMinFrameDuration];</span><br><span class="line"><span class="built_in">CMTime</span> averageFrameDuration = [<span class="keyword">self</span> getAvgFrameDuration]</span><br><span class="line"></span><br><span class="line">[outputSettingsAssistant setSourceVideoAverageFrameDuration:averageFrameDuration];</span><br><span class="line">[outputSettingsAssistant setSourceVideoMinFrameDuration:assetMinVideoFrameDuration];</span><br><span class="line"></span><br><span class="line"><span class="built_in">AVAssetWriter</span> *assetWriter = [<span class="built_in">AVAssetWriter</span> assetWriterWithURL:&lt;some URL&gt; fileType:[outputSettingsAssistant outputFileType] error:<span class="literal">NULL</span>];</span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *audioInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeAudio</span> outputSettings:[outputSettingsAssistant audioSettings] sourceFormatHint:audioFormat];</span><br><span class="line"><span class="built_in">AVAssetWriterInput</span> *videoInput = [<span class="built_in">AVAssetWriterInput</span> assetWriterInputWithMediaType:<span class="built_in">AVMediaTypeVideo</span> outputSettings:[outputSettingsAssistant videoSettings] sourceFormatHint:videoFormat];</span><br></pre></td></tr></table></figure>

<h1 id="六、时间和媒体的表示"><a href="#六、时间和媒体的表示" class="headerlink" title="六、时间和媒体的表示"></a>六、时间和媒体的表示</h1><p>AV Foundation 框架中使用的一些用来代表时间和媒体的底层数据结构来源于 Core Media 框架。</p>
<h2 id="6-1-时间的表示"><a href="#6-1-时间的表示" class="headerlink" title="6.1 时间的表示"></a>6.1 时间的表示</h2><p>AV Foundation 框架中的时间由一个 Core Media 框架中的数据结构表示.</p>
<h3 id="6-1-1-用-CMTime-表示一段时间"><a href="#6-1-1-用-CMTime-表示一段时间" class="headerlink" title="6.1.1 用 CMTime 表示一段时间"></a>6.1.1 用 CMTime 表示一段时间</h3><p><a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/cmtime">CMTime</a> 是一个以有理数表示时间的 C 语言结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用一个 int64_t 类型作为分子，一个 int32_t 类型作为分母。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> CMTimeValue;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int32_t</span> CMTimeScale;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int64_t</span> CMTimeEpoch</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	CMTimeValue	value;		<span class="comment">/*!&lt; The value of the CMTime. value/timescale = seconds */</span></span><br><span class="line">	CMTimeScale	timescale;	<span class="comment">/*!&lt; The timescale of the CMTime. value/timescale = seconds. */</span></span><br><span class="line">	<span class="comment">// 除了用来表示时间，CMTime还可以用来表示非数值的值：正无穷大(+infinity)，负无穷大(-infinity)，不确定(indefinite)，还可以指示时间是否在某个时间点四舍五入(HasBeenRounded)。</span></span><br><span class="line">  CMTimeFlags	flags;		<span class="comment">/*!&lt; The flags, eg. kCMTimeFlags_Valid, kCMTimeFlags_PositiveInfinity, etc. */</span></span><br><span class="line">  <span class="comment">// 维护了一个纪元数（记数的起算时间）。epoch通常为0，但您可以使用不同的值，例如，在循环中。</span></span><br><span class="line">	CMTimeEpoch	epoch;</span><br><span class="line">&#125; CMTime;</span><br></pre></td></tr></table></figure>

<p>从概念上来看，timescale (时间段/时间刻度) 描述了一秒中包含多少个时间单元。</p>
<ul>
<li>如果 timescale 等于 4，则每个时间单元代表四分之一秒；</li>
<li>如果果 timescale 等于 10，则每个时间单元代表十分之一秒，以此类推；</li>
<li>经常使用 600 的 timescale ，因为这是几个常用帧速率的倍数：电影 24 fps、NTSC 30 fps（用于北美和日本的电视）和 PAL 25 fps（用于电视欧洲）。使用 600 的timescale，可以准确地表示这些系统中的任意数量的帧。</li>
</ul>
<h4 id="1-CMTime的创建与使用"><a href="#1-CMTime的创建与使用" class="headerlink" title="1. CMTime的创建与使用"></a>1. CMTime的创建与使用</h4><p>使用方法 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1400785-cmtimemake">CMTimeMake</a> 或者 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1400797-cmtimemakewithseconds">CMTimeMakeWithSeconds</a> 创建一个时间。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用value和时间刻度的有效 CMTime。 Epoch 隐含为 0。</span></span><br><span class="line"><span class="built_in">CMTime</span> <span class="built_in">CMTimeMake</span>(int64_t value, int32_t timescale);</span><br><span class="line"><span class="comment">// 使用秒数和首选时间刻度生成 CMTime。</span></span><br><span class="line"><span class="built_in">CMTime</span> <span class="built_in">CMTimeMakeWithSeconds</span>(Float64 seconds, int32_t preferredTimescale)</span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMTime</span> time1 = <span class="built_in">CMTimeMake</span>(<span class="number">200</span>, <span class="number">2</span>); <span class="comment">// 200 1/2秒</span></span><br><span class="line"><span class="built_in">CMTime</span> time2 = <span class="built_in">CMTimeMake</span>(<span class="number">400</span>, <span class="number">4</span>); <span class="comment">// 400 1/4秒</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// time1 和 time2 都代表 100 秒，但使用不同的时间刻度。</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CMTimeCompare</span>(time1, time2) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;time1 and time2 are the same&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Float64 float64Seconds = <span class="number">200.0</span> / <span class="number">3</span>;</span><br><span class="line"><span class="built_in">CMTime</span> time3 = <span class="built_in">CMTimeMakeWithSeconds</span>(float64Seconds , <span class="number">3</span>); <span class="comment">// 66.66... third-seconds</span></span><br><span class="line">time3 = <span class="built_in">CMTimeMultiply</span>(time3, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//  time3 现在代表 200 秒；接下来减去 time1（100 秒）</span></span><br><span class="line">time3 = <span class="built_in">CMTimeSubtract</span>(time3, time1);</span><br><span class="line"><span class="built_in">CMTimeShow</span>(time3);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CMTIME_COMPARE_INLINE</span>(time2, ==, time3)) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;time2 and time3 are the same&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更多详细信息参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1669288-cmtime"><em>CMTime Reference</em></a>.</p>
<h4 id="2-CMTime-的特殊值与判断宏"><a href="#2-CMTime-的特殊值与判断宏" class="headerlink" title="2. CMTime 的特殊值与判断宏"></a>2. CMTime 的特殊值与判断宏</h4><p>Core Media 框架提供了一些常量:</p>
<ul>
<li><code>kCMTimeZero</code></li>
<li><code>kCMTimeInvalid</code></li>
<li><code>kCMTimePositiveInfinity</code> </li>
<li><code>kCMTimeNegativeInfinity</code>。</li>
</ul>
<p><code>CMTime</code>结构体能够进行很多操作，比如要判断一个时间是否有效(是否为非数字值)，可以使用一些定义好的宏：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_VALID(time) ((Boolean)(((time).flags &amp; kCMTimeFlags_Valid) != 0))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_INVALID(time) (! CMTIME_IS_VALID(time))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_POSITIVE_INFINITY(time) ((Boolean)(CMTIME_IS_VALID(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_PositiveInfinity) != 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_NEGATIVE_INFINITY(time) ((Boolean)(CMTIME_IS_VALID(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_NegativeInfinity) != 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_INDEFINITE(time) ((Boolean)(CMTIME_IS_VALID(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_Indefinite) != 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_IS_NUMERIC(time) ((Boolean)(((time).flags &amp; (kCMTimeFlags_Valid | kCMTimeFlags_ImpliedValueFlagsMask)) == kCMTimeFlags_Valid))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIME_HAS_BEEN_ROUNDED(time) ((Boolean)(CMTIME_IS_NUMERIC(time) &amp;&amp; (((time).flags &amp; kCMTimeFlags_HasBeenRounded) != 0)))</span></span><br></pre></td></tr></table></figure>

<p>比如：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMTime</span> myTime = &lt;#Get a <span class="built_in">CMTime</span>#&gt;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">CMTIME_IS_INVALID</span>(myTime)) &#123;</span><br><span class="line">    <span class="comment">// Perhaps treat this as an error; display a suitable alert to the user.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不能将 CMTime 结构体与<code>kCMTimeZero</code>直接进行比较。</p>
<h4 id="3-将-CMTime-转换为对象"><a href="#3-将-CMTime-转换为对象" class="headerlink" title="3. 将 CMTime 转换为对象"></a>3. 将 CMTime 转换为对象</h4><p>如果要在注释或者<code>Core Foundation</code>容器中使用 CMTime，使用方法 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1400845-cmtimecopyasdictionary">CMTimeCopyAsDictionary</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1400819-cmtimemakefromdictionary">CMTimeMakeFromDictionary</a> 可以在 CMTime 结构体和<code>CFDictionary</code>类型 (参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/corefoundation/cfdictionaryref">CFDictionaryRef</a>) 之间进行相互转换。</p>
<p>使用方法 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1400791-cmtimecopydescription">CMTimeCopyDescription</a> 可以获取 CMTime 结构体的字符串描述。</p>
<h4 id="4-纪元-Epochs"><a href="#4-纪元-Epochs" class="headerlink" title="4. 纪元 (Epochs)"></a>4. 纪元 (Epochs)</h4><p><code>CMTime</code>结构体中的 epoch 通常被设置为 0。但有些场景下，可以用到，比如在循环中，可以使用这个值来区分不同循环次数中的同一个时间点。</p>
<h3 id="6-1-2-用-CMTimeRange-表示一个时间范围"><a href="#6-1-2-用-CMTimeRange-表示一个时间范围" class="headerlink" title="6.1.2 用 CMTimeRange 表示一个时间范围"></a>6.1.2 用 CMTimeRange 表示一个时间范围</h3><p>CMTimeRange 是一个 C 语言结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CMTime  start;		<span class="comment">// 起始时间</span></span><br><span class="line">    CMTime  duration;	<span class="comment">// 持续时间</span></span><br><span class="line">&#125; CMTimeRange;</span><br><span class="line"></span><br><span class="line"><span class="function">CMTimeRange <span class="title">CMTimeRangeMake</span><span class="params">(CMTime start, CMTime duration)</span></span>;</span><br><span class="line"><span class="function">CMTimeRange <span class="title">CMTimeRangeFromTimeToTime</span><span class="params">(CMTime start, CMTime end)</span></span>;</span><br></pre></td></tr></table></figure>

<p>一个时间范围并不包含<code>start</code>加上<code>duration</code>得到的时间。（是个数学上的开区间，不包含后边界）</p>
<p>使用上面两个方法可以创建一个时间范围，但是存在一些限制:</p>
<ul>
<li><code>CMTimeRange</code>不能跨过不同的<code>epoch</code>。</li>
<li><code>start</code>的<code>epoch</code>值可能不为0，我们只能对<code>start</code>的<code>epoch</code>值相同的 CMTimeRange 进行范围操作(例如 CMTimeRangeGetUnion)。</li>
<li><code>duration</code>的<code>epoch</code>值应该一直为 0，<code>value</code> 值为非负。</li>
</ul>
<h4 id="1-处理-CMTimeRange"><a href="#1-处理-CMTimeRange" class="headerlink" title="1. 处理 CMTimeRange"></a>1. 处理 CMTimeRange</h4><p>Core Media 框架提供了一些一个时间范围操作方法：</p>
<ul>
<li>判断一个时间范围是否包含某个时间点或者其他时间范围的方法</li>
<li>判断两个时间范围是否相同</li>
<li>对两个时间范围进行交集和并集运算的方法。</li>
</ul>
<p>例如，<a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1462775-cmtimerangecontainstime">CMTimeRangeContainsTime</a>，<a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1462841-cmtimerangeequal">CMTimeRangeEqual</a>，<a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1462830-cmtimerangecontainstimerange">CMTimeRangeContainsTimeRange</a> 和 <a target="_blank" rel="noopener" href="https://changjianfeishui.gitbooks.io/avfoundation-programming-guide/CMTimeRangeGetUnion">CMTimeRangeGetUnion</a>.</p>
<p>注意下面的表达式永远返回 false(<em>包前不包后，前闭后开</em>)：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMTimeRangeContainsTime</span>(range, <span class="built_in">CMTimeRangeGetEnd</span>(range));</span><br></pre></td></tr></table></figure>

<p>更多相关的详细信息，参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1665980-cmtimerange"><em>CMTimeRange Reference</em></a>.</p>
<h4 id="2-CMTimeRange-的特殊值"><a href="#2-CMTimeRange-的特殊值" class="headerlink" title="2. CMTimeRange 的特殊值"></a>2. CMTimeRange 的特殊值</h4><p>Core Media 提供了两个常量：</p>
<ul>
<li>kCMTimeRangeZero：表示空范围</li>
<li>kCMTimeRangeInvalid：表示无效范围</li>
</ul>
<p>可以使用以下这些宏对 CMTimeRange 的特殊值进行判断: </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_VALID(range) ((Boolean)(CMTIME_IS_VALID(range.start) &amp;&amp; CMTIME_IS_VALID(range.duration) &amp;&amp; (range.duration.epoch == 0) &amp;&amp; (range.duration.value &gt;= 0)))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_INVALID(range) (! CMTIMERANGE_IS_VALID(range))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_INDEFINITE(range) ((Boolean)(CMTIMERANGE_IS_VALID(range) &amp;&amp; (CMTIME_IS_INDEFINITE(range.start) || CMTIME_IS_INDEFINITE(range.duration))))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CMTIMERANGE_IS_EMPTY(range) ((Boolean)(CMTIMERANGE_IS_VALID(range) &amp;&amp; (CMTIME_COMPARE_INLINE(range.duration, ==, kCMTimeZero))))</span></span><br></pre></td></tr></table></figure>

<p>不能将 CMTimeRange 结构体与<code>kCMTimeRangeInvalid</code>直接进行比较。</p>
<h4 id="3-将-CMTimeRange-转换为对象"><a href="#3-将-CMTimeRange-转换为对象" class="headerlink" title="3. 将 CMTimeRange 转换为对象"></a>3. 将 CMTimeRange 转换为对象</h4><p>如果要在注释或者<code>Core Foundation</code>容器中使用 CMTimeRange，使用方法 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1462781-cmtimerangecopyasdictionary">CMTimeRangeCopyAsDictionary</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1462777-cmtimerangemakefromdictionary">CMTimeRangeMakeFromDictionary</a> 可以在 CMTimeRange 结构体和<code>CFDictionary</code>类型 (参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/corefoundation/cfdictionaryref">CFDictionaryRef</a>) 之间进行相互转换。</p>
<p>使用方法 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1462823-cmtimerangecopydescription">CMTimeRangeCopyDescription</a> 可以获取 CMTimeRange 结构体的字符串描述.</p>
<h2 id="6-2-媒体的表示-CMSampleBuffer"><a href="#6-2-媒体的表示-CMSampleBuffer" class="headerlink" title="6.2 媒体的表示(CMSampleBuffer)"></a>6.2 媒体的表示(CMSampleBuffer)</h2><p>视频数据和与其相关联的元数据都使用 Core Media 框架中的对象类型来表示。</p>
<p>Core Media 使用<code>CMSampleBuffer</code>(参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/cmsamplebuffer">CMSampleBufferRef</a>) 类型表示视频数据。</p>
<blockquote>
<p>CMSampleBuffers 是包含零个或多个特定媒体类型（音频、视频、多路混合等）的压缩（或未压缩）样本的 CF 对象，用于在媒体系统中移动媒体样本数据。</p>
<p>CMSampleBuffer 可以包含一个或多个媒体样本的 CMBlockBuffer 或 CVImageBuffer、CMSampleBuffer 流的格式描述、每个包含的媒体样本的大小和时间信息，以及缓冲区级别(buffer-level)和样本级别(sample-level)的附件。</p>
</blockquote>
<p>一个<code>CMSampleBuffer</code>对象是一个包含了视频数据帧的 sample buffer(样本缓冲区)，用来作为 Core Video pixel buffer(核心视频像素缓冲区，参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/corevideo/cvpixelbufferref">CVPixelBufferRef</a>)。</p>
<p>可以使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1489236-cmsamplebuffergetimagebuffer">CMSampleBufferGetImageBuffer</a> 方法访问 sample buffer 中的 pixel buffer.</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CVPixelBufferRef pixelBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(&lt;#A <span class="built_in">CMSampleBuffer</span>#&gt;);</span><br></pre></td></tr></table></figure>

<p>可以在 pixel buffer 访问到实际的视频数据，参见下节示例代码。</p>
<p>除了视频数据而言，还可以获取视频帧其他方面的信息:</p>
<ul>
<li><p><strong>时间信息</strong>: 使用 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1489252-cmsamplebuffergetpresentationtim">CMSampleBufferGetPresentationTimeStamp</a> 和 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1489404-cmsamplebuffergetdecodetimestamp">CMSampleBufferGetDecodeTimeStamp</a> 可以分别获取视频帧的初始时间和解码时间。</p>
</li>
<li><p><strong>格式信息</strong>: 包含在一个<code>CMFormatDescription</code>对象中 (参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/cmformatdescriptionref">CMFormatDescriptionRef</a>)。从格式描述 对象中，可以：</p>
<ul>
<li>使用<code>CMVideoFormatDescriptionGetCodecType</code>获取视频的编码信息</li>
<li>使用<code>CMVideoFormatDescriptionGetDimensions</code>获取视频尺寸。</li>
</ul>
</li>
<li><p><strong>元数据</strong>: 以附件形式存储在一个字典中，通过 <a target="_blank" rel="noopener" href="https://developer.apple.com/reference/coremedia/1470707-cmgetattachment">CMGetAttachment</a> 获取:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">CMSampleBufferRef</span> sampleBuffer = &lt;#Get a sample buffer#&gt;;</span><br><span class="line"><span class="built_in">CFDictionaryRef</span> metadataDictionary =</span><br><span class="line">    <span class="built_in">CMGetAttachment</span>(sampleBuffer, <span class="built_in">CFSTR</span>(<span class="string">&quot;MetadataDictionary&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (metadataDictionary) &#123;</span><br><span class="line">    <span class="comment">// Do something with the metadata.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="6-3-将CMSampleBuffer转换为UIImage"><a href="#6-3-将CMSampleBuffer转换为UIImage" class="headerlink" title="6.3 将CMSampleBuffer转换为UIImage"></a>6.3 将CMSampleBuffer转换为UIImage</h2><p>下面的代码示例了如何将<code>CMSampleBuffer</code>转换为<code>UIImage</code>。这个转换相当消耗性能，使用时必须进行谨慎考虑。</p>
<p>例如，它适用于从大约每秒钟拍摄的一帧视频数据创建静态图像。您不应该将此作为实时操作来自捕获设备的每一帧视频的方法。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a UIImage from sample buffer data</span></span><br><span class="line">- (<span class="built_in">UIImage</span> *) imageFromSampleBuffer:(<span class="built_in">CMSampleBufferRef</span>) sampleBuffer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Get a CMSampleBuffer&#x27;s Core Video image buffer for the media data</span></span><br><span class="line">    CVImageBufferRef imageBuffer = <span class="built_in">CMSampleBufferGetImageBuffer</span>(sampleBuffer);</span><br><span class="line">    <span class="comment">// Lock the base address of the pixel buffer</span></span><br><span class="line">    CVPixelBufferLockBaseAddress(imageBuffer, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get the number of bytes per row for the pixel buffer</span></span><br><span class="line">    <span class="keyword">void</span> *baseAddress = CVPixelBufferGetBaseAddress(imageBuffer);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Get the number of bytes per row for the pixel buffer</span></span><br><span class="line">    size_t bytesPerRow = CVPixelBufferGetBytesPerRow(imageBuffer);</span><br><span class="line">    <span class="comment">// Get the pixel buffer width and height</span></span><br><span class="line">    size_t width = CVPixelBufferGetWidth(imageBuffer);</span><br><span class="line">    size_t height = CVPixelBufferGetHeight(imageBuffer);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create a device-dependent RGB color space</span></span><br><span class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create a bitmap graphics context with the sample buffer data</span></span><br><span class="line">    <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(baseAddress, width, height, <span class="number">8</span>,</span><br><span class="line">      bytesPerRow, colorSpace, kCGBitmapByteOrder32Little | kCGImageAlphaPremultipliedFirst);</span><br><span class="line">    <span class="comment">// Create a Quartz image from the pixel data in the bitmap graphics context</span></span><br><span class="line">    <span class="built_in">CGImageRef</span> quartzImage = <span class="built_in">CGBitmapContextCreateImage</span>(context);</span><br><span class="line">    <span class="comment">// Unlock the pixel buffer</span></span><br><span class="line">    CVPixelBufferUnlockBaseAddress(imageBuffer,<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Free up the context and color space</span></span><br><span class="line">    <span class="built_in">CGContextRelease</span>(context);</span><br><span class="line">    <span class="built_in">CGColorSpaceRelease</span>(colorSpace);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Create an image object from the Quartz image</span></span><br><span class="line">    <span class="built_in">UIImage</span> *image = [<span class="built_in">UIImage</span> imageWithCGImage:quartzImage];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// Release the Quartz image</span></span><br><span class="line">    <span class="built_in">CGImageRelease</span>(quartzImage);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> (image);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="七、并发编程"><a href="#七、并发编程" class="headerlink" title="七、并发编程"></a>七、并发编程</h1><p>来自 AVFoundation 的回调 —— block、KVO、notification，都不能保证会在任何特定线程或队列上进行。相反，AVFoundation 会在任务的线程或队列上执行这些回调。</p>
<p>两个有关通知和线程的准则：</p>
<ul>
<li>UI 相关的通知必须在主线程中发送</li>
<li>需要创建或指定一个队列的类或方法，将在该队列上返回通知</li>
</ul>
<p>除了这两个准则之外，您不应该假设将在任何特定线程上返回通知。</p>
<p>如果你正在编写一个多线程的应用程序，你可以使用 NSThread 类的下面方法来判断当前是否是你所需要的线程： </p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">BOOL</span> isMainThread;</span><br><span class="line"></span><br><span class="line">[[<span class="built_in">NSThread</span> currentThread] isEqual:&lt;#A stored thread reference#&gt;] </span><br></pre></td></tr></table></figure>

<p>可以使用 NSObject 下面的方法来指定线程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector </span><br><span class="line">                         withObject:(nullable id)arg </span><br><span class="line">                      waitUntilDone:(BOOL)wait;</span><br><span class="line">- (void)performSelector:(SEL)aSelector </span><br><span class="line">               onThread:(NSThread *)thr </span><br><span class="line">             withObject:(nullable id)arg </span><br><span class="line">          waitUntilDone:(BOOL)wait </span><br><span class="line">                  modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br></pre></td></tr></table></figure>

<p>也可以使用 <code>dispatch_async</code>将回调 block 放到合适的线程中执行。</p>
<ul>
<li>更多并发编程的资料参考：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/prerelease/content/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091"><em>Concurrency Programming Guide.</em></a> </li>
<li>更多 block 相关资料参见 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/prerelease/content/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502"><em>Blocks Programming Topics</em></a>. </li>
<li>示例代码 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/prerelease/content/samplecode/AVCam/Introduction/Intro.html#//apple_ref/doc/uid/DTS40010112"><em>AVCam-iOS: Using AVFoundation to Capture Images and Movies</em></a> 是 AVFoundation 的一个基础示例， 并展示了一些 AVFoundation 中线程和队列的用法。</li>
</ul>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="https://tenloy.github.io">Tenloy</a>
            <p>原文链接：<a href="https://tenloy.github.io/2022/03/18/avfoundation.html">https://tenloy.github.io/2022/03/18/avfoundation.html</a>
            <p>发表日期：2022.03.18 , 4:54 PM</p>
            <p>更新日期：2022.06.02 , 9:59 AM</p>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Crative Commons 4.0 许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2022/04/28/mmap.html" title= "内存映射mmap函数的原理与应用">
                    <div class="nextTitle">内存映射mmap函数的原理与应用</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2022/03/17/avframework.html" title= "iOS音视频库概述">
                    <div class="prevTitle">iOS音视频库概述</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:luotengoto@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/Tenloy" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <a href="https://www.jianshu.com/u/8db1bc12db9f" class="iconfont-jian jianshu" target="_blank" title=jianshu></a>
            
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:40vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#AVFoundation%E6%A6%82%E8%BF%B0"><span class="toc-text">AVFoundation概述</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BD%BF%E7%94%A8Assets"><span class="toc-text">一、使用Assets</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A6%82%E8%BF%B0"><span class="toc-text">概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E8%B5%84%E4%BA%A7%E4%B8%8E%E8%BD%A8%E9%81%93-AVAsset%E4%B8%8EAVAssetTrack"><span class="toc-text">1.1 资产与轨道(AVAsset与AVAssetTrack)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-1-AVAsset%E7%B1%BB%E7%BB%93%E6%9E%84"><span class="toc-text">1.1.1 AVAsset类结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-2-%E8%BD%A8%E9%81%93-Track"><span class="toc-text">1.1.2 轨道(Track)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%88%9B%E5%BB%BAAVURLAsset"><span class="toc-text">1.2 创建AVURLAsset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E7%B1%BB%E6%BA%90%E7%A0%81"><span class="toc-text">1.2.1 类源码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AAAVURLAsset%E5%AF%B9%E8%B1%A1"><span class="toc-text">1.2.2 创建一个AVURLAsset对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E8%AE%BF%E9%97%AE%E7%94%A8%E6%88%B7%E7%9A%84asset-iPod%E5%BA%93-%E7%9B%B8%E5%86%8C"><span class="toc-text">1.2.3 访问用户的asset(iPod库+相册)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%BD%BF%E7%94%A8Asset"><span class="toc-text">1.3 使用Asset</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E8%A7%86%E9%A2%91%E4%B8%AD%E8%8E%B7%E5%8F%96%E9%9D%99%E6%80%81%E5%9B%BE%E5%83%8F-AssetImageGenerator"><span class="toc-text">1.4 视频中获取静态图像(AssetImageGenerator)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-%E7%94%9F%E6%88%90%E5%8D%95%E4%B8%AA%E5%9B%BE%E5%83%8F"><span class="toc-text">1.4.1 生成单个图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-%E7%94%9F%E6%88%90%E4%B8%80%E7%B3%BB%E5%88%97%E5%9B%BE%E5%83%8F"><span class="toc-text">1.4.2 生成一系列图像</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E8%A7%86%E9%A2%91%E7%9A%84%E5%89%AA%E8%BE%91%E5%92%8C%E8%BD%AC%E7%A0%81-AVAssetExportSession"><span class="toc-text">1.5 视频的剪辑和转码(AVAssetExportSession)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%92%AD%E6%94%BEAssets"><span class="toc-text">二、播放Assets</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E6%A0%B8%E5%BF%83%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 核心类概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-%E6%92%AD%E6%94%BE%E5%99%A8AVPlayer"><span class="toc-text">2.1.1 播放器AVPlayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-AVPlayerItem"><span class="toc-text">2.1.2 AVPlayerItem</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-3-AVPlayerLayer"><span class="toc-text">2.1.3 AVPlayerLayer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-4-%E7%B1%BB%E5%85%B3%E7%B3%BB%E6%A2%B3%E7%90%86"><span class="toc-text">2.1.4 类关系梳理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%A4%84%E7%90%86%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-text">2.2 处理不同类型的资源</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E4%B8%A4%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%B5%84%E6%BA%90"><span class="toc-text">2.2.1 两种类型资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%92%AD%E6%94%BE%E5%9F%BA%E4%BA%8E%E6%96%87%E4%BB%B6%E7%9A%84%E8%B5%84%E6%BA%90"><span class="toc-text">2.2.2 播放基于文件的资源</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%92%AD%E6%94%BE-HTTP-%E5%AE%9E%E6%97%B6%E6%B5%81"><span class="toc-text">2.2.3 播放 HTTP 实时流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-URL%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%88%A4%E6%96%AD"><span class="toc-text">2.2.4 URL类型的判断</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E6%92%AD%E6%94%BE%E4%B8%80%E4%B8%AA%E9%A1%B9%E7%9B%AE-AVPlayer"><span class="toc-text">2.3 播放一个项目 AVPlayer</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">2.3.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-2-%E6%9B%B4%E6%94%B9%E6%92%AD%E6%94%BE%E9%80%9F%E5%BA%A6"><span class="toc-text">2.3.2 更改播放速度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3-3-%E5%AF%BB%E6%89%BE%E2%80%94%E9%87%8D%E6%96%B0%E5%AE%9A%E4%BD%8D%E6%92%AD%E6%94%BE%E5%A4%B4"><span class="toc-text">2.3.3 寻找—重新定位播放头</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-%E6%92%AD%E6%94%BE%E5%A4%9A%E4%B8%AA%E9%A1%B9%E7%9B%AE-AVQueuePlayer"><span class="toc-text">2.4 播放多个项目 AVQueuePlayer</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E6%92%AD%E6%94%BE%E7%9B%91%E5%90%AC"><span class="toc-text">2.5 播放监听</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">2.5.1 使用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E7%9B%91%E5%90%ACstatus%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-text">2.5.2 监听status的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E7%9B%91%E5%90%AC%E5%8F%AF%E8%A7%86%E5%8C%96%E5%86%85%E5%AE%B9%E7%9A%84%E5%B0%B1%E7%BB%AA%E7%8A%B6%E6%80%81"><span class="toc-text">2.5.3 监听可视化内容的就绪状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-%E7%9B%91%E5%90%AC%E6%92%AD%E6%94%BE%E6%97%B6%E9%97%B4"><span class="toc-text">2.5.4 监听播放时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-5-%E7%9B%91%E5%90%AC%E6%92%AD%E6%94%BE%E7%BB%93%E6%9D%9F"><span class="toc-text">2.5.5 监听播放结束</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E4%BD%BF%E7%94%A8-AVPlayerLayer-%E6%92%AD%E6%94%BE%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6"><span class="toc-text">2.6 示例：使用 AVPlayerLayer 播放视频文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#step1-%E5%AE%9A%E4%B9%89-Player-View"><span class="toc-text">step1: 定义 Player View</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step2-%E9%85%8D%E7%BD%AE-View-Controller"><span class="toc-text">step2: 配置 View Controller</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step3-%E5%88%9B%E5%BB%BA-Asset%E3%80%81PlayerItem%E3%80%81Player"><span class="toc-text">step3: 创建 Asset、PlayerItem、Player</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step4-%E5%93%8D%E5%BA%94-PlayerItem-%E7%9A%84-status-%E6%94%B9%E5%8F%98"><span class="toc-text">step4: 响应 PlayerItem 的 status 改变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#step5-%E6%92%AD%E6%94%BE-Item"><span class="toc-text">step5: 播放 Item</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BC%96%E8%BE%91-Assets"><span class="toc-text">三、编辑 Assets</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-Asset%E5%90%88%E6%88%90-AVMutableComposition"><span class="toc-text">3.1 Asset合成(AVMutableComposition)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-text">核心类概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-%E5%88%9B%E5%BB%BAAVMutableComposition"><span class="toc-text">3.1.1 创建AVMutableComposition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-%E6%B7%BB%E5%8A%A0AVMutableCompositionTrack"><span class="toc-text">3.1.2 添加AVMutableCompositionTrack</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E5%90%91composition-track%E4%B8%AD%E6%B7%BB%E5%8A%A0AVAssetTrack"><span class="toc-text">3.1.3 向composition track中添加AVAssetTrack</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%B7%BB%E5%8A%A0%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE"><span class="toc-text">1. 添加媒体数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%A3%80%E7%B4%A2%E5%85%BC%E5%AE%B9%E7%9A%84-Composition-Tracks"><span class="toc-text">2. 检索兼容的 Composition Tracks</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-4-%E5%B0%8F%E7%BB%93"><span class="toc-text">3.1.4 小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E9%9F%B3%E9%A2%91%E6%B7%B7%E5%90%88-AVMutableAudioMix"><span class="toc-text">3.2 音频混合(AVMutableAudioMix)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-%E6%A0%B8%E5%BF%83%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-text">3.2.1 核心类概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-%E7%A4%BA%E4%BE%8B-%E8%87%AA%E5%AE%9A%E4%B9%89%E9%9F%B3%E9%A2%91%E5%A4%84%E7%90%86-%E2%80%94-%E9%9F%B3%E9%87%8F%E6%B8%90%E5%8F%98"><span class="toc-text">3.2.2 示例: 自定义音频处理 — 音量渐变</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E8%A7%86%E9%A2%91%E5%90%88%E6%88%90-AVMutableVideoComposition"><span class="toc-text">3.3 视频合成(AVMutableVideoComposition)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-1-%E6%A0%B8%E5%BF%83%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-text">3.3.1 核心类概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E5%9B%BE"><span class="toc-text">1. 类图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%86%E9%A2%91%E5%90%88%E6%88%90%E7%B1%BB"><span class="toc-text">2. 视频合成类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%A7%86%E9%A2%91%E5%90%88%E6%88%90%E6%8C%87%E4%BB%A4%E7%B1%BB"><span class="toc-text">3. 视频合成指令类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%A0%B8%E5%BF%83%E5%8A%A8%E7%94%BB%E5%B7%A5%E5%85%B7"><span class="toc-text">4. 核心动画工具</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-2-%E7%A4%BA%E4%BE%8B-%E8%87%AA%E5%AE%9A%E4%B9%89%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86"><span class="toc-text">3.3.2 示例: 自定义视频处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%AE%BE%E7%BD%AE-Composition-%E7%9A%84%E8%83%8C%E6%99%AF%E8%89%B2"><span class="toc-text">1. 设置 Composition 的背景色</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%AE%BE%E7%BD%AE-track-%E5%88%87%E6%8D%A2%E6%97%B6%E7%9A%84%E9%80%8F%E6%98%8E%E5%BA%A6%E6%B8%90%E5%8F%98"><span class="toc-text">2. 设置 track 切换时的透明度渐变</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%BB%93%E5%90%88-Core-Animation"><span class="toc-text">3. 结合 Core Animation</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-%E9%9F%B3%E8%A7%86%E9%A2%91%E7%BB%84%E5%90%88-AVAssetExportSession"><span class="toc-text">3.4 音视频组合(AVAssetExportSession)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-%E7%A4%BA%E4%BE%8B-%E5%A4%9A%E4%B8%AAasset%E7%9A%84%E5%90%88%E6%88%90%E4%B8%8E%E5%AF%BC%E5%87%BA"><span class="toc-text">3.5 示例: 多个asset的合成与导出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%88%9B%E5%BB%BA-Composition"><span class="toc-text">1. 创建 Composition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%B7%BB%E5%8A%A0-Assets"><span class="toc-text">2. 添加 Assets</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%E8%A7%86%E9%A2%91%E6%96%B9%E5%90%91"><span class="toc-text">3. 判断视频方向</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%AE%BE%E7%BD%AE%E8%A7%86%E9%A2%91%E5%90%88%E6%88%90%E5%9B%BE%E5%B1%82%E6%8C%87%E4%BB%A4"><span class="toc-text">4. 设置视频合成图层指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E8%AE%BE%E7%BD%AE%E6%B8%B2%E6%9F%93%E5%B0%BA%E5%AF%B8%E5%92%8C%E5%B8%A7%E7%8E%87"><span class="toc-text">5. 设置渲染尺寸和帧率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%AF%BC%E5%87%BA-Composition"><span class="toc-text">6. 导出 Composition</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E9%9D%99%E6%80%81%E5%9B%BE%E7%89%87%E5%92%8C%E8%A7%86%E9%A2%91%E6%8D%95%E6%8D%89"><span class="toc-text">四、静态图片和视频捕捉</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E7%B1%BB%E6%A6%82%E8%BF%B0-1"><span class="toc-text">核心类概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E4%BD%BF%E7%94%A8AVCaptureSession%E5%8D%8F%E8%B0%83%E6%95%B0%E6%8D%AE%E6%B5%81"><span class="toc-text">4.1 使用AVCaptureSession协调数据流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-AVCaptureSession-%E7%B1%BB"><span class="toc-text">4.1.1 AVCaptureSession 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E9%85%8D%E7%BD%AE-Capture-Session"><span class="toc-text">4.1.2 配置 Capture Session</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E7%9B%91%E5%90%AC-Capture-Session-%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text">4.1.3 监听 Capture Session 的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E8%A1%A5%E5%85%85-AVCaptureConnection-%E7%B1%BB"><span class="toc-text">4.1.4 补充: AVCaptureConnection 类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E4%BD%BF%E7%94%A8AVCaptureDevice%E8%A1%A8%E7%A4%BA%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87"><span class="toc-text">4.2 使用AVCaptureDevice表示输入设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E8%AE%BE%E5%A4%87%E7%89%B9%E6%80%A7"><span class="toc-text">4.2.1 设备特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E8%AE%BE%E5%A4%87%E6%8D%95%E6%8D%89%E6%97%B6%E7%9A%84%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE"><span class="toc-text">4.2.2 设备捕捉时的参数设置</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%AF%B9%E7%84%A6%E6%A8%A1%E5%BC%8F-Focus%E5%88%86%E7%B1%BB"><span class="toc-text">1. 对焦模式(Focus分类)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9B%9D%E5%85%89%E6%A8%A1%E5%BC%8F-Exposure%E5%88%86%E7%B1%BB"><span class="toc-text">2. 曝光模式(Exposure分类)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E9%97%AA%E5%85%89%E6%A8%A1%E5%BC%8F-Flash%E5%88%86%E7%B1%BB"><span class="toc-text">3. 闪光模式(Flash分类)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%89%8B%E7%94%B5%E7%AD%92%E6%A8%A1%E5%BC%8F-Torch%E5%88%86%E7%B1%BB"><span class="toc-text">4. 手电筒模式(Torch分类)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E7%99%BD%E5%B9%B3%E8%A1%A1-WhiteBalance%E5%88%86%E7%B1%BB"><span class="toc-text">5. 白平衡(WhiteBalance分类)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E8%A7%86%E9%A2%91%E7%A8%B3%E5%AE%9A%E6%80%A7-AVCaptureConnection"><span class="toc-text">6. 视频稳定性(AVCaptureConnection)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%AE%BE%E7%BD%AE%E8%AE%BE%E5%A4%87%E6%96%B9%E5%90%91-AVCaptureConnection"><span class="toc-text">7. 设置设备方向(AVCaptureConnection)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E8%AE%BE%E5%A4%87%E9%85%8D%E7%BD%AE"><span class="toc-text">4.2.3 设备配置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-%E5%88%87%E6%8D%A2%E8%AE%BE%E5%A4%87"><span class="toc-text">4.2.4 切换设备</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E4%BD%BF%E7%94%A8AVCaptureInput%E6%B7%BB%E5%8A%A0%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87"><span class="toc-text">4.3 使用AVCaptureInput添加输入设备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-AVCaptureInput-%E4%B8%8E-Port"><span class="toc-text">4.3.1 AVCaptureInput 与 Port</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E6%B7%BB%E5%8A%A0%E8%BE%93%E5%85%A5%E8%AE%BE%E5%A4%87-AVCaptureSession"><span class="toc-text">4.3.2 添加输入设备(AVCaptureSession)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-%E4%BD%BF%E7%94%A8AVCaptureOutput%E8%BE%93%E5%87%BA%E6%95%B0%E6%8D%AE"><span class="toc-text">4.4 使用AVCaptureOutput输出数据</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E8%BE%93%E5%87%BA%E4%B8%BA%E8%A7%86%E9%A2%91%E6%96%87%E4%BB%B6-AVCaptureFileOutput"><span class="toc-text">4.4.1 输出为视频文件(AVCaptureFileOutput)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%89%E4%B8%AA%E8%BE%93%E5%87%BA%E6%96%87%E4%BB%B6%E7%B1%BB"><span class="toc-text">1. 三个输出文件类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E4%B8%A4%E4%B8%AA%E5%8D%8F%E8%AE%AE"><span class="toc-text">2. 两个协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B"><span class="toc-text">3. 简单示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E6%B7%BB%E5%8A%A0%E5%85%83%E6%95%B0%E6%8D%AE-AVMetadataItem"><span class="toc-text">4. 在文件中添加元数据(AVMetadataItem)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%A4%84%E7%90%86%E8%A7%86%E9%A2%91%E5%B8%A7-AVCaptureVideoDataOutput"><span class="toc-text">4.4.2 处理视频帧(AVCaptureVideoDataOutput)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-AVCaptureVideoDataOutput%E7%B1%BB"><span class="toc-text">1. AVCaptureVideoDataOutput类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%A7%86%E9%A2%91%E5%A4%84%E7%90%86%E6%97%B6%E7%9A%84%E6%80%A7%E8%83%BD%E8%80%83%E8%99%91"><span class="toc-text">2. 视频处理时的性能考虑</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-3-%E6%8D%95%E6%8D%89%E9%9D%99%E6%80%81%E5%9B%BE%E5%83%8F-AVCaptureStillImageOutput"><span class="toc-text">4.4.3 捕捉静态图像(AVCaptureStillImageOutput)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%83%8F%E7%B4%A0%E5%92%8C%E7%BC%96%E7%A0%81%E6%A0%BC%E5%BC%8F"><span class="toc-text">1. 像素和编码格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%8D%95%E6%8D%89%E5%9B%BE%E7%89%87"><span class="toc-text">2. 捕捉图片</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-%E5%BD%95%E5%88%B6%E9%A2%84%E8%A7%88"><span class="toc-text">4.5 录制预览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E8%A7%86%E9%A2%91%E9%A2%84%E8%A7%88-AVCaptureVideoPreviewLayer"><span class="toc-text">4.5.1 视频预览(AVCaptureVideoPreviewLayer)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-AVCaptureVideoPreviewLayer%E7%B1%BB"><span class="toc-text">1. AVCaptureVideoPreviewLayer类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%A2%84%E8%A7%88%E6%97%B6%E4%BD%BF%E7%94%A8%E7%82%B9%E5%87%BB%E8%81%9A%E7%84%A6%E5%8A%9F%E8%83%BD"><span class="toc-text">2. 预览时使用点击聚焦功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E5%B1%95%E7%A4%BA%E5%A3%B0%E9%9F%B3%E7%AD%89%E7%BA%A7-AVCaptureAudioChannel"><span class="toc-text">4.5.2 展示声音等级(AVCaptureAudioChannel)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-%E7%A4%BA%E4%BE%8B-%E6%8D%95%E6%8D%89%E8%A7%86%E9%A2%91%E5%B8%A7%E4%B8%BAUIImage%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.6 示例: 捕捉视频帧为UIImage对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-%E9%AB%98%E5%B8%A7%E7%8E%87%E8%A7%86%E9%A2%91%E6%8D%95%E6%8D%89"><span class="toc-text">4.7 高帧率视频捕捉</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-%E6%92%AD%E6%94%BE"><span class="toc-text">4.7.1 播放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E7%BC%96%E8%BE%91"><span class="toc-text">4.7.2 编辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E5%AF%BC%E5%87%BA"><span class="toc-text">4.7.3 导出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-4-%E5%BD%95%E5%88%B6"><span class="toc-text">4.7.4 录制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Asset%E7%9A%84%E8%AF%BB%E3%80%81%E5%86%99%E3%80%81%E9%87%8D%E7%BC%96%E7%A0%81"><span class="toc-text">五、Asset的读、写、重编码</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E8%AF%BB%E5%8F%96Asset-AVAssetReader"><span class="toc-text">5.1 读取Asset(AVAssetReader)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AVAssetReader-%E5%92%8C-Output-%E7%B1%BB"><span class="toc-text">AVAssetReader 和 Output 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E5%88%9B%E5%BB%BA-AVAssetReader"><span class="toc-text">5.1.1 创建 AVAssetReader</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-%E8%AE%BE%E7%BD%AE-AVAssetReaderOutput"><span class="toc-text">5.1.2 设置 AVAssetReaderOutput</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-AVAssetReaderTrackOutput"><span class="toc-text">1. AVAssetReaderTrackOutput</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-AVAssetReaderAudioMixOutput"><span class="toc-text">2. AVAssetReaderAudioMixOutput</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-AVAssetReaderVideoCompositionOutput"><span class="toc-text">3. AVAssetReaderVideoCompositionOutput</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E8%AF%BB%E5%8F%96-Asset-%E4%B8%AD%E7%9A%84%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE"><span class="toc-text">5.1.3 读取 Asset 中的媒体数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E5%86%99%E5%85%A5Asset-AVAssetWriter"><span class="toc-text">5.2 写入Asset(AVAssetWriter)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AVAssetWriter-%E5%92%8C-Input-%E7%B1%BB"><span class="toc-text">AVAssetWriter 和 Input 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1-%E5%88%9B%E5%BB%BA-AVAssetWriter"><span class="toc-text">5.2.1 创建 AVAssetWriter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2-%E8%AE%BE%E7%BD%AE-AVAssetWriterInput"><span class="toc-text">5.2.2 设置 AVAssetWriterInput</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-AVAssetWriterInput"><span class="toc-text">1. AVAssetWriterInput</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-AVAssetWriterInputPixelBufferAdaptor"><span class="toc-text">2. AVAssetWriterInputPixelBufferAdaptor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3-%E5%86%99%E5%85%A5%E5%AA%92%E4%BD%93%E6%95%B0%E6%8D%AE"><span class="toc-text">5.2.3 写入媒体数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-%E9%87%8D%E7%BC%96%E7%A0%81Assets"><span class="toc-text">5.3 重编码Assets</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E7%A4%BA%E4%BE%8B-Asset-Reader%E5%92%8CWriter-%E9%87%8D%E7%BC%96%E7%A0%81-Asset"><span class="toc-text">5.4 示例: Asset Reader和Writer 重编码 Asset</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%AE%BE%E7%BD%AE"><span class="toc-text">5.4.1 初始化设置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-%E5%8A%A0%E8%BD%BD-asset-%E4%B8%AD%E7%9A%84-track%EF%BC%8C%E5%B9%B6%E5%BC%80%E5%A7%8B%E9%87%8D%E7%BC%96%E7%A0%81"><span class="toc-text">5.4.2 加载 asset 中的 track，并开始重编码.</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-3-%E5%88%9D%E5%A7%8B%E5%8C%96-Asset-Reader-%E5%92%8C-Writer"><span class="toc-text">5.4.3 初始化 Asset Reader 和 Writer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-4-%E9%87%8D%E7%BC%96%E7%A0%81-Asset"><span class="toc-text">5.4.4 重编码 Asset</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-5-%E5%A4%84%E7%90%86%E7%BC%96%E7%A0%81%E7%BB%93%E6%9E%9C"><span class="toc-text">5.4.5 处理编码结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-6-%E5%8F%96%E6%B6%88%E9%87%8D%E7%BC%96%E7%A0%81"><span class="toc-text">5.4.6 取消重编码</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-5-AVOutputSettingsAssistant%E4%BB%8B%E7%BB%8D"><span class="toc-text">5.5 AVOutputSettingsAssistant介绍</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%97%B6%E9%97%B4%E5%92%8C%E5%AA%92%E4%BD%93%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">六、时间和媒体的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-%E6%97%B6%E9%97%B4%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-text">6.1 时间的表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-1-%E7%94%A8-CMTime-%E8%A1%A8%E7%A4%BA%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4"><span class="toc-text">6.1.1 用 CMTime 表示一段时间</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-CMTime%E7%9A%84%E5%88%9B%E5%BB%BA%E4%B8%8E%E4%BD%BF%E7%94%A8"><span class="toc-text">1. CMTime的创建与使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CMTime-%E7%9A%84%E7%89%B9%E6%AE%8A%E5%80%BC%E4%B8%8E%E5%88%A4%E6%96%AD%E5%AE%8F"><span class="toc-text">2. CMTime 的特殊值与判断宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%86-CMTime-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 将 CMTime 转换为对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E7%BA%AA%E5%85%83-Epochs"><span class="toc-text">4. 纪元 (Epochs)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-2-%E7%94%A8-CMTimeRange-%E8%A1%A8%E7%A4%BA%E4%B8%80%E4%B8%AA%E6%97%B6%E9%97%B4%E8%8C%83%E5%9B%B4"><span class="toc-text">6.1.2 用 CMTimeRange 表示一个时间范围</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%A4%84%E7%90%86-CMTimeRange"><span class="toc-text">1. 处理 CMTimeRange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-CMTimeRange-%E7%9A%84%E7%89%B9%E6%AE%8A%E5%80%BC"><span class="toc-text">2. CMTimeRange 的特殊值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%B0%86-CMTimeRange-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">3. 将 CMTimeRange 转换为对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-2-%E5%AA%92%E4%BD%93%E7%9A%84%E8%A1%A8%E7%A4%BA-CMSampleBuffer"><span class="toc-text">6.2 媒体的表示(CMSampleBuffer)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-3-%E5%B0%86CMSampleBuffer%E8%BD%AC%E6%8D%A2%E4%B8%BAUIImage"><span class="toc-text">6.3 将CMSampleBuffer转换为UIImage</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B"><span class="toc-text">七、并发编程</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="操作系统"><span class="iconfont-archer">&#xe60a;</span>操作系统</span>
    
        <span class="sidebar-category-name" data-categories="数据的传输与存储"><span class="iconfont-archer">&#xe60a;</span>数据的传输与存储</span>
    
        <span class="sidebar-category-name" data-categories="Swift"><span class="iconfont-archer">&#xe60a;</span>Swift</span>
    
        <span class="sidebar-category-name" data-categories="性能优化"><span class="iconfont-archer">&#xe60a;</span>性能优化</span>
    
        <span class="sidebar-category-name" data-categories="编译链接与装载"><span class="iconfont-archer">&#xe60a;</span>编译链接与装载</span>
    
        <span class="sidebar-category-name" data-categories="计算机组成原理"><span class="iconfont-archer">&#xe60a;</span>计算机组成原理</span>
    
        <span class="sidebar-category-name" data-categories="计算机网络"><span class="iconfont-archer">&#xe60a;</span>计算机网络</span>
    
        <span class="sidebar-category-name" data-categories="音视频处理"><span class="iconfont-archer">&#xe60a;</span>音视频处理</span>
    
        <span class="sidebar-category-name" data-categories="软件工程"><span class="iconfont-archer">&#xe60a;</span>软件工程</span>
    
        <span class="sidebar-category-name" data-categories="DSL"><span class="iconfont-archer">&#xe60a;</span>DSL</span>
    
        <span class="sidebar-category-name" data-categories="数据结构与算法"><span class="iconfont-archer">&#xe60a;</span>数据结构与算法</span>
    
        <span class="sidebar-category-name" data-categories="iOS"><span class="iconfont-archer">&#xe60a;</span>iOS</span>
    
        <span class="sidebar-category-name" data-categories="图形处理与渲染"><span class="iconfont-archer">&#xe60a;</span>图形处理与渲染</span>
    
        <span class="sidebar-category-name" data-categories="架构与设计模式"><span class="iconfont-archer">&#xe60a;</span>架构与设计模式</span>
    
        <span class="sidebar-category-name" data-categories="Hybid-APP"><span class="iconfont-archer">&#xe60a;</span>Hybid-APP</span>
    
        <span class="sidebar-category-name" data-categories="互联网标准RFC"><span class="iconfont-archer">&#xe60a;</span>互联网标准RFC</span>
    
        <span class="sidebar-category-name" data-categories="汇编语言"><span class="iconfont-archer">&#xe60a;</span>汇编语言</span>
    
        <span class="sidebar-category-name" data-categories="React"><span class="iconfont-archer">&#xe60a;</span>React</span>
    
        <span class="sidebar-category-name" data-categories="Web"><span class="iconfont-archer">&#xe60a;</span>Web</span>
    
        <span class="sidebar-category-name" data-categories="Git"><span class="iconfont-archer">&#xe60a;</span>Git</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 57
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-side-search"> 
                <span class="iconfont-jian search-icon">&#xe7fc;搜索</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2022 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span><a class="archive-post-title" href= "/2022/05/05/sqlite.html" >iOS SQLite的使用与优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href= "/2022/04/28/mmap.html" >内存映射mmap函数的原理与应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/18</span><a class="archive-post-title" href= "/2022/03/18/avfoundation.html" >AVFoundation Programming Guide(译)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span><a class="archive-post-title" href= "/2022/03/17/avframework.html" >iOS音视频库概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2022/02/09/OAuth.html" >[转] OAuth 2.0简述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/18</span><a class="archive-post-title" href= "/2022/01/18/wkwebview-buges.html" >WKWebView使用过程中遇到的坑</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/22</span><a class="archive-post-title" href= "/2021/12/22/aes.html" >数据加密 — 对称加密(以AES为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href= "/2021/12/21/aes-standard.html" >[转] AES标准及Rijndael算法解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span><a class="archive-post-title" href= "/2021/12/20/asymmetric.html" >数据加密 — 非对称加密(加签/加密，以RSA为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/09</span><a class="archive-post-title" href= "/2021/12/09/pki.html" >常见的PKI标准(X.509、PKCS)及证书相关介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/22</span><a class="archive-post-title" href= "/2021/11/22/bit-calculation.html" >[转] 位运算实现加、减、乘、除运算</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span><a class="archive-post-title" href= "/2021/11/10/git-use.html" >Git的使用总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/11</span><a class="archive-post-title" href= "/2021/10/11/runtime-data-structure.html" >Objc Runtime总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/2021/09/28/dyld-objc.html" >(七) dyld与Objc—_objc_init、map_images、load_images</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2021/09/27/compile-dynamic-link.html" >(六) Mach-O 文件的动态链接、库、Dyld(含dlopen)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/26</span><a class="archive-post-title" href= "/2021/09/26/compile-vm-asrl.html" >(五) Mach-O 文件之进程(虚拟)地址空间、ASLR</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href= "/2021/09/25/compile-load.html" >(四) Mach-O 文件的装载</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/24</span><a class="archive-post-title" href= "/2021/09/24/compile-static-link.html" >(三) Mach-O 文件的静态链接</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/23</span><a class="archive-post-title" href= "/2021/09/23/compile-macho.html" >(二) Mach-O 文件结构</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/22</span><a class="archive-post-title" href= "/2021/09/22/compile-clang-llvm.html" >(一) Clang/LLVM 介绍、OC 程序的编译过程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href= "/2021/09/20/architectural-pattern.html" >常见架构模式: MVC、MVP、MVVM、VIPER</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/18</span><a class="archive-post-title" href= "/2021/09/18/design-pattern.html" >常见的设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing-case.html" >图形处理(三) - 图形处理实践案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing.html" >图形处理(二) - 图形与视频处理相关的框架</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2021/09/13/image-encode-decode.html" >图形处理(一) - 图片的加载与编解码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/12</span><a class="archive-post-title" href= "/2021/09/12/iOS-Render.html" >[转] iOS离屏渲染原理及优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2021/09/11/core-animation03.html" >Core-Animation(三) - 渲染流程探究及性能分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/09</span><a class="archive-post-title" href= "/2021/09/09/core-animation02.html" >Core Animation(二) - 隐式动画、CATransaction与CAAction</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/07</span><a class="archive-post-title" href= "/2021/09/07/core-animation01.html" >Core Animation(一) - UIView与CALayer、布局与绘制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span><a class="archive-post-title" href= "/2021/09/05/AFN-Analyse.html" >[转] AFN框架实现解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2021/09/02/Log.html" >移动端日志库设计</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2021/07/01/Crash-Monitor.html" >iOS崩溃监控与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href= "/2021/06/30/Lag-Monitor.html" >iOS卡顿监控</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/29</span><a class="archive-post-title" href= "/2021/06/29/SwiftUI.html" >SwiftUI</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/29</span><a class="archive-post-title" href= "/2021/06/29/Swift-Version-History.html" >Swift版本更新API介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/28</span><a class="archive-post-title" href= "/2021/06/28/GCD.html" >深入浅出GCD常用API</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/28</span><a class="archive-post-title" href= "/2021/06/28/AutoreleasePool.html" >AutoreleasePool</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/26</span><a class="archive-post-title" href= "/2021/06/26/RunLoop-Reposted-From-ibireme.html" >[转] 深入理解RunLoop—ibireme</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/25</span><a class="archive-post-title" href= "/2021/06/25/Protocol-Buffer.html" >Protocol Buffer的基本介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/24</span><a class="archive-post-title" href= "/2021/06/24/base64.html" >Base64编码及iOS中的Base64</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/23</span><a class="archive-post-title" href= "/2021/06/23/chinese-encode.html" >[转] 彻底弄懂常见的7种中文字符编码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/22</span><a class="archive-post-title" href= "/2021/06/22/dynamic-programming.html" >(二) 动态规划算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span><a class="archive-post-title" href= "/2021/06/18/Web-Module.html" >前端各种模块化方案总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Fiber.html" >[转] 最通俗的 React Fiber(时间分片)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Coroutine.html" >[转] 什么是协程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/29</span><a class="archive-post-title" href= "/2021/04/29/DSL.html" >[转] 谈谈DSL以及DSL的应用（以CocoaPods 为例）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/26</span><a class="archive-post-title" href= "/2021/04/26/Containers.html" >常见的容器概念：Linux容器、Docker容器、服务器容器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span><a class="archive-post-title" href= "/2021/04/24/Dock-Reprinted-from-RuanYIFeng.html" >[转] Docker入门教程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span><a class="archive-post-title" href= "/2021/04/20/Sync-Async.html" >同步和异步解读及编程中的使用场景</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span><a class="archive-post-title" href= "/2021/04/17/Arm64-Handbook.html" >ARM64指令简易手册</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span><a class="archive-post-title" href= "/2021/04/16/Arm64-Introduce.html" >iOS需要了解的ARM64汇编</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span><a class="archive-post-title" href= "/2021/04/13/Command-Line.html" >CLI Shell、Terminal、脚本(语言)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href= "/2021/04/10/Ins-SysCall-Kernel-Shell.html" >指令、系统调用、库、Shell、APP的层次关系</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span><a class="archive-post-title" href= "/2021/04/08/ISA-Microarch-Soc.html" >指令集、微架构、手机芯片(Soc)及ARM的介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/05</span><a class="archive-post-title" href= "/2021/04/05/iOS-CI.html" >iOS的持续集成</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span><a class="archive-post-title" href= "/2021/04/02/Engineering.html" >工程化、动态化、容器化、组件化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2021/04/01/GithubPages-Hexo.html" >使用Hexo+Github Pages搭建个人博客</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="hexo"><span class="iconfont-archer">&#xe606;</span>hexo</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="协程"><span class="iconfont-archer">&#xe606;</span>协程</span>
    
        <span class="sidebar-tag-name" data-tags="SwiftUI"><span class="iconfont-archer">&#xe606;</span>SwiftUI</span>
    
        <span class="sidebar-tag-name" data-tags="Swift-Syntax"><span class="iconfont-archer">&#xe606;</span>Swift-Syntax</span>
    
        <span class="sidebar-tag-name" data-tags="Log"><span class="iconfont-archer">&#xe606;</span>Log</span>
    
        <span class="sidebar-tag-name" data-tags="ISA"><span class="iconfont-archer">&#xe606;</span>ISA</span>
    
        <span class="sidebar-tag-name" data-tags="Microarch"><span class="iconfont-archer">&#xe606;</span>Microarch</span>
    
        <span class="sidebar-tag-name" data-tags="Soc"><span class="iconfont-archer">&#xe606;</span>Soc</span>
    
        <span class="sidebar-tag-name" data-tags="Docker"><span class="iconfont-archer">&#xe606;</span>Docker</span>
    
        <span class="sidebar-tag-name" data-tags="DSL"><span class="iconfont-archer">&#xe606;</span>DSL</span>
    
        <span class="sidebar-tag-name" data-tags="dp"><span class="iconfont-archer">&#xe606;</span>dp</span>
    
        <span class="sidebar-tag-name" data-tags="AutoreleasePool"><span class="iconfont-archer">&#xe606;</span>AutoreleasePool</span>
    
        <span class="sidebar-tag-name" data-tags="CLI"><span class="iconfont-archer">&#xe606;</span>CLI</span>
    
        <span class="sidebar-tag-name" data-tags="Shell"><span class="iconfont-archer">&#xe606;</span>Shell</span>
    
        <span class="sidebar-tag-name" data-tags="ARM64"><span class="iconfont-archer">&#xe606;</span>ARM64</span>
    
        <span class="sidebar-tag-name" data-tags="RunLoop"><span class="iconfont-archer">&#xe606;</span>RunLoop</span>
    
        <span class="sidebar-tag-name" data-tags="LagMonitor"><span class="iconfont-archer">&#xe606;</span>LagMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="CrashMonitor"><span class="iconfont-archer">&#xe606;</span>CrashMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="Fiber"><span class="iconfont-archer">&#xe606;</span>Fiber</span>
    
        <span class="sidebar-tag-name" data-tags="GCD"><span class="iconfont-archer">&#xe606;</span>GCD</span>
    
        <span class="sidebar-tag-name" data-tags="AFN"><span class="iconfont-archer">&#xe606;</span>AFN</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Tenloy"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


