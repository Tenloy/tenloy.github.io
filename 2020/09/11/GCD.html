<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Tenloy">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Tenloy">
    
    <meta name="keywords" content="Tenloy,iOS,Swift">
    
    <meta name="description" content="学习 生活 记录 回忆">
    <meta name="description" content="一、什么是多线程编程？先来复习一下操作系统中线程相关的知识点： 1.1 代码的运行首先，代码是怎么运行的？  源代码通过编译器转换为CPU命令列(二进制编码)，应用程序就是CPU命令列和数据的汇集，在应用程序启动后，首先便将包含在应用程序中的CPU命令列配置在内存中。 CPU从应用程序指定的地址开始，一个一个的执行CUP命令列。在OC的if语句和for语句等控制语句或函数调用的情况下，执行命令列的">
<meta property="og:type" content="article">
<meta property="og:title" content="Objective-C — 深入浅出GCD常用API">
<meta property="og:url" content="https://tenloy.github.io/2020/09/11/GCD.html">
<meta property="og:site_name" content="Tenloy&#39;s Blog">
<meta property="og:description" content="一、什么是多线程编程？先来复习一下操作系统中线程相关的知识点： 1.1 代码的运行首先，代码是怎么运行的？  源代码通过编译器转换为CPU命令列(二进制编码)，应用程序就是CPU命令列和数据的汇集，在应用程序启动后，首先便将包含在应用程序中的CPU命令列配置在内存中。 CPU从应用程序指定的地址开始，一个一个的执行CUP命令列。在OC的if语句和for语句等控制语句或函数调用的情况下，执行命令列的">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch_queue-2.png">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch_queue-1.png">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch_queue-3.png">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch_queue-4.png">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch_queue-5.png">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch_queue-6.png">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch_queue-7.png">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/gcd-imp-1.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch-semaphore-1.png">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch-semaphore-2.png">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch_queue-8.png">
<meta property="og:image" content="https://tenloy.github.io/images/GCD/dispatch_once.png">
<meta property="article:published_time" content="2020-09-11T01:12:21.000Z">
<meta property="article:modified_time" content="2025-02-05T06:45:19.169Z">
<meta property="article:author" content="Tenloy">
<meta property="article:tag" content="GCD">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tenloy.github.io/images/GCD/dispatch_queue-2.png">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>Objective-C — 深入浅出GCD常用API · Tenloy&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"Search for Posts","hits_empty":"没有找到任何搜索结果: ${query}","hits_stats":"找到约${hits}条结果（用时${time}ms）"}')

            var algolia = {
                applicationID: 'V0HYXBS9FB',
                apiKey: '6550d5de786935564142097c3e78c380',
                indexName: 'law_blog_index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Tenloy's Blog" type="application/atom+xml">
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Tenloy&#39;s Blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Objective-C — 深入浅出GCD常用API</a>
            </div>
    </div>
    
    <!-- 将home-link的操作改为应用到header-top-right上 -->
    <div class="header-top-right">
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-search">
                <span class="iconfont-jian tl-search-icon">&#xe7fc;搜索</span>
            </div>
            
        <a class="home-link" href=/>Tenloy's Blog</a>
    </div>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:40vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Objective-C — 深入浅出GCD常用API
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "GCD">GCD</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">21.3k</span>Reading time: <span class="post-count reading-time">90 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/09/11</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="一、什么是多线程编程？"><a href="#一、什么是多线程编程？" class="headerlink" title="一、什么是多线程编程？"></a>一、什么是多线程编程？</h1><p>先来复习一下<strong>操作系统</strong>中线程相关的知识点：</p>
<h2 id="1-1-代码的运行"><a href="#1-1-代码的运行" class="headerlink" title="1.1 代码的运行"></a>1.1 代码的运行</h2><p><strong>首先，代码是怎么运行的？</strong></p>
<ul>
<li>源代码通过编译器转换为CPU命令列(二进制编码)，应用程序就是CPU命令列和数据的汇集，在应用程序启动后，首先便将包含在应用程序中的CPU命令列配置在内存中。</li>
<li>CPU从应用程序指定的地址开始，一个一个的执行CUP命令列。在OC的if语句和for语句等控制语句或函数调用的情况下，执行命令列的地址会远离当前的位置（位置迁移），但是由于一个CUP一次只能执行一个命令，不能执行某处分开的并列的两个命令，因此通过CPU执行的CPU命令列就好比一条无分叉的大道，其执行不会出现分歧。</li>
</ul>
<p><strong>一个CPU执行的CPU命令列尾一条无分叉的路径即为“线程”</strong>。</p>
<h2 id="1-2-几对概念"><a href="#1-2-几对概念" class="headerlink" title="1.2 几对概念"></a>1.2 几对概念</h2><h3 id="1-2-1-并发和并行"><a href="#1-2-1-并发和并行" class="headerlink" title="1.2.1 并发和并行"></a>1.2.1 并发和并行</h3><ul>
<li>并发：<strong>同一时间段</strong>有几个程序都处于已经启动到运行完毕之间，并且这几个程序都在同一个处理机上运行。<ul>
<li>并发的两种关系是同步和互斥。</li>
<li>互斥：进程之间访问临界资源时相互排斥的现象。</li>
<li>同步：进程之间是相互依赖的关系。进一步的说明：就是前一个进程的输出作为后一个进程的输入，当第一个进程没有输出时第二个进程必须等待。</li>
</ul>
</li>
<li>并行：<ul>
<li>单处理器中，进程被交替执行，表现出一种并发的外部特征；</li>
<li>多处理器中，进程可以交替执行，还能重叠执行，实现并行处理。</li>
</ul>
</li>
<li>区别：<ul>
<li>并行是指同一时刻同时做多件事情，例如，在多核处理器上，并发是两个任务可以在重叠的时间段内启动，运行和完成。</li>
<li>并发是指同一时间间隔内做多件事情。</li>
</ul>
</li>
</ul>
<p><strong>并行是并发，但并发不一定是并行。</strong>比如：我们说资源请求并发数达到了1万。这里的意思是有1万个请求同时过来了。但是这里很明显不可能真正的同时去处理这1万个请求的吧！如果这台机器的处理器有4个核心，不考虑超线程，那么我们认为同时会有4个线程在跑。</p>
<p>也就是说，并发访问数是1万，而底层真实的并行处理的请求数是4。如果并发数小一些只有4的话，又或者你的机器牛逼有1万个核心，那并发在这里和并行一个效果。也就是说，并发可以是虚拟的同时执行，也可以是真的同时执行。而并行的意思是真的同时执行。</p>
<p><strong>并行执行的处理数量取决于当前系统的状态</strong>，即iOS和 OS X基于Dispatch Queue中的处理数、CPU核数以及CPU负荷等当前系统的状态来决定并行队列中并行执行的处理数。</p>
<h3 id="1-2-2-同步和异步"><a href="#1-2-2-同步和异步" class="headerlink" title="1.2.2 同步和异步"></a>1.2.2 同步和异步</h3><ul>
<li>同步：进程之间存在依赖关系，一个进程结束的输出作为另一个进程的输入。具有同步关系的一组并发进程之间发送的信息称为消息或者事件。</li>
<li>异步：和同步相对，同步是顺序执行，而异步是彼此独立，在等待某个事件的过程中继续做自己的事，不要等待这一事件完成后再工作。线程是实现异步的一个方式，异步是让调用方法的主线程不需要同步等待另一个线程的完成，从而让主线程干其他事情。</li>
</ul>
<p>更详细的可以看：<a href="https://tenloy.github.io/2021/04/20/Sync-Async.html">同步和异步解读及编程中的使用场景</a>。</p>
<h3 id="1-2-3-异步-≠-多线程"><a href="#1-2-3-异步-≠-多线程" class="headerlink" title="1.2.3 异步 ≠ 多线程"></a>1.2.3 异步 ≠ 多线程</h3><p>多线程：是进程中并发运行的一段代码，能够实现线程之间的切换执行。</p>
<p>异步：发送一个调用请求出去，不等待其结果的返回，直接去做其它的事情，等这个异步请求有结果了通知一下。</p>
<p>异步和多线程不是同等关系。<strong>异步是目的，多线程只是实现异步的一个手段</strong>。实现异步可以采用多线程技术或者交给其他进程来处理，或者参照JS的单线程模型，线程等同步代码执行完成，再执行异步的回调代码。</p>
<h2 id="1-3-上下文切换"><a href="#1-3-上下文切换" class="headerlink" title="1.3 上下文切换"></a>1.3 上下文切换</h2><blockquote>
<p>OS X 和 iOS 的核心XNU内核在发生操作系统事件时（如每隔一定时间，唤起系统调用等情况）会切换执行路径。执行中路径的状态，例如CPU的寄存器的信息保存到各自路径专用的内存块中，从切换目标路径专用的内存块中，复原CPU寄存器的信息，继续执行切换路径的CPU命令列，这被称为“上下文切换”。</p>
</blockquote>
<p>上下文切换是并行（单处理器中进程被交替执行，表现出并发外部特征）的核心关键。</p>
<p>单核中的多线程是并发，其实是顺序执行的，只不过CPU高速的切换，表面看起来像是并行。</p>
<p>多核中的多线程，在线程数小于 &lt; CPU核数时，是真正的并行。</p>
<p><strong>iOS和OS X的核心 — XNU内核决定应当使用的线程数，并只生成所需的线程执行处理，另外，当处理结束，应当执行的处理数减少时，XNU内核会结束不再需要的线程，XNU内核仅使用并行队列便可完美的管理并行执行处理的线程</strong>。</p>
<h2 id="1-4-多线程编程的优缺点"><a href="#1-4-多线程编程的优缺点" class="headerlink" title="1.4 多线程编程的优缺点"></a>1.4 多线程编程的优缺点</h2><ul>
<li><strong>优点：</strong>保证应用程序的响应性能</li>
<li><strong>缺点</strong>：是易发生各种问题，比如：数据竞争、死锁，而且使用太多线程会消耗大量内存，引起大量的上下文切换，大幅度降低系统的响应性能。</li>
</ul>
<h2 id="1-5-主线程"><a href="#1-5-主线程" class="headerlink" title="1.5 主线程"></a>1.5 主线程</h2><p>应用程序启动时。通过最先执行的线程，即<strong>主线程</strong>来描绘用户界面、处理触摸屏幕的事件，如果在该线程中进行长时间的处理，会造成主线程阻塞，会妨碍主线程中被称为RunLoop的主循环执行，从而导致不能更新用户界面、应用程序画面长时间停滞等问题。</p>
<p><strong>GCD大大简化了偏于复杂的多线程编程的源代码，与Block结合使用，只需要将要执行的任务并追加到适当的Dispatch Queue</strong>。</p>
<h1 id="二、GCD的概述及基础知识"><a href="#二、GCD的概述及基础知识" class="headerlink" title="二、GCD的概述及基础知识"></a>二、GCD的概述及基础知识</h1><p>Grand Central Dispatch(GCD)</p>
<ul>
<li>是Apple推出的一套多线程解决方案，它拥有系统级的线程管理机制，开发者不需要再管理线程的生命周期，只需要关注于要执行的任务即可。</li>
<li>是异步执行任务的技术之一，用非常简洁的技术方法，实现了极为复杂繁琐的多线程编程。</li>
</ul>
<p><strong>GCD 是在系统级即iOS和OS X的核心XNU内核级上实现，所以开发者无论如何努力编写线程关系代码，<code>性能</code>都不可能胜过XNU内核级所实现的GCD。</strong>开发者应该尽量多使用GCD或者使用了Cocoa框架GCD的NSOperationQueue类等API。</p>
<p>GCD的源码libdispatch版本很多，源代码风格各版本都有不同，但大体逻辑没有太大变化。libdispatch的源码下载地址<a target="_blank" rel="noopener" href="https://opensource.apple.com/tarballs/libdispatch/">在这里</a>。</p>
<p>阅读GCD的源码之前，先了解一些相关知识，方便后面的理解。</p>
<h2 id="2-1-DISPATCH-DECL"><a href="#2-1-DISPATCH-DECL" class="headerlink" title="2.1 DISPATCH_DECL"></a>2.1 DISPATCH_DECL</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_DECL(name) typedef struct name##_s *name##_t</span></span><br></pre></td></tr></table></figure>

<p>GCD中的变量大多使用了这个宏，比如<code>DISPATCH_DECL(dispatch_queue)</code>展开后是</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">dispatch_queue_t</span>；</span></span><br></pre></td></tr></table></figure>

<p>它的意思是定义一个<code>dispatch_queue_t</code>类型的指针，指向了一个<code>dispatch_queue_s</code>类型的结构体。</p>
<h2 id="2-2-fastpath-vs-slowpath"><a href="#2-2-fastpath-vs-slowpath" class="headerlink" title="2.2 fastpath vs slowpath"></a>2.2 fastpath vs slowpath</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fastpath(x) ((typeof(x))__builtin_expect((long)(x), ~0l))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> slowpath(x) ((typeof(x))__builtin_expect((long)(x), 0l))</span></span><br></pre></td></tr></table></figure>

<p><code>__builtin_expect</code>是编译器用来优化执行速度的函数，fastpath表示条件更可能成立，slowpath表示条件更不可能成立。我们在阅读源码的时候可以做忽略处理。</p>
<h2 id="2-3-TSD-TLS"><a href="#2-3-TSD-TLS" class="headerlink" title="2.3 TSD/TLS"></a>2.3 TSD/TLS</h2><blockquote>
<p><strong>如果一个变量需要在线程内部的各个函数调用都能访问、但其它线程不能访问</strong>，这就需要新的机制来实现，我们称之为Static memory local to a thread (线程局部静态变量)，同时也可称之为线程特有数据（TSD: Thread-Specific Data）或者线程本地存储（<strong>TLS: Thread-Local Storage</strong>）。这一类型的数据，在程序中每个线程都会分别维护一份变量的副本(copy)，并且长期存在于该线程中，对此类变量的操作不影响其他线程。</p>
</blockquote>
<p>在多线程中，会用全局变量来实现多个函数间的数据共享，局部变量来实现内部的单独访问。</p>
<p>TLS则是能够在同一个线程的不同函数中被访问，在不同线程时，相同的键值获取的数据随线程不同而不同。</p>
<p>Linux下支持两种方式定义和使用TLS变量，具体如下表：</p>
<table>
<thead>
<tr>
<th align="left">定义方式</th>
<th align="left">支持层次</th>
<th align="left">访问方式</th>
</tr>
</thead>
<tbody><tr>
<td align="left">__thread关键字</td>
<td align="left">语言层面</td>
<td align="left">与全局变量完全一样</td>
</tr>
<tr>
<td align="left">pthread_key_create函数</td>
<td align="left">运行库层面</td>
<td align="left">pthread_get_specific和pthread_set_specific对线程变量进行映射和读取(通过键值)</td>
</tr>
</tbody></table>
<p><strong>可以通过pthread的相关api来实现TSD</strong>:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_create</span><span class="params">(<span class="keyword">pthread_key_t</span> *, <span class="keyword">void</span> (* _Nullable)(<span class="keyword">void</span> *))</span></span>;</span><br><span class="line"><span class="comment">//删除key</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_key_delete</span><span class="params">(<span class="keyword">pthread_key_t</span> key)</span></span>;</span><br><span class="line"><span class="comment">//set方法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setspecific</span><span class="params">(<span class="keyword">pthread_key_t</span> , <span class="keyword">const</span> <span class="keyword">void</span> * _Nullable)</span></span>;</span><br><span class="line"><span class="comment">//get方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* _Nullable <span class="title">pthread_getspecific</span><span class="params">(<span class="keyword">pthread_key_t</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>__thread关键字</strong></p>
<p>在Linux中还有一种更为高效的线程局部存储方法，就是使用关键字<code>__thread</code>来定义变量。</p>
<p><code>__thread</code>是GCC内置的线程局部存储设施（Thread-Local Storage），它的实现非常高效，与pthread_key_t向比较更为快速，其存储性能可以与全局变量相媲美，而且使用方式也更为简单。</p>
<p>创建线程局部变量只需简单的在全局或者静态变量的声明中加入<code>__thread</code>说明即可。列如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __thread <span class="keyword">char</span> t_buf[<span class="number">32</span>] = &#123;<span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">extern</span> __thread <span class="keyword">int</span> t_val = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>凡是带有__thread的变量，每个线程都拥有该变量的一份拷贝，且互不干扰。线程局部存储中的变量将一直存在，直至线程终止，当线程终止时会自动释放这一存储。</p>
<h1 id="三、GCD的常用数据结构"><a href="#三、GCD的常用数据结构" class="headerlink" title="三、GCD的常用数据结构"></a>三、GCD的常用数据结构</h1><h2 id="3-1-dispatch-object-s结构体"><a href="#3-1-dispatch-object-s结构体" class="headerlink" title="3.1 dispatch_object_s结构体"></a>3.1 dispatch_object_s结构体</h2><p>dispatch_object_s是GCD最基础的结构体，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//GCD的基础结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_STRUCT_HEADER</span>(object);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//os object头部宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _OS_OBJECT_HEADER(isa, ref_cnt, xref_cnt) \</span></span><br><span class="line">        isa; <span class="comment">/* must be pointer-sized */</span> \  <span class="comment">//isa</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> ref_cnt; \             <span class="comment">//引用计数</span></span><br><span class="line">        <span class="keyword">int</span> <span class="keyword">volatile</span> xref_cnt               <span class="comment">//外部引用计数，两者都为0时释放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch结构体头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_STRUCT_HEADER(x) \</span></span><br><span class="line">    _OS_OBJECT_HEADER( \</span><br><span class="line">    <span class="keyword">const</span> struct dispatch_#<span class="meta">#x##_vtable_s *do_vtable, \  <span class="comment">//vtable结构体</span></span></span><br><span class="line">    do_ref_cnt, \</span><br><span class="line">    do_xref_cnt); \                            </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \   <span class="comment">//下一个do</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *<span class="title">do_targetq</span>;</span> \         <span class="comment">//目标队列</span></span><br><span class="line">    <span class="keyword">void</span> *do_ctxt; \                               <span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">void</span> *do_finalizer; \                          <span class="comment">//销毁时调用函数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> do_suspend_cnt;                   <span class="comment">//suspend计数，用作暂停标志</span></span><br></pre></td></tr></table></figure>

<h2 id="3-2-dispatch-continuation-s结构体"><a href="#3-2-dispatch-continuation-s结构体" class="headerlink" title="3.2 dispatch_continuation_s结构体"></a>3.2 dispatch_continuation_s结构体</h2><p>dispatch_continuation_s结构体主要封装block和function，<code>dispatch_async</code>中的block最终都会封装成这个数据类型，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_CONTINUATION_HEADER</span>(continuation);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//continuation结构体头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_CONTINUATION_HEADER(x) \</span></span><br><span class="line">    _OS_OBJECT_HEADER( \</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">void</span> *do_vtable, \                            </span><br><span class="line">      do_ref_cnt, \</span><br><span class="line">      do_xref_cnt); \                               <span class="comment">//_OS_OBJECT_HEADER定义</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_</span>##<span class="title">x</span>##_<span class="title">s</span> *<span class="title">volatile</span> <span class="title">do_next</span>;</span> \    <span class="comment">//下一个任务</span></span><br><span class="line">    <span class="keyword">dispatch_function_t</span> dc_func; \                  <span class="comment">//执行内容</span></span><br><span class="line">    <span class="keyword">void</span> *dc_ctxt; \                                <span class="comment">//上下文</span></span><br><span class="line">    <span class="keyword">void</span> *dc_data; \                                <span class="comment">//相关数据</span></span><br><span class="line">    <span class="keyword">void</span> *dc_other;                                 <span class="comment">//其他</span></span><br></pre></td></tr></table></figure>

<h2 id="3-3-dispatch-object-t联合体"><a href="#3-3-dispatch-object-t联合体" class="headerlink" title="3.3 dispatch_object_t联合体"></a>3.3 dispatch_object_t联合体</h2><p>dispatch_object_t是个union的联合体，可以用dispatch_object_t代表这个联合体里的所有数据结构。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">os_object_s</span> *_<span class="title">os_obj</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *_<span class="title">do</span>;</span>             <span class="comment">//object结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *_<span class="title">dc</span>;</span>       <span class="comment">//任务,dispatch_aync的block会封装成这个数据结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> *_<span class="title">dq</span>;</span>              <span class="comment">//队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_attr_s</span> *_<span class="title">dqa</span>;</span>        <span class="comment">//队列属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_group_s</span> *_<span class="title">dg</span>;</span>              <span class="comment">//群组操作</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_s</span> *_<span class="title">ds</span>;</span>             <span class="comment">//source结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_s</span> *_<span class="title">dm</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_mach_msg_s</span> *_<span class="title">dmsg</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_timer_aggregate_s</span> *_<span class="title">dta</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_source_attr_s</span> *_<span class="title">dsa</span>;</span>       <span class="comment">//source属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> *_<span class="title">dsema</span>;</span>       <span class="comment">//信号量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_data_s</span> *_<span class="title">ddata</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_io_s</span> *_<span class="title">dchannel</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_operation_s</span> *_<span class="title">doperation</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_disk_s</span> *_<span class="title">ddisk</span>;</span></span><br><span class="line">&#125; <span class="keyword">dispatch_object_t</span> __attribute__((__transparent_union__));</span><br></pre></td></tr></table></figure>

<h2 id="3-4-DISPATCH-VTABLE-HEADER宏"><a href="#3-4-DISPATCH-VTABLE-HEADER宏" class="headerlink" title="3.4 DISPATCH_VTABLE_HEADER宏"></a>3.4 DISPATCH_VTABLE_HEADER宏</h2><p>GCD中常见结构体（比如queue、semaphore等）的vtable字段中定义了很多函数回调，在后续代码分析中会经常看到，定义如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dispatch vtable的头部</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_VTABLE_HEADER(x) \</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> do_type; \     <span class="comment">//类型</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *<span class="keyword">const</span> do_kind; \       <span class="comment">//种类，比如:group/queue/semaphore</span></span><br><span class="line">    <span class="built_in">size_t</span> (*<span class="keyword">const</span> do_debug)(struct dispatch_#<span class="meta">#x##_s *, char *, size_t); \ <span class="comment">//debug用</span></span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*<span class="keyword">const</span> do_invoke)(struct dispatch_#<span class="meta">#x##_s *); \    <span class="comment">//invoke回调</span></span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="built_in"><span class="keyword">long</span></span> (*<span class="keyword">const</span> do_probe)(struct dispatch_#<span class="meta">#x##_s *); \   <span class="comment">//probe回调</span></span></span><br><span class="line">    <span class="built_in"><span class="keyword">void</span></span> (*<span class="keyword">const</span> do_dispose)(struct dispatch_#<span class="meta">#x##_s *);     <span class="comment">//dispose回调，销毁时调用</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//dx_xxx开头的宏定义，后续文章会用到，本质是调用vtable的do_xxx</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_type(x) (x)-&gt;do_vtable-&gt;do_type</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_metatype(x) ((x)-&gt;do_vtable-&gt;do_type &amp; _DISPATCH_META_TYPE_MASK)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_kind(x) (x)-&gt;do_vtable-&gt;do_kind</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_debug(x, y, z) (x)-&gt;do_vtable-&gt;do_debug((x), (y), (z))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_dispose(x) (x)-&gt;do_vtable-&gt;do_dispose(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_invoke(x) (x)-&gt;do_vtable-&gt;do_invoke(x)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dx_probe(x) (x)-&gt;do_vtable-&gt;do_probe(x)</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5-dispatch-queue-s-队列结构"><a href="#3-5-dispatch-queue-s-队列结构" class="headerlink" title="3.5 dispatch_queue_s(队列结构)"></a>3.5 dispatch_queue_s(队列结构)</h2><p>dispatch_queue_s是队列的结构体，也是GCD中开发者接触最多的结构体了，定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> &#123;</span></span><br><span class="line">    <span class="built_in">DISPATCH_STRUCT_HEADER</span>(queue);    <span class="comment">//基础header</span></span><br><span class="line">    DISPATCH_QUEUE_HEADER;            <span class="comment">//队列头部，见下面的定义</span></span><br><span class="line">    DISPATCH_QUEUE_CACHELINE_PADDING; <span class="comment">// for static queues only</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//队列自己的头部定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_QUEUE_HEADER \</span></span><br><span class="line">    <span class="keyword">uint32_t</span> <span class="keyword">volatile</span> dq_running; \                       <span class="comment">//队列运行的任务数量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_head</span>;</span> \   <span class="comment">//链表头部节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">volatile</span> <span class="title">dq_items_tail</span>;</span> \   <span class="comment">//链表尾部节点</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq_specific_q; \                     <span class="comment">//specific队列</span></span><br><span class="line">    <span class="keyword">uint32_t</span> dq_width; \                                  <span class="comment">//队列并发数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> dq_is_thread_bound:<span class="number">1</span>; \                  <span class="comment">//是否线程绑定</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> dq_serialnum; \                         <span class="comment">//队列的序列号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *dq_label; \                               <span class="comment">//队列名</span></span><br><span class="line">    DISPATCH_INTROSPECTION_QUEUE_LIST;</span><br></pre></td></tr></table></figure>

<p>队列的do_table中有很多函数指针，阅读queue的源码时会遇到dx_invoke或者dx_probe等函数，它们其实就是调用vtable中定义的函数。下面看一下相关定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//main-queue和普通queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_INSTANCE</span>(queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_queue_dispose,    <span class="comment">//销毁时调用</span></span><br><span class="line">    .do_invoke = _dispatch_queue_invoke,      <span class="comment">//invoke函数</span></span><br><span class="line">    .do_probe = _dispatch_queue_probe,        <span class="comment">//probe函数</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,         <span class="comment">//debug回调</span></span><br><span class="line">);</span><br><span class="line"><span class="comment">//global-queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_SUBCLASS_INSTANCE</span>(queue_root, queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_ROOT_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;global-queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_pthread_root_queue_dispose,  <span class="comment">//global-queue销毁时调用</span></span><br><span class="line">    .do_probe = _dispatch_root_queue_probe,              <span class="comment">//_dispatch_wakeup时会调用</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,                    <span class="comment">//debug回调</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h1 id="四、GCD的API"><a href="#四、GCD的API" class="headerlink" title="四、GCD的API"></a>四、GCD的API</h1><h2 id="4-1-Dispatch-Queue-调度队列"><a href="#4-1-Dispatch-Queue-调度队列" class="headerlink" title="4.1 Dispatch Queue(调度队列)"></a>4.1 Dispatch Queue(调度队列)</h2><h3 id="4-1-1-概述"><a href="#4-1-1-概述" class="headerlink" title="4.1.1 概述"></a>4.1.1 概述</h3><p><code>dispatch_queue</code>可以说是GCD编程中使用频率最高的API，这一节主要讲一下queue的相关用法和原理，关于queue的数据结构和常用定义见上节。</p>
<ul>
<li>Dispatch Queue按照追加的顺序（先进先出FIFO）执行处理</li>
<li>Dispatch Queue分两种：<ul>
<li>一种是等待现在执行中处理结束的 Serial Dispatch Queue(串行调度队列)</li>
<li>一种是不等待现在执行中处理结束的 Concurrent Dispatch Queue(并行调度队列)</li>
</ul>
</li>
<li>Dispatch Queue实例：<ul>
<li>库内置了两个队列：<ul>
<li>Main Dispatch Queue(串行队列)：追加到Main Dispatch Queue中的处理在主线程的RunLoop中执行</li>
<li>Global Dispatch Queue(并行队列)</li>
<li>对这两种队列执行 dispatch_retain 函数和 dispatch_release 函数无效，开发者无需关心这两者的保留、释放。</li>
</ul>
</li>
<li>也可以用 dispatch_queue_create 来创建串行、并行队列</li>
</ul>
</li>
</ul>
<h3 id="4-1-2-使用"><a href="#4-1-2-使用" class="headerlink" title="4.1.2 使用"></a>4.1.2 使用</h3><h4 id="1-dispatch-queue-create-串行与并行"><a href="#1-dispatch-queue-create-串行与并行" class="headerlink" title="1. dispatch_queue_create(串行与并行)"></a>1. dispatch_queue_create(串行与并行)</h4><p><code>dispatch_queue_create</code> 方法的文档注释：</p>
<ul>
<li>提交到串行队列的block按FIFO顺序一次执行一个。上一个block执行完开始取出下一个执行。</li>
<li>提交到并发队列的block按FIFO顺序出列，但如果资源可用，则可以同时运行。</li>
<li>但是请注意，<strong>提交到不同的、独立队列的block可以相对于彼此同时执行</strong>。<ul>
<li>【两个block通过dispatch_async提交到一个并行队列 基本等价于 两个block通过dispatch_sync提交到两个串行队列】（都是两个线程）</li>
<li>1个并行队列 + 多个异步任务(dispatch_async) = 会开启多线程</li>
<li>多个【1个串行队列+1个异步任务】 = 多线程</li>
</ul>
</li>
</ul>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 如果您的应用程序没有使用ARC，您应该在不再需要时在调度队列上调用 dispatch_release。任何提交到队列的未执行的block都持有对该队列的引用，因此在所有未执行的block完成之前不会释放队列。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @参数1 指定Dispatch Queue名称（推荐使用应用程序ID这种逆序全程域名，该名称便于Xcode和Instruments调试，会出现在CrashLog中）</span></span><br><span class="line"><span class="comment"> * @参数2 Serial Dispatch Queue指定为NULL；Concurrent Dispatch Queue指定为DISPATCH_QUEUE_CONCURRENT</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 为表示Dispatch Queue的&quot;dispatch_queue_t类型&quot;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dispatch_queue_t mySerialDispatchQueue = dispatch_queue_create (<span class="string">&quot;com.example.MySerialDispatchQueue&quot;</span> , <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">dispatch_async(queue, ^&#123;</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">dispatch_release(mySerialDispatchQueue)</span><br></pre></td></tr></table></figure>

<ul>
<li>dispatch_queue_t 类型变量，必须程序员自己负责释放，像OC的引用计数式内存管理一样，需要通过 <code>dispatch_retain</code> 函数和 <code>dispatch_release</code> 函数的引用计数来管理内存。</li>
<li>在 <code>dispatch_async</code>、<code>diapatch_sync</code> 函数中追加 Block 到 Dispatch Queue（该 Block 通过 dispatch_retain 函数持有 Dispatch Queue）。</li>
<li>一旦 Block 执行结束，就要通过 dispatch_release 函数函数释放该 Block 持有的 Dispatch Queue。</li>
</ul>
<p><strong>释放时机：</strong></p>
<ul>
<li>在 dispatch_async 函数中追加 Block 到 Dispatch Queue 后，即是立刻释放 Dispatch Queue，该 Dispatch Queue 由于被 Block 持有也不会废弃，因而 Block 能够执行，Block 执行结束后释放该 Block 持有的 Dispatch Queue，这时谁都不持有 Dispatch Queue，因此它被废弃。</li>
<li>在通过函数或方法名获取 Dispatch Queue 以及其他名称中包含 <code>creat</code> 的API生成的对象时，有必要通过 dispatch_retain 函数持有，并在不需要时通过 dispatch_release 函数释放。</li>
</ul>
<p>系统对于一个串行队列，就只生成并使用一个线程，所以串行队列的生成个数应当仅限所必需的数量，不能大量生成。</p>
<p>对于并行队列，不管生成多少，由于XNU内核<strong>只使用有效管理的线程</strong>，不会出现串行队列那种问题。</p>
<h4 id="2-dispatch-async与dispatch-sync-同步与异步"><a href="#2-dispatch-async与dispatch-sync-同步与异步" class="headerlink" title="2. dispatch_async与dispatch_sync(同步与异步)"></a>2. dispatch_async与dispatch_sync(同步与异步)</h4><p>并发和串行作为队列的属性，主要影响：任务的执行方式。</p>
<ul>
<li>并发：多个任务并发(同时)执行</li>
<li>串行：一个任务执行完毕后，再执行下一个任务。</li>
</ul>
<p>同步和异步作为任务的属性，主要影响：是否阻塞当前线程下面代码的执行。 </p>
<ul>
<li>同步：将block提交到队列，并执行完毕后，继续往下执行。</li>
<li>异步：将block提交到队列后，立即返回。执行下面的代码。</li>
</ul>
<p>有的文章中说 <code>dispatch_sync</code> 与 <code>dispatch_async</code> 的区别在于会不会开辟新的线程，个人感觉是有些问题的。</p>
<ul>
<li>前者的文档中只说<strong>尽可能</strong>在当前线程中执行。</li>
<li>后者与并行队列组合时，如果线程数已经超过64，也是不会继续创建新线程的，而是会等待线程资源的释放。</li>
<li>见下面<a href="">4.1.3-4小节</a>。</li>
</ul>
<p>当我们处理耗时操作时，比如读取数据库、请求网络数据，为了避免这些耗时操作卡住UI，可将耗时任务放到子线程中，执行完成后再通知主线程更新UI。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  Submits a block for asynchronous execution on a dispatch queue and returns immediately.</span></span><br><span class="line"><span class="comment">  在分派队列上提交一个用于异步执行的块，然后立即返回。如果不是主队列就会开启新的线程，但不管开启不开启，都是马上返回的，不会阻塞！</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> queue, <span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  dispatch_sync：Submits a block object for execution and returns after that block finishes executing.</span></span><br><span class="line"><span class="comment">  将一个block提交到指定的调度队列以同步执行。block执行完毕，dispatch_sync函数才return。</span></span><br><span class="line"><span class="comment">     与dispatch_async不同：</span></span><br><span class="line"><span class="comment">       1. 此函数在block完成之前不会返回。【阻塞在此，block执行完才能再往下走】</span></span><br><span class="line"><span class="comment">       2. 目标队列不执行retain。因为对该函数的调用是同步的，所以它“借用”了调用者的引用。此外，不会对block执行 Block_copy。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync</span><span class="params">(<span class="keyword">dispatch_queue_t</span> queue, DISPATCH_NOESCAPE <span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>dispatch_sync</code> 函数：</p>
<ul>
<li>调用此函数时，如果以当前所在的<strong>串行队列</strong>为目标会<strong>【导致死锁】</strong>！！</li>
<li>作为性能优化，此函数<strong>【尽可能在当前线程上】</strong>执行块。但有一个例外：提交到主调度队列的块总是在主线程上运行。</li>
</ul>
<p>代码示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">    <span class="comment">//耗时操作</span></span><br><span class="line">    <span class="built_in">dispatch_async</span>(<span class="built_in">dispatch_get_main_queue</span>(), ^&#123;</span><br><span class="line">         <span class="comment">//更新UI</span></span><br><span class="line">    &#125;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="3-GCD-NSOperation设置优先级"><a href="#3-GCD-NSOperation设置优先级" class="headerlink" title="3. GCD/NSOperation设置优先级"></a>3. GCD/NSOperation设置优先级</h4><p>GCD 和 NSOperation 的优先级设置：</p>
<ul>
<li>NSThread 可以指定线程的优先级：iOS8之前是threadPriority，之后是qualityOfService。较高优先级不保证你的线程具体执行的时间，只是相比较低优先级的线程，它更有可能被调度器选择执⾏而已。 （<em>read-only after the thread is started</em>）</li>
<li>GCD 可以指定队列优先级：（以下两者指定优先级时，使用的值不一样，有映射关系）。<ul>
<li><code>dispatch_queue_create</code> 创建队列时，指定优先级。</li>
<li><code>dispatch_get_global_queue</code> 获取全局并行队列时，指定优先级。</li>
</ul>
</li>
<li>NSOperation 可以设置 operation 的 qualityOfService 属性；</li>
<li>NSOperationQueue 可以设置 队列 的 qualityOfService 属性。指定了添加到该队列的 operation 对象的服务质量级别。如果 operation 显式设置过自身的 qualityOfService，则优先使用后者。</li>
</ul>
<p><em>（个人认为：队列、任务、线程的优先级可以理解为一个东西，都是在控制线程的优先级）</em></p>
<p>通过XNU内核用于 global_queue 的线程并<strong>不能保证实时性</strong>，所以优先级只是个大致判断。</p>
<p><strong>XNU内核管理，会将各自使用的队列的执行优先级，作为线程的执行优先级使用，所以添加任务时，需要选择与处理的任务对应优先级的队列。</strong></p>
<h4 id="4-dispatch-set-target-queue"><a href="#4-dispatch-set-target-queue" class="headerlink" title="4. dispatch_set_target_queue"></a>4. dispatch_set_target_queue</h4><p>dispatch_queue_create函数生成的队列，生成的线程优先级为 Global Dispatch Queue 的默认优先级。</p>
<p>变更生成的Dispatch Queue的执行优先级要使用dispatch_set_target_queue函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> mySerialDispatchQueue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.example.gcd.MySerialDispatchQueue&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">dispatch_queue_t</span> globalDispatchQueueBackground = <span class="built_in">dispatch_get_global_queue</span>(DISPATCH_PRIORITY_BACKGROUND ,<span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 指定要变更执行优先级的Dispatch Queue为dispatch_set_target_queue函数的第一个参数</span></span><br><span class="line"><span class="comment"> * 指定与要使用的执行优先级相同优先级的Dispatch Queue为第二个参数（目标）</span></span><br><span class="line"><span class="comment"> * Main Dispatch Queue和Global Dispatch Queue不可指定为第一个参数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">dispatch_set_target_queue</span>(mySerialDispatchQueue, globalDispatchQueueBackground);</span><br></pre></td></tr></table></figure>

<p>用途：</p>
<ul>
<li>变更执行优先级</li>
<li>目标队列会变成第一个参数队列中任务的执行阶层<ul>
<li>多个 Serial Dispatch Queue 中用 dispatch_set_target_queue 函数指定目标为某一个 Serial Dispatch Queue，那么原先本应并行执行的多个 Serial Dispatch Queue，在目标 Serial Dispatch Queue 上只能同时执行一个处理（可防止 Serial Dispatch Queue 处理并行执行）</li>
<li>使多个serial队列变并行为串行</li>
</ul>
</li>
</ul>
<h3 id="4-1-3-实现-—-Root-Queue-与-线程池"><a href="#4-1-3-实现-—-Root-Queue-与-线程池" class="headerlink" title="4.1.3 实现 — Root Queue 与 线程池"></a>4.1.3 实现 — Root Queue 与 线程池</h3><h4 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h4><p>在GCD和NSOperationQueue之前，iOS使用线程一般是用NSThread，而NSThread是对<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/POSIX_Threads">POSIX thread</a>的封装，也就是pthread，本文最后会面附上一段使用pthread下图片的代码，现在我们还是继续上面的讨论。使用NSThread的一个最大的问题是：直接操纵线程，线程的生命周期完全交给developer控制，在大的工程中，模块间相互独立，假如A模块并发了8条线程，B模块需要并发6条线程，以此类推，线程数量会持续增长，最终会导致难以控制的结果。</p>
<p>GCD和NSOperationQueue出来以后，可以很方便地实现多线程，而不需要过多地关注线程的实现和创建等。GCD内部维护了一个线程池，由系统根据任务的数量和优先级动态地创建和分配线程执行。线程池会有效管理线程的并发，控制线程的生命周期。</p>
<p>developer可以不直接操纵线程，而是将所要执行的任务封装成一个unit丢给线程池去处理。</p>
<p>GCD是一种轻量的基于block的线程模型，使用GCD一般要注意两点：一是线程的priority，二是对象间的循环引用问题。</p>
<p>NSOperationQueue是对GCD更上一层的封装，它对线程的控制更好一些，但是用起来也麻烦一些。关于这两个孰优熟劣，需要根据具体应用场景进行讨论：<a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/10373331/nsoperation-vs-grand-central-dispatch">stackoverflow:GCD vs NSopeartionQueue</a>（NSopeartionQueue设置最大并发数、设置任务之间的依赖比较方便）。</p>
<p>下面是 objc.io上的一幅图，直观地描述GCD队列和线程的关系：</p>
<blockquote>
<p>Thread Pool 具体细节，可以看GCD的源码，开源的嘛</p>
</blockquote>
<img src="/images/GCD/dispatch_queue-2.png" alt="img" style="zoom:80%;" />

<h4 id="2-GCD的16个root-queue"><a href="#2-GCD的16个root-queue" class="headerlink" title="2. GCD的16个root queue"></a>2. GCD的16个root queue</h4><p>首先，根据优先级、overcommit定义了12个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从_dispatch_root_queues数组中获取对应优先级的队列。</span></span><br><span class="line"><span class="comment"> * _dispatch_root_queues数组中总共存放了12个root队列，优先级6种 × overcommit(过载)2种</span></span><br><span class="line"><span class="comment"> * 支持overcommit的队列在创建队列时无论系统是否有足够的资源都会重新开一个线程，非overcommit队列创建队列则未必创建线程。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment">   #define DISPATCH_QOS_MAINTENANCE        ((dispatch_qos_t)1) //优先级最低(维护线程)</span></span><br><span class="line"><span class="comment">   #define DISPATCH_QOS_BACKGROUND         ((dispatch_qos_t)2) //     后台</span></span><br><span class="line"><span class="comment">   #define DISPATCH_QOS_UTILITY            ((dispatch_qos_t)3) //     实用/多功能的</span></span><br><span class="line"><span class="comment">   #define DISPATCH_QOS_DEFAULT            ((dispatch_qos_t)4) //     默认</span></span><br><span class="line"><span class="comment">   #define DISPATCH_QOS_USER_INITIATED     ((dispatch_qos_t)5) //     用户发起</span></span><br><span class="line"><span class="comment">   #define DISPATCH_QOS_USER_INTERACTIVE   ((dispatch_qos_t)6) //优先级最高(用户交互)</span></span><br><span class="line"><span class="comment">   #define DISPATCH_QOS_MIN                DISPATCH_QOS_MAINTENANCE</span></span><br><span class="line"><span class="comment">   #define DISPATCH_QOS_MAX                DISPATCH_QOS_USER_INTERACTIVE</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_global_s</span> *<span class="title">dispatch_queue_global_t</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">dispatch_queue_global_t</span> _dispatch_get_root_queue(<span class="keyword">dispatch_qos_t</span> qos, <span class="keyword">bool</span> overcommit)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">unlikely</span>(qos &lt; DISPATCH_QOS_MIN || qos &gt; DISPATCH_QOS_MAX)) &#123;</span><br><span class="line">		<span class="built_in">DISPATCH_CLIENT_CRASH</span>(qos, <span class="string">&quot;Corrupted priority&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> &amp;_dispatch_root_queues[<span class="number">2</span> * (qos - <span class="number">1</span>) + overcommit];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_global_s</span> _<span class="title">dispatch_root_queues</span>[] =</span> &#123;</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.maintenance-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">4</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(MAINTENANCE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.maintenance-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">5</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.background-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">6</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(BACKGROUND, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.background-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">7</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.utility-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">8</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(UTILITY, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.utility-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">9</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT, DISPATCH_PRIORITY_FLAG_FALLBACK,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.default-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">10</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(DEFAULT,</span><br><span class="line">			DISPATCH_PRIORITY_FLAG_FALLBACK | DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.default-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">11</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">12</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INITIATED, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-initiated-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">13</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, <span class="number">0</span>,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">14</span>,</span><br><span class="line">	),</span><br><span class="line">	_DISPATCH_ROOT_QUEUE_ENTRY(USER_INTERACTIVE, DISPATCH_PRIORITY_FLAG_OVERCOMMIT,</span><br><span class="line">		.dq_label = <span class="string">&quot;com.apple.root.user-interactive-qos.overcommit&quot;</span>,</span><br><span class="line">		.dq_serialnum = <span class="number">15</span>,</span><br><span class="line">	),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>此外，还有三个特殊的队列：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> dispatch_queue_static_s _dispatch_main_q = &#123;</span><br><span class="line">	.dq_label = <span class="string">&quot;com.apple.main-thread&quot;</span>,</span><br><span class="line">	.dq_serialnum = <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dispatch_queue_global_s _dispatch_mgr_root_queue = &#123;</span><br><span class="line">	.dq_label = <span class="string">&quot;com.apple.root.libdispatch-manager&quot;</span>,</span><br><span class="line">	.dq_serialnum = <span class="number">3</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> dispatch_queue_static_s _dispatch_mgr_q = &#123;</span><br><span class="line">	.dq_label = <span class="string">&quot;com.apple.libdispatch-manager&quot;</span>,</span><br><span class="line">	.dq_serialnum = <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们平时用到的全局队列也是其中一个root队列。见下面的<code>dispatch_get_global_queue</code> 源码。</p>
<p><strong>不管是自定义队列、全局队列还是主队列最终都直接或者间接的依赖12个root队列来执行任务调度</strong>。如果按照label算，应该有16个：</p>
<ul>
<li><code>_dispatch_root_queues</code> 数组初始化中的12个label；</li>
<li>主队列有自己的label <code>com.apple.main-thread</code>；</li>
<li>两个内部管理队列 <code>com.apple.libdispatch-manager</code> 和 <code>com.apple.root.libdispatch-manager</code>；</li>
<li>runloop的运行队列。</li>
</ul>
<h4 id="3-Queue设定的线程池的数量"><a href="#3-Queue设定的线程池的数量" class="headerlink" title="3. Queue设定的线程池的数量"></a>3. Queue设定的线程池的数量</h4><p><code>_dispatch_root_queues </code>取出的 <code>dispatch_queue_global_s</code> 队列的 <code>dgq_thread_pool_size</code> 字段表示queue的线程池，每个线程池的最大线程数限制是255。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_WORKQ_MAX_PTHREAD_COUNT 255</span></span><br></pre></td></tr></table></figure>

<p>最大线程数设置255，但实际程序中开辟的线程数，不一定能达到这个最大值。</p>
<p>官方文档 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW7">Thread Management</a> 中，辅助线程为512KB，辅助线程允许的最小堆栈大小为16KB，并且堆栈大小必须是4KB的倍数。</p>
<p>针对一个<code>4GB</code>内存的<code>iOS</code>真机来说，内存分为内核态和用户态。程序启动，系统给出的虚拟内存4GB，用户态占3GB，内核态占1GB。但内核态的1GB并不能全部用来开辟线程，所以最大线程数是未知的。如果内核态全部用于创建线程，也就是<code>1GB</code>的空间，也就是说最多能开辟 <code>1024MB / 16KB</code>个线程。当然这也只是一个理论值。</p>
<h4 id="4-队列与线程之间的关系"><a href="#4-队列与线程之间的关系" class="headerlink" title="4. 队列与线程之间的关系"></a>4. 队列与线程之间的关系</h4><p>再次重申：</p>
<ul>
<li>overcommit的队列在队列创建时会新建一个线程，非overcommit队列创建队列则未必创建线程。</li>
<li>另外，width=1意味着是串行队列，只有一个线程可用，width=0xffe则意味着并行队列，线程则是从线程池获取。</li>
</ul>
<p><em>测试现象：</em></p>
<ul>
<li>全局队列是非overcommit的。</li>
<li>主队列是overcommit的com.apple.root.default-qos.overcommit，不过它是串行队列，width=1，并且运行的这个线程只能是主线程。</li>
<li>自定义串行队列是overcommit的，默认优先级则是 com.apple.root.default-qos.overcommit。<strong>创建串行队列肯定会创建1个新的线程</strong>。<ul>
<li>最多可以创建512个，明显已经是灾难性的了，所以，<strong>串行队列是开发中应该注意的</strong>。【测试代码2，线程号是3-514】</li>
</ul>
</li>
<li>自定义并行队列则是非overcommit的。<ul>
<li><strong>创建并行队列不一定会新建线程，会从线程池中的64个线程中获取并使用。</strong> 【测试代码3，线程号是3-66】</li>
<li>如果64个线程都在使用中，那么如果再调用需要【申请新的子线程资源】的API，那么会<strong>进行等待状态，直到有可用子线程</strong>。【测试代码4，注意如果64个线程一直得不到释放，那么会发生死等】</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 测试1：使用一个串行队列，那始终只会在一个线程上执行</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">- (<span class="keyword">void</span>)test2 &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_attr_t</span> attr = <span class="built_in">dispatch_queue_attr_make_with_qos_class</span>(DISPATCH_QUEUE_SERIAL, QOS_CLASS_USER_INITIATED, <span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> serialQueue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.cmjstudio.dispatch&quot;</span>, attr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;%@，%i&quot;</span>,[NSThread currentThread],i); <span class="comment">// 只有一个线程，线程num &gt; 2 （3~66）</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 测试2：创建多个串行队列肯定会创建多个新的线程</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">- (<span class="keyword">void</span>)test1 &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">dispatch_queue_t</span> serialQueue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.cmjstudio.dispatch-%d&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">        <span class="built_in">dispatch_async</span>(serialQueue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;%d, %@&quot;</span>, i, [NSThread currentThread]);</span><br><span class="line">            [NSThread sleepForTimeInterval:<span class="number">30</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 15:30:12.822417: LOG: 3, &lt;NSThread: 0x282ce6240&gt;&#123;number = 3, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 15:30:12.858744: LOG: 641, &lt;NSThread: 0x282cd85c0&gt;&#123;number = 514, name = (null)&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 测试3：不管优先级多高并行队列有最多有64个线程，线程num在3~66，在一次轮询中遇到高优先级的会先执行</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">- (<span class="keyword">void</span>)test3 &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> concurrentQueue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.cmjstudio.dispatch&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">1000</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;%@，%i&quot;</span>,[NSThread currentThread],i); <span class="comment">// 64 thread (num = 3~66)</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 测试4：如果64个线程都在使用中，那再次调用申请新线程的API，会进入等待。如果64个线程一直不释放，就会死等。</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line">- (<span class="keyword">void</span>)test4 &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> concurrentQueue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.cmjstudio.dispatch&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=<span class="number">65</span>; ++i) &#123;</span><br><span class="line">        <span class="built_in">dispatch_async</span>(concurrentQueue, ^&#123;</span><br><span class="line">            <span class="built_in">NSLog</span>(@<span class="string">&quot;%d, %@&quot;</span>, i, [NSThread currentThread]);</span><br><span class="line">            [NSThread sleepForTimeInterval:<span class="number">3</span>];</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 15:14:33.153114: LOG: 60, &lt;NSThread: 0x282a733c0&gt;&#123;number = 62, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 15:14:33.153165: LOG: 61, &lt;NSThread: 0x282a74100&gt;&#123;number = 63, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 15:14:33.153190: LOG: 62, &lt;NSThread: 0x282a73780&gt;&#123;number = 64, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 15:14:33.153266: LOG: 63, &lt;NSThread: 0x282a75e80&gt;&#123;number = 65, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 15:14:33.153311: LOG: 64, &lt;NSThread: 0x282a73c00&gt;&#123;number = 66, name = (null)&#125;</span></span><br><span class="line"><span class="comment">// 等待了3秒</span></span><br><span class="line"><span class="comment">// 15:14:36.154120: LOG: 65, &lt;NSThread: 0x282a06e00&gt;&#123;number = 5, name = (null)&#125;</span></span><br></pre></td></tr></table></figure>

<p>GCD线程池中，线程数是64个。但有时候会超出64，<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/7213845/number-of-threads-created-by-gcd">StackOverflow</a>上的解释是实际线程数 = 64（最大 GCD 线程池大小）+ 主线程 + 一些其他随机非 GCD 线程。</p>
<ul>
<li>参考链接：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/kenshincui/p/13272517.html">iOS刨根问底-深入理解GCD</a></li>
</ul>
<h3 id="4-1-4-实现-—-相关API的源码逻辑"><a href="#4-1-4-实现-—-相关API的源码逻辑" class="headerlink" title="4.1.4 实现 — 相关API的源码逻辑"></a>4.1.4 实现 — 相关API的源码逻辑</h3><h4 id="1-dispatch-get-global-queue-8种类型"><a href="#1-dispatch-get-global-queue-8种类型" class="headerlink" title="1. dispatch_get_global_queue(8种类型)"></a>1. dispatch_get_global_queue(8种类型)</h4><p>dispatch_get_global_queue用于获取一个全局队列，先看一下它的源码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 常见的全局队列类型有8种：下面四种优先级以及对应的是否overcommit.</span></span><br><span class="line"><span class="comment"> * The global concurrent queues may still be identified by their priority,</span></span><br><span class="line"><span class="comment"> * which map to the following QOS classes:</span></span><br><span class="line"><span class="comment">                                            QOS_CLASS_USER_INTERACTIVE</span></span><br><span class="line"><span class="comment"> *  - DISPATCH_QUEUE_PRIORITY_HIGH:         QOS_CLASS_USER_INITIATED</span></span><br><span class="line"><span class="comment"> *  - DISPATCH_QUEUE_PRIORITY_DEFAULT:      QOS_CLASS_DEFAULT</span></span><br><span class="line"><span class="comment"> *  - DISPATCH_QUEUE_PRIORITY_LOW:          QOS_CLASS_UTILITY</span></span><br><span class="line"><span class="comment"> *  - DISPATCH_QUEUE_PRIORITY_BACKGROUND:   QOS_CLASS_BACKGROUND</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_queue_global_t</span> <span class="title">dispatch_get_global_queue</span><span class="params">(<span class="keyword">intptr_t</span> priority, <span class="keyword">uintptr_t</span> flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(<span class="built_in">countof</span>(_dispatch_root_queues) == DISPATCH_ROOT_QUEUE_COUNT);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (flags &amp; ~(<span class="keyword">unsigned</span> <span class="keyword">long</span>)DISPATCH_QUEUE_OVERCOMMIT) &#123;</span><br><span class="line">      <span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dispatch_qos_t</span> qos = _dispatch_qos_from_queue_priority(priority);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> !HAVE_PTHREAD_WORKQUEUE_QOS</span></span><br><span class="line">    <span class="keyword">if</span> (qos == QOS_CLASS_MAINTENANCE) &#123;</span><br><span class="line">      qos = DISPATCH_QOS_BACKGROUND;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (qos == QOS_CLASS_USER_INTERACTIVE) &#123;</span><br><span class="line">      qos = DISPATCH_QOS_USER_INITIATED;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="keyword">if</span> (qos == DISPATCH_QOS_UNSPECIFIED) &#123;</span><br><span class="line">      <span class="keyword">return</span> DISPATCH_BAD_INPUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//封装调用_dispatch_get_root_queue函数</span></span><br><span class="line">    <span class="keyword">return</span> _dispatch_get_root_queue(qos, flags &amp; DISPATCH_QUEUE_OVERCOMMIT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面看一下global queue的do_vtable结构体，它比较重要的是do_probe的调用函数<code>_dispatch_root_queue_probe</code>，这个函数在后续的分析中会用到。结构体定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//global queue的vtable定义</span></span><br><span class="line"><span class="built_in">DISPATCH_VTABLE_SUBCLASS_INSTANCE</span>(queue_root, queue,</span><br><span class="line">    .do_type = DISPATCH_QUEUE_ROOT_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;global-queue&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_pthread_root_queue_dispose, <span class="comment">//销毁时调用</span></span><br><span class="line">    .do_probe = _dispatch_root_queue_probe,             <span class="comment">//重要，唤醒队列时调用</span></span><br><span class="line">    .do_debug = dispatch_queue_debug,                   <span class="comment">//debug回调</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="2-dispatch-get-main-queue"><a href="#2-dispatch-get-main-queue" class="headerlink" title="2. dispatch_get_main_queue"></a>2. dispatch_get_main_queue</h4><p>该API的使用主要是在更新UI时获取<code>dispatch_get_main_queue()</code>并把任务提交到主队列中。它的源码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//宏定义，返回到是_dispatch_main_q</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> dispatch_get_main_queue() \</span></span><br><span class="line">        <span class="built_in">DISPATCH_GLOBAL_OBJECT</span>(<span class="keyword">dispatch_queue_t</span>, _dispatch_main_q)</span><br><span class="line"></span><br><span class="line"><span class="comment">//main_queue结构体定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_queue_s</span> _<span class="title">dispatch_main_q</span> =</span> &#123;</span><br><span class="line">    .do_vtable = <span class="built_in">DISPATCH_VTABLE</span>(queue),</span><br><span class="line">    .do_targetq = &amp;_dispatch_root_queues[DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY],  <span class="comment">//目标队列</span></span><br><span class="line">    .do_ref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,   </span><br><span class="line">    .do_xref_cnt = DISPATCH_OBJECT_GLOBAL_REFCNT,  </span><br><span class="line">    .do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_LOCK,</span><br><span class="line">    .dq_label = <span class="string">&quot;com.apple.main-thread&quot;</span>,   <span class="comment">//队列名</span></span><br><span class="line">    .dq_running = <span class="number">1</span>,          </span><br><span class="line">    .dq_width = <span class="number">1</span>,            <span class="comment">//最大并发数是1，串行队列</span></span><br><span class="line">    .dq_is_thread_bound = <span class="number">1</span>,  <span class="comment">//线程绑定</span></span><br><span class="line">    .dq_serialnum = <span class="number">1</span>,        <span class="comment">//序列号为1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>main queue设置了并发数为1，即串行队列，并且将targetq指向com.apple.root.default-overcommit-priority队列。</p>
<h4 id="3-dispatch-queue-create"><a href="#3-dispatch-queue-create" class="headerlink" title="3. dispatch_queue_create"></a>3. dispatch_queue_create</h4><p><code>dispatch_queue_create</code>主要用来创建自定义的队列，流程图和源码如下：</p>
<img src="/images/GCD/dispatch_queue-1.png" alt="img" style="zoom:80%;" />

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param attr 除了预定义的DISPATCH_QUEUE_SERIAL、DISPATCH_QUEUE_CONCURRENT。也可以自定义 dispatch_queue_attr_t 变量传入。</span></span><br><span class="line"><span class="comment">    dispatch_queue_attr_make_initially_inactive  队列配置为最初不活动，直到调用其dispatch_activate方法时才执行任务。</span></span><br><span class="line"><span class="comment">    dispatch_queue_attr_make_with_autorelease_frequency 指定队列如何为其执行的blocks管理自动释放池。</span></span><br><span class="line"><span class="comment">    dispatch_queue_attr_make_with_qos_class 指定quality-of-service服务质量(优先级)</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * 使用示例：</span></span><br><span class="line"><span class="comment"> *     dispatch_queue_attr_t serialAttr = dispatch_queue_attr_make_with_qos_class(</span></span><br><span class="line"><span class="comment">                                              DISPATCH_QUEUE_SERIAL,       // DISPATCH_QUEUE_SERIAL(串行)或DISPATCH_QUEUE_CONCURRENT(并行)</span></span><br><span class="line"><span class="comment">                                              QOS_CLASS_USER_INTERACTIVE,  // 服务质量有助于确定给予队列执行的任务的优先级。(见下面的QOS类)</span></span><br><span class="line"><span class="comment">                                              -1);                         // 相对优先级，值为[-15,0), 同一个服务质量的队列们中，也得有个相对的优先级</span></span><br><span class="line"><span class="comment"> *     dispatch_queue_t userInteractiveQueue = dispatch_queue_create(&quot;com.xy.interactive.serialQueue&quot;, serialAttr);</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_queue_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label, <span class="keyword">dispatch_queue_attr_t</span> attr)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用dispatch_queue_create_with_target</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dispatch_queue_create_with_target</span>(label, attr, DISPATCH_TARGET_QUEUE_DEFAULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//dispatch_queue_create具体实现函数</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_queue_t</span> <span class="title">dispatch_queue_create_with_target</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *label,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                   <span class="keyword">dispatch_queue_attr_t</span> attr, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                   <span class="keyword">dispatch_queue_t</span> tq)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq;</span><br><span class="line">   <span class="comment">//申请内存空间</span></span><br><span class="line">    dq = _dispatch_alloc(<span class="built_in">DISPATCH_VTABLE</span>(queue),</span><br><span class="line">                         <span class="built_in"><span class="keyword">sizeof</span></span>(struct dispatch_queue_s) - DISPATCH_QUEUE_CACHELINE_PAD);</span><br><span class="line">  <span class="comment">//初始化，设置自定义队列的基本属性，方法实现见下面</span></span><br><span class="line">    _dispatch_queue_init(dq);</span><br><span class="line">    <span class="keyword">if</span> (label) &#123;</span><br><span class="line">       <span class="comment">//设置队列名</span></span><br><span class="line">        dq-&gt;dq_label = <span class="built_in">strdup</span>(label);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (attr == DISPATCH_QUEUE_CONCURRENT) &#123;</span><br><span class="line">       <span class="comment">//并行队列设置dq_width为UINT32_MAX</span></span><br><span class="line">        dq-&gt;dq_width = UINT32_MAX;</span><br><span class="line">        <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">           <span class="comment">//默认targetq，优先级为DISPATCH_QUEUE_PRIORITY_DEFAULT</span></span><br><span class="line">            tq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!tq) &#123;</span><br><span class="line">           <span class="comment">//默认targetq，优先级为DISPATCH_ROOT_QUEUE_IDX_DEFAULT_OVERCOMMIT_PRIORITY</span></span><br><span class="line">            <span class="comment">// Default target queue is overcommit!</span></span><br><span class="line">            tq = _dispatch_get_root_queue(<span class="number">0</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置自定义队列的目标队列，dq队列的任务会放到目标队列执行</span></span><br><span class="line">    dq-&gt;do_targetq = tq;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_introspection_queue_create(dq);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列初始化方法</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_init(<span class="keyword">dispatch_queue_t</span> dq)</span><br><span class="line">&#123;</span><br><span class="line">    dq-&gt;do_next = (struct dispatch_queue_s *)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dq-&gt;dq_running = <span class="number">0</span>;      <span class="comment">//队列当前运行时初始为0</span></span><br><span class="line">    dq-&gt;dq_width = <span class="number">1</span>;        <span class="comment">//队列并发数默认为1，串行队列</span></span><br><span class="line">    dq-&gt;dq_serialnum = <span class="built_in">dispatch_atomic_inc_orig</span>(&amp;_dispatch_queue_serial_numbers, relaxed);   <span class="comment">//序列号,在_dispatch_queue_serial_numbers基础上原子性加1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码介绍了自定义队列是如何创建的，初始化时会将dq_width默认设置为1，即串行队列。如果外部设置attr为DISPATCH_QUEUE_CONCURRENT，将并发数改为UINT32_MAX；</p>
<p>自定义队列的serialnum是在_dispatch_queue_serial_numbers基础上原子性加一，即从12开始累加。1到11被保留的序列号定义如下（后续版本有改动，自定义序列从16开始累加）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// skip zero        //跳过0</span></span><br><span class="line"><span class="comment">// 1 - main_q       //主队列</span></span><br><span class="line"><span class="comment">// 2 - mgr_q        //管理队列</span></span><br><span class="line"><span class="comment">// 3 - mgr_root_q   //管理队列的目标队列</span></span><br><span class="line"><span class="comment">// 4,5,6,7,8,9,10,11 - global queues   //全局队列</span></span><br><span class="line"><span class="comment">// we use &#x27;xadd&#x27; on Intel, so the initial value == next assigned</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">volatile</span> _dispatch_queue_serial_numbers = <span class="number">12</span>;</span><br></pre></td></tr></table></figure>

<p>同时还会设置队列的target_queue，向队列提交的任务，都会被放到它的目标队列来执行。串行队列的target_queue是一个支持overcommit的root队列。</p>
<h4 id="4-dispatch-async"><a href="#4-dispatch-async" class="headerlink" title="4. dispatch_async"></a>4. dispatch_async</h4><p><code>dispatch_async</code>用来异步执行任务，它的代码比较复杂，我们可以分成三个阶段来看，第一阶段是更新队列链表，第二部分是从队列取任务，第三部分则是执行任务。每个阶段都有一张流程图表示，觉得代码多的话可以直接看每个阶段对应的流程图。</p>
<p>首先看一下<code>dispatch_async</code>的入口函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> (^work)(<span class="keyword">void</span>))</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch_async_f</span>(dq, _dispatch_Block_copy(work), _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dispatch_async封装调用了dispatch_async_f函数，先将block拷贝到堆上，避免block执行前被销毁，同时传入_dispatch_call_block_and_release来保证block执行后会执行Block_release。下面看一下dispatch_async_f的实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_async_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width == <span class="number">1</span>) &#123;</span><br><span class="line">       <span class="comment">//如果是串行队列，执行dispatch_barrier_async_f，和当前函数的不同点在于</span></span><br><span class="line">       <span class="comment">//.do_vtable = (void *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT)</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_barrier_async_f</span>(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务封装到dispatch_continuation_t结构体中</span></span><br><span class="line">    dc = <span class="built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)DISPATCH_OBJ_ASYNC_BIT;  <span class="comment">//将vtable设置为ASYNC标志位</span></span><br><span class="line">    dc-&gt;dc_func = func; </span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;do_targetq) &#123;</span><br><span class="line">       <span class="comment">//如果有do_targetq，将任务放到目标队列执行</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将任务压入队列(FIFO)</span></span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来分析一下_dispatch_queue_push，这是一个宏定义，展开后的调用栈如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_push</span><br><span class="line">└──_dispatch_trace_queue_push</span><br><span class="line">    └──_dispatch_queue_push</span><br></pre></td></tr></table></figure>

<p>看一下_dispatch_queue_push的具体实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_queue_push(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">dispatch_object_t</span> _tail) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">tail</span> =</span> _tail._do;</span><br><span class="line">    <span class="comment">//判断链表中是否已经存在节点，有的话返回YES,否则返回NO</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">fastpath</span>(_dispatch_queue_push_list2(dq, tail, tail))) &#123;</span><br><span class="line">       <span class="comment">//将任务放到链表头部</span></span><br><span class="line">        _dispatch_queue_push_slow(dq, tail);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断链表中是否已经存在节点</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> _dispatch_queue_push_list2(<span class="keyword">dispatch_queue_t</span> dq, </span><br><span class="line">                                              struct dispatch_object_s *head,</span><br><span class="line">                                              struct dispatch_object_s *tail) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">prev</span>;</span></span><br><span class="line">    tail-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//将tail原子性赋值给dq-&gt;dq_items_tail，同时返回之前的值并赋给prev</span></span><br><span class="line">    prev = <span class="built_in">dispatch_atomic_xchg2o</span>(dq, dq_items_tail, tail, release);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(prev)) &#123;</span><br><span class="line">       <span class="comment">//如果prev不等于NULL，直接在链表尾部添加节点</span></span><br><span class="line">        prev-&gt;do_next = head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//链表中之前有元素返回YES，否则返回NO</span></span><br><span class="line">    <span class="keyword">return</span> (prev != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将节点放到链表开头</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_queue_push_slow(<span class="keyword">dispatch_queue_t</span> dq,</span><br><span class="line">                               struct dispatch_object_s *obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dx_type</span>(dq) == DISPATCH_QUEUE_ROOT_TYPE &amp;&amp; !dq-&gt;dq_is_thread_bound) &#123;</span><br><span class="line">       <span class="comment">//原子性的将head存储到链表头部</span></span><br><span class="line">        <span class="built_in">dispatch_atomic_store2o</span>(dq, dq_items_head, obj, relaxed);</span><br><span class="line">        <span class="comment">//唤醒global queue队列</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_queue_wakeup_global(dq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将obj放到链表头部并执行_dispatch_wakeup函数里的dx_probe()函数</span></span><br><span class="line">    _dispatch_queue_push_list_slow2(dq, obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可以看出<code>_dispatch_queue_push</code>分为两种情况：</p>
<ul>
<li>如果队列的链表不为空，将节点添加到链表尾部，即dq-&gt;dq_item_tail=dc。然后队列会按先进先出(FIFO)来处理任务。</li>
<li>如果队列此时为空，进入到<code>_dispatch_queue_push_slow</code>函数。<ul>
<li>如果队列是全局队列会进入if分支，原子性的将节点添加到队列开头，并执行<code>_dispatch_queue_wakeup_global</code>唤醒全局队列；</li>
<li>如果队列是主队列或自定义串行队列if分支判断不成立，执行<code>_dispatch_queue_push_list_slow2</code>函数，它会将节点添加到队列开头并执行<code>_dispatch_wakeup</code>函数唤醒队列。</li>
</ul>
</li>
</ul>
<p><code>dispatch_async</code>第一阶段的工作主要是封装外部任务并添加到队列的链表中，可以用下图来表示：</p>
<img src="/images/GCD/dispatch_queue-3.png" alt="img" style="zoom:80%;" />

<p>接着来看队列唤醒的逻辑，主要分成主队列和全局队列的唤醒和任务执行逻辑：</p>
<p>1、如果是主队列，会先调用<code>_dispatch_wakeup</code>唤醒队列，然后执行<code>_dispatch_main_queue_wakeup</code>函数来唤醒主线程的Runloop，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> _dispatch_wakeup(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dou._do))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//_dispatch_queue_probe判断dq_items_tail是否为空，if分支不成立</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dx_probe</span>(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果dou._do-&gt;do_suspend_cnt==0，返回YES,否则返回NO；</span></span><br><span class="line">    <span class="comment">//同时将DISPATCH_OBJECT_SUSPEND_LOCK赋值给dou._do-&gt;do_suspend_cnt</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">dispatch_atomic_cmpxchg2o</span>(dou._do, do_suspend_cnt, <span class="number">0</span>, DISPATCH_OBJECT_SUSPEND_LOCK, release)) &#123;</span><br><span class="line">            <span class="comment">//因为主线程do_suspend_cnt非0，所以主线程if分支判断成功</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">        <span class="keyword">if</span> (dou._dq == &amp;_dispatch_main_q) &#123;</span><br><span class="line">            <span class="comment">//主队列的任务执行和Runloop关联，唤醒主队列</span></span><br><span class="line">            <span class="keyword">return</span> _dispatch_main_queue_wakeup();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//放到目标队列中，重新走_dispatch_queue_push方法</span></span><br><span class="line">    _dispatch_retain(dou._do);</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> tq = dou._do-&gt;do_targetq;</span><br><span class="line">    _dispatch_queue_push(tq, dou._do);</span><br><span class="line">    <span class="keyword">return</span> tq;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒主线程Runloop</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_queue_t</span> _dispatch_main_queue_wakeup(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = &amp;_dispatch_main_q;</span><br><span class="line">    <span class="keyword">if</span> (!dq-&gt;dq_is_thread_bound) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//只初始化一次mach_port_t</span></span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(&amp;_dispatch_main_q_port_pred, dq, _dispatch_runloop_queue_port_init);</span><br><span class="line">    _dispatch_runloop_queue_wakeup_thread(dq);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒runloop</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_runloop_queue_wakeup_thread(<span class="keyword">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    <span class="keyword">mach_port_t</span> mp = (<span class="keyword">mach_port_t</span>)dq-&gt;do_ctxt;</span><br><span class="line">    <span class="keyword">if</span> (!mp) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//唤醒主线程的runloop</span></span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = _dispatch_send_wakeup_runloop_thread(mp, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (kr) &#123;</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_TIMEOUT:</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_TIMED_OUT:</span><br><span class="line">    <span class="keyword">case</span> MACH_SEND_INVALID_DEST:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们调用 dispatch_async(dispatch_get_main_queue(), block) 时，libDispatch 向主线程的 RunLoop 发送消息，RunLoop会被唤醒，并从消息中取得这个 block，并在回调 <strong>CFRUNLOOP_IS_SERVICING_THE_MAIN_DISPATCH_QUEUE</strong>() 里执行这个 block。用Xcode在block处打断点就会看到下图中的调用栈:</p>
<img src="/images/GCD/dispatch_queue-4.png" alt="img" style="zoom:80%;" />

<p>2、如果是全局队列，调用_dispatch_queue_wakeup_global函数，它封装调用了核心函数<code>_dispatch_queue_wakeup_global_slow</code>，调用栈和核心代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_wakeup_global_slow</span><br><span class="line">└──_dispatch_queue_wakeup_global2</span><br><span class="line">    └──_dispatch_queue_wakeup_global_slow</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_queue_wakeup_global_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">unsigned</span> <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> pred;</span><br><span class="line">    <span class="keyword">dispatch_root_queue_context_t</span> qc = dq-&gt;do_ctxt;</span><br><span class="line">    <span class="keyword">uint32_t</span> i = n;</span><br><span class="line">    <span class="keyword">int</span> r;</span><br><span class="line"></span><br><span class="line">    _dispatch_debug_root_queue(dq, __func__);</span><br><span class="line">    <span class="comment">//初始化dispatch_root_queue_context_s</span></span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(&amp;pred, <span class="literal">NULL</span>, _dispatch_root_queues_init);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_USE_PTHREAD_POOL</span></span><br><span class="line">    <span class="comment">//为了防止有些timer每隔一分钟调用，线程执行任务后会有65s的超时用来等待signal唤醒</span></span><br><span class="line">    <span class="comment">//降低线程频繁创建销毁的性能消耗</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">dispatch_semaphore_signal</span>(qc-&gt;dgq_thread_mediator)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!--i) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//检测线程池可用大小，如果还有，则将线程池减一</span></span><br><span class="line">    <span class="keyword">uint32_t</span> j, t_count = qc-&gt;dgq_thread_pool_size;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!t_count) &#123;</span><br><span class="line">          <span class="comment">//线程池已达到最大使用量</span></span><br><span class="line">            _dispatch_root_queue_debug(<span class="string">&quot;pthread pool is full for root queue: &quot;</span></span><br><span class="line">                    <span class="string">&quot;%p&quot;</span>, dq);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        j = i &gt; t_count ? t_count : i;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!<span class="built_in">dispatch_atomic_cmpxchgvw2o</span>(qc, dgq_thread_pool_size, t_count, t_count - j, &amp;t_count, relaxed));</span><br><span class="line">   <span class="comment">//创建新的线程，入口函数是_dispatch_worker_thread</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        _dispatch_retain(dq);</span><br><span class="line">        <span class="keyword">while</span> ((r = <span class="built_in">pthread_create</span>(pthr, attr, _dispatch_worker_thread, dq))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r != EAGAIN) &#123;</span><br><span class="line">                (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(r);</span><br><span class="line">            &#125;</span><br><span class="line">            _dispatch_temporary_resource_shortage();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!attr) &#123;</span><br><span class="line">            r = <span class="built_in">pthread_detach</span>(*pthr);</span><br><span class="line">            (<span class="keyword">void</span>)<span class="built_in">dispatch_assume_zero</span>(r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (--j);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_USE_PTHREAD_POOL</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建新的线程后执行<code>_dispatch_worker_thread</code>函数，代码简化后如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> * _dispatch_worker_thread(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int64_t</span> timeout = (pqc ? <span class="number">5ull</span> : <span class="number">65ull</span>) * NSEC_PER_SEC;</span><br><span class="line">    <span class="comment">//为了防止有些timer每隔一分钟调用，线程执行任务后会有65s的超时用来等待signal唤醒</span></span><br><span class="line">    <span class="comment">//降低线程频繁创建销毁的性能消耗</span></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">       <span class="comment">//取出一个任务并执行</span></span><br><span class="line">        _dispatch_root_queue_drain(dq);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">dispatch_semaphore_wait</span>(qc-&gt;dgq_thread_mediator, <span class="built_in">dispatch_time</span>(<span class="number">0</span>, timeout)) == <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//将线程池加一</span></span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_inc2o</span>(qc, dgq_thread_pool_size, relaxed);</span><br><span class="line">    _dispatch_queue_wakeup_global(dq);</span><br><span class="line">    _dispatch_release(dq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从队列取任务的入口是_dispatch_root_queue_drain函数，简化的代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_root_queue_drain(<span class="keyword">dispatch_queue_t</span> dq) &#123;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="comment">// ensure that high-level memory management techniques do not leak/crash</span></span><br><span class="line">    <span class="keyword">if</span> (dispatch_begin_thread_4GC) &#123;</span><br><span class="line">        <span class="built_in">dispatch_begin_thread_4GC</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//autoreleasepool的push操作</span></span><br><span class="line">    <span class="keyword">void</span> *pool = _dispatch_autorelease_pool_push();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_COCOA_COMPAT</span></span></span><br><span class="line"></span><br><span class="line">    _dispatch_perfmon_start();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">item</span>;</span></span><br><span class="line">    <span class="comment">//取出队列的头部节点(FIFO)</span></span><br><span class="line">    <span class="keyword">while</span> ((item = <span class="built_in">fastpath</span>(_dispatch_queue_concurrent_drain_one(dq)))) &#123;</span><br><span class="line">        <span class="comment">//对取出的内容进行处理，核心函数</span></span><br><span class="line">        _dispatch_continuation_pop(item);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_perfmon_end();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_COCOA_COMPAT</span></span><br><span class="line">    <span class="comment">//autoreleasepool的pop操作</span></span><br><span class="line">    _dispatch_autorelease_pool_pop(pool);</span><br><span class="line">    <span class="keyword">if</span> (dispatch_end_thread_4GC) &#123;</span><br><span class="line">        <span class="built_in">dispatch_end_thread_4GC</span>();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// DISPATCH_COCOA_COMPAT</span></span></span><br><span class="line"></span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>队列唤醒后的工作主要是用线程池(全局队列)或者唤醒Runloop(主队列)的方式从队列的链表中依次取出要执行的任务，流程图如下：</p>
<img src="/images/GCD/dispatch_queue-5.png" alt="img" style="zoom:80%;" />

<p>队列的任务取出之后就是核心的执行逻辑了，也就是<code>_dispatch_continuation_pop</code>函数的逻辑，代码和流程图如下所示:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg;</span><br><span class="line"></span><br><span class="line">    _dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);</span><br><span class="line">    <span class="comment">//判断传入的内容是不是队列，如果是的话执行_dispatch_queue_invoke函数，否的话就是block型的</span></span><br><span class="line">    <span class="comment">//任务，直接执行block即可</span></span><br><span class="line">    <span class="comment">//dispatch_barrier_async到自定义并行队列时,dou._do是用户创建的自定义queue，此时会执行</span></span><br><span class="line">    <span class="comment">//_dispatch_queue_invoke，并且用信号量保证barrier的任务不会和其他任务同时执行，后续分析</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">DISPATCH_OBJ_IS_VTABLE</span>(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dx_invoke</span>(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否带有DISPATCH_OBJ_ASYNC_BIT标志位</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_ASYNC_BIT) &#123;</span><br><span class="line">        dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dc1 = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断是否是group</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;</span><br><span class="line">        dg = dc-&gt;dc_data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dispatch_continuation_t结构体，执行dc-&gt;dc_func(dc-&gt;ctxt)</span></span><br><span class="line">    <span class="comment">//本质是调用Block_layout结构体的invoke执行block的实现代码</span></span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="keyword">if</span> (dg) &#123;</span><br><span class="line">       <span class="comment">//如果是群组执行dispatch_group_leave</span></span><br><span class="line">        <span class="built_in">dispatch_group_leave</span>(dg);</span><br><span class="line">        _dispatch_release(dg);</span><br><span class="line">    &#125;</span><br><span class="line">     _dispatch_introspection_queue_item_complete(dou);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dc1)) &#123;</span><br><span class="line">        _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/images/GCD/dispatch_queue-6.png" alt="img" style="zoom:80%;" />

<p>总结一下：<code>dispatch_async</code>的流程是用链表保存所有提交的block，然后在底层线程池中，依次取出block并执行；而向主队列提交block则会向主线程的Runloop发送消息并唤醒Runloop，接着会在回调函数中取出block并执行。</p>
<h4 id="5-dispatch-sync"><a href="#5-dispatch-sync" class="headerlink" title="5. dispatch_sync"></a>5. dispatch_sync</h4><p>了解了dispatch_async的逻辑后，再来看下dispatch_sync的实现和流程。<code>dispatch_sync</code>主要封装调用了<code>dispatch_sync_f</code>函数，看一下具体代码:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">       <span class="comment">//串行队列执行同步方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_barrier_sync_f</span>(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!dq-&gt;do_targetq)) &#123;</span><br><span class="line">       <span class="comment">//global queue不要求执行顺序，直接执行具体的block</span></span><br><span class="line">        <span class="comment">// the global concurrent queues do not need strict ordering</span></span><br><span class="line">        (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//并发队列压入同步方法</span></span><br><span class="line">    _dispatch_sync_f2(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可以看出，后续逻辑主要分为两种情况：</p>
<p>1、向串行队列提交同步任务，执行dispatch_barrier_sync_f函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_sync_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!<span class="built_in">dispatch_atomic_cmpxchg2o</span>(dq, dq_running, <span class="number">0</span>, <span class="number">1</span>, acquire))) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_barrier_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果队列无任务执行，调用_dispatch_barrier_sync_f_invoke执行任务。<code>_dispatch_barrier_sync_f_invoke</code>代码逻辑展开后如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_barrier_sync_f_invoke(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="comment">//任务执行核心逻辑，将当前线程的dispatch_queue_key设置为dq，然后执行block，</span></span><br><span class="line">    <span class="comment">//执行完之后再恢复到之前的old_dq</span></span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line">    _dispatch_client_callout(ctxt, func);</span><br><span class="line">    _dispatch_perfmon_workitem_inc();</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果队列中存在其他任务，用信号量的方法唤醒，然后继续执行下一个任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_sync_f2(dq);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">dispatch_atomic_dec2o</span>(dq, dq_running, release) == <span class="number">0</span>)) &#123;</span><br><span class="line">        _dispatch_wakeup(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果队列存在其他任务或者被挂起，调用<code>_dispatch_barrier_sync_f_slow</code>函数，等待该队列的任务执行完之后用信号量通知队列继续执行任务。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_barrier_sync_f_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = _dispatch_get_thread_semaphore();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dc</span> =</span> &#123;</span><br><span class="line">        .dc_data = dq,</span><br><span class="line">        .dc_func = func,</span><br><span class="line">        .dc_ctxt = ctxt,</span><br><span class="line">        .dc_other = (<span class="keyword">void</span>*)sema,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dbss</span> =</span> &#123;</span><br><span class="line">        .do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_BARRIER_BIT | DISPATCH_OBJ_SYNC_SLOW_BIT),</span><br><span class="line">        .dc_func = _dispatch_barrier_sync_f_slow_invoke,</span><br><span class="line">        .dc_ctxt = &amp;dc,</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_INTROSPECTION</span></span><br><span class="line">        .dc_data = (<span class="keyword">void</span>*)_dispatch_thread_self(),</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//使用信号量等待其他任务执行完成</span></span><br><span class="line">    _dispatch_queue_push(dq, &amp;dbss);</span><br><span class="line">    _dispatch_thread_semaphore_wait(sema); <span class="comment">// acquire</span></span><br><span class="line">    _dispatch_put_thread_semaphore(sema);</span><br><span class="line">    <span class="comment">//收到signal信号，继续执行当前任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        _dispatch_function_recurse(dq, ctxt, func);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、向并发队列提交同步任务，执行<code>_dispatch_sync_f2</code>函数。如果队列存在其他任务，或者队列被挂起，或者有正在执行的任务，则调用<code>_dispatch_sync_f_slow</code>函数，使用信号量等待，否则直接调用<code>_dispatch_sync_f_invoke</code>执行任务。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_sync_f2(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;dq_items_tail) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)))&#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">uint32_t</span> running = <span class="built_in">dispatch_atomic_add2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">    <span class="comment">// re-check suspension after barrier check &lt;rdar://problem/15242126&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(running &amp; <span class="number">1</span>) || <span class="built_in">slowpath</span>(<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq))) &#123;</span><br><span class="line">        running = <span class="built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="number">2</span>, relaxed);</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_slow(dq, ctxt, func, running == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_sync_f_recurse(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_sync_f_invoke(dq, ctxt, func);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//队列存在其他任务|队列被挂起|有正在执行的任务，信号等待</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_sync_f_slow(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func, <span class="keyword">bool</span> wakeup) &#123;</span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = _dispatch_get_thread_semaphore();</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> <span class="title">dss</span> =</span> &#123;</span><br><span class="line">        .do_vtable = (<span class="keyword">void</span>*)DISPATCH_OBJ_SYNC_SLOW_BIT,</span><br><span class="line">        .dc_func = func,</span><br><span class="line">        .dc_ctxt = ctxt,</span><br><span class="line">        .dc_data = (<span class="keyword">void</span>*)_dispatch_thread_self(),</span><br><span class="line">        .dc_other = (<span class="keyword">void</span>*)sema,</span><br><span class="line">    &#125;;</span><br><span class="line">    _dispatch_queue_push_wakeup(dq, &amp;dss, wakeup);</span><br><span class="line">    <span class="comment">//信号等待</span></span><br><span class="line">    _dispatch_thread_semaphore_wait(sema);</span><br><span class="line">    _dispatch_put_thread_semaphore(sema);</span><br><span class="line">    <span class="comment">//信号唤醒，执行同步任务</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dq-&gt;do_targetq-&gt;do_targetq)) &#123;</span><br><span class="line">        _dispatch_function_recurse(dq, ctxt, func);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_function_invoke(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(<span class="built_in">dispatch_atomic_sub2o</span>(dq, dq_running, <span class="number">2</span>, relaxed) == <span class="number">0</span>)) &#123;</span><br><span class="line">        _dispatch_wakeup(dq);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatch_sync</code>的逻辑主要是将任务放入队列，并用线程专属信号量做等待，保证每次只会有一个block在执行。流程图如下：</p>
<img src="/images/GCD/dispatch_queue-7.png" alt="img" style="zoom:80%;" />

<h3 id="4-1-5-Dispatch-Quene机制的底层实现"><a href="#4-1-5-Dispatch-Quene机制的底层实现" class="headerlink" title="4.1.5 Dispatch Quene机制的底层实现"></a>4.1.5 Dispatch Quene机制的底层实现</h3><h4 id="1-Dispatch-Quene实现所需"><a href="#1-Dispatch-Quene实现所需" class="headerlink" title="1. Dispatch Quene实现所需"></a>1. Dispatch Quene实现所需</h4><p>GCD的Dispatch Queue非常方便，其实现会使用下面这些工具，但不仅仅只有这些：</p>
<ul>
<li>用于管理追加的Block的C语言实现的FIFO队列；</li>
<li>Atomic函数中实现的用于排他控制的轻量级信号；</li>
<li>用于管理线程的C语言实现的一些容器。</li>
</ul>
<p>用于实现Dispatch Queue的几个软件组件框架：</p>
<ul>
<li>组件libdispatch提供Dispatch Quene技术；</li>
<li>组件Libc(pthreads)提供pthread_workquene技术；</li>
<li>组件XNU内核提供workquene技术。</li>
</ul>
<h4 id="2-执行上下文"><a href="#2-执行上下文" class="headerlink" title="2. 执行上下文"></a>2. 执行上下文</h4><p>Dispatch Quene通过结构体和链表，被实现为FIFO队列。</p>
<p>Block并不是直接加入FIFO队列，而是先加入 <code>Dispatch Continuation</code> 这一 <code>dispatch_continuation_t类型</code> 结构体中，然后再加入 FIFO 队列。该 Dispatch Continuation 用于记忆 Block 所属的 Dispatch Group 和其他一些信息，相当于一般常说的<strong>执行上下文</strong>。</p>
<p>上面在讲 <code>Global Dispatch Queue</code> 的时候，我们介绍过8种类型，这8种 Global Dispatch Quene 各使用一个pthread_workquene。GCD初始化时，使用 <code>pthread_workquene_creat_np</code> 函数生成 pthread_workquene。</p>
<p>pthread_workquene包含在Libc提供的pthreads API 中。其使用bsdthread_register和workq_open系统调用，<strong>在初始化XNU内核的workquene之后获取workquene信息</strong>。</p>
<p>XNU内核持有4种workquene：</p>
<ul>
<li>WORKQUENE_HIGH_PRIOQUENE</li>
<li>WORKQUENE_Default_PRIOQUENE</li>
<li>WORKQUENE_Low_PRIOQUENE</li>
<li>WORKQUENE_BG_PRIOQUENE</li>
</ul>
<p>以上4种执行优先级的workqueue，其执行优先级与Global Dispatch Quene的四种执行优先级相同。</p>
<p><strong>Global Dispatch Queue → Libc pthread_wordqueue → XNU workqueue</strong></p>
<img src="/images/GCD/gcd-imp-1.jpg" style="zoom:80%">

<h4 id="3-Dispatch-Queue执行Block的过程"><a href="#3-Dispatch-Queue执行Block的过程" class="headerlink" title="3. Dispatch Queue执行Block的过程"></a>3. Dispatch Queue执行Block的过程</h4><ol>
<li>在Global Dispatch Queue 中执行Block时，libdispatch 从Global Dispatch Queue自身的FIFO队列取出<code>Dispatch Continuation</code></li>
<li>调用<code>pthread_workqueue_additem_np</code>函数将该Global Dispatch Queue 本身、符合其优先级的workqueue信息以及执行Dispatch Continuation的回调函数等传递给参数。</li>
<li>pthread_workqueue_additem_np函数使用<code>workq_kernreturn系统调用</code>，通知workqueue增加应当执行的项目。<ol>
<li>根据该通知，XNU内核基于系统状态判断是否要生成线程。如果是<code>Overcommit优先级</code>的Global Dispatch Queue ，workqueue则始终生成线程(该线程虽然与iOS和OS X中通常使用的线程大致相同，但是有一部分pthread API不能使用)。</li>
<li>因为workqueue生成的线程在实现用于workqueue的线程计划表中运行，他的<code>上下文切换(shift context)</code>与普通的线程有很大的不同。这也是隐藏着使用GCD的原因。</li>
</ol>
</li>
<li>workqueue的线程 –&gt; 执行pthread_workqueue函数 –&gt; 该函数调用libdispatch的回调函数。在该回调函数中执行加入到Global Dispatch Queue中的下一个Block。</li>
<li>Block执行结束后，进行通知Dispatch Group结束、释放Dispatch Continuation等处理，开始准备执行加入到Global Dispatch Queue中的下一个Block。</li>
</ol>
<h3 id="4-1-6-总结"><a href="#4-1-6-总结" class="headerlink" title="4.1.6 总结"></a>4.1.6 总结</h3><p>dispatch_async将任务添加到队列的链表中并唤醒队列，全局队列唤醒时中会从线程池里取出可用线程，如果没有则会新建线程，然后在线程中执行队列取出的任务；主队列会唤醒主线程的Runloop，然后在Runloop循环中通知GCD执行主队列提交的任务。</p>
<p>dispatch_sync一般都在当前线程执行，如果是主队列的任务还是会切换到主线程执行。它使用线程信号量来实现串行执行的功能。</p>
<h2 id="4-2-Dispatch-Semaphore"><a href="#4-2-Dispatch-Semaphore" class="headerlink" title="4.2 Dispatch Semaphore"></a>4.2 Dispatch Semaphore</h2><h3 id="4-2-1-API介绍"><a href="#4-2-1-API介绍" class="headerlink" title="4.2.1 API介绍"></a>4.2.1 API介绍</h3><p>Dispatch Semaphore是持有计数的信号，该信号是多线程编程中的计数类型信号。所谓信号，类似过马路时常用的手旗，可以通过时举起手旗，不可以通过时放下手旗。</p>
<p>在Dispatch Semaphore中，使用计数来实现该功能：<strong>计数为0时等待，计数为1或大于1时，减去1而不等待</strong>。</p>
<p>信号量的使用比较简单，主要就三个API：<code>create</code>、<code>wait</code>和<code>signal</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 使用dispatch_semaphore_create函数生成Dispatch Semaphore</span></span><br><span class="line"><span class="comment"> * 参数value是信号量计数的初始值</span></span><br><span class="line"><span class="comment"> * 函数名称中包含create，必须自己通过dispatch_release函数释放，和dispatch_retain函数持有</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_semaphore_t</span> <span class="title">dispatch_semaphore_create</span><span class="params">(<span class="keyword">intptr_t</span> value)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 当Dispatch Semaphore的计数值大于等于1，或者待机中计数值大于等于1时，对该计数进行减法并从dispatch_semaphore_wait函数返回。</span></span><br><span class="line"><span class="comment"> * 当Dispatch Semaphore的计数值为0时会等待(直到超时)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timeout：等待时间 dispatch_time_t类型。DISPATCH_TIME_FOREVER</span></span><br><span class="line"><span class="comment"> * @return 返回值与dispatch_group_wait函数相同，0表示执行完；超时时返回非0。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">dispatch_semaphore_wait</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让信号量值加一，如果有通过dispatch_semaphore_wait函数等待Dispatch Semaphore的计数值增加的线程，会由系统唤醒最先等待的线程执行。</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">dispatch_semaphore_signal</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放 </span></span><br><span class="line"><span class="built_in">dispatch_release</span>(semaphore);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-原理"><a href="#4-2-2-原理" class="headerlink" title="4.2.2 原理"></a>4.2.2 原理</h3><h4 id="1-dispatch-semaphore-t"><a href="#1-dispatch-semaphore-t" class="headerlink" title="1.dispatch_semaphore_t"></a>1.dispatch_semaphore_t</h4><p>首先看一下<code>dispatch_semaphore_s</code>的结构体定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dispatch_semaphore_s</span> &#123;</span></span><br><span class="line">    DISPATCH_STRUCT_HEADER(semaphore);</span><br><span class="line">    <span class="keyword">semaphore_t</span> dsema_port;    <span class="comment">//等同于mach_port_t信号</span></span><br><span class="line">    <span class="keyword">long</span> dsema_orig;           <span class="comment">//初始化的信号量值</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_value; <span class="comment">//当前信号量值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_sent_ksignals;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">volatile</span> dsema_group_waiters;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dsema_notify_head</span>;</span> <span class="comment">//notify的链表头部</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_continuation_s</span> *<span class="title">volatile</span> <span class="title">dsema_notify_tail</span>;</span> <span class="comment">//notify的链表尾部</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-dispatch-semaphore-create"><a href="#2-dispatch-semaphore-create" class="headerlink" title="2. dispatch_semaphore_create"></a>2. dispatch_semaphore_create</h4><p><code>dispatch_semaphore_create</code>用来创建信号量，创建时需要指定value，内部会将value的值存储到dsema_value(当前的value)和dsema_orig(初始value)中，value的值必须大于或等于0。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_semaphore_t</span> <span class="title">dispatch_semaphore_create</span><span class="params">(<span class="keyword">long</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">//value值需大于或等于0</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//申请dispatch_semaphore_t的内存</span></span><br><span class="line">    dsema = (<span class="keyword">dispatch_semaphore_t</span>)_dispatch_alloc(DISPATCH_VTABLE(semaphore),</span><br><span class="line">                                                  <span class="keyword">sizeof</span>(struct dispatch_semaphore_s) - <span class="keyword">sizeof</span>(dsema-&gt;dsema_notify_head) - <span class="keyword">sizeof</span>(dsema-&gt;dsema_notify_tail));</span><br><span class="line">    <span class="comment">//调用初始化函数</span></span><br><span class="line">    _dispatch_semaphore_init(value, dsema);</span><br><span class="line">    <span class="keyword">return</span> dsema;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//初始化结构体信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_semaphore_init(<span class="keyword">long</span> value, <span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = dou._dsema;</span><br><span class="line">    dsema-&gt;do_next = (<span class="keyword">dispatch_semaphore_t</span>)DISPATCH_OBJECT_LISTLESS;</span><br><span class="line">    dsema-&gt;do_targetq = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line">    dsema-&gt;dsema_value = value; <span class="comment">//设置信号量的当前value值</span></span><br><span class="line">    dsema-&gt;dsema_orig = value;  <span class="comment">//设置信号量的初始value值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>接着来看Dispatch Semaphore很容易忽略也是最容易造成App崩溃的地方，即信号量的释放。</strong></p>
<p>创建Semaphore的时候会将do_vtable指向_dispatch_semaphore_vtable，_dispatch_semaphore_vtable的结构定义了信号量销毁的时候会执行<code>_dispatch_semaphore_dispose</code>方法，相关代码实现如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore的vtable定义</span></span><br><span class="line">DISPATCH_VTABLE_INSTANCE(semaphore,</span><br><span class="line">    .do_type = DISPATCH_SEMAPHORE_TYPE,</span><br><span class="line">    .do_kind = <span class="string">&quot;semaphore&quot;</span>,</span><br><span class="line">    .do_dispose = _dispatch_semaphore_dispose,  <span class="comment">//销毁时执行的回调函数</span></span><br><span class="line">    .do_debug = _dispatch_semaphore_debug,      <span class="comment">//debug函数</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//释放信号量的函数</span></span><br><span class="line"><span class="keyword">void</span> _dispatch_semaphore_dispose(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = dou._dsema;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value &lt; dsema-&gt;dsema_orig) &#123;</span><br><span class="line">       <span class="comment">//Warning:信号量还在使用的时候销毁会造成崩溃</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="string">&quot;Semaphore/group object deallocated while in use&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_port) &#123;</span><br><span class="line">        kr = semaphore_destroy(mach_task_self(), dsema-&gt;dsema_port);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果销毁时信号量还在使用，那么dsema_value会小于dsema_orig，则会引起崩溃，这是一个特别需要注意的地方。这里模拟一下信号量崩溃的代码:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_semaphore_t</span> semephore = dispatch_semaphore_create(<span class="number">1</span>);</span><br><span class="line">dispatch_semaphore_wait(semephore, DISPATCH_TIME_FOREVER);</span><br><span class="line"><span class="comment">//重新赋值或者将semephore = nil都会造成崩溃,因为此时信号量还在使用中</span></span><br><span class="line">semephore = dispatch_semaphore_create(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h4 id="3-dispatch-semaphore-wait"><a href="#3-dispatch-semaphore-wait" class="headerlink" title="3. dispatch_semaphore_wait"></a>3. dispatch_semaphore_wait</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_wait</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(value &gt;= <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_semaphore_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatch_semaphore_wait</code>先将信号量的dsema值原子性减一，并将新值赋给value。如果value大于等于0就立即返回，否则调用<code>_dispatch_semaphore_wait_slow</code>函数，等待信号量唤醒或者timeout超时。<code>_dispatch_semaphore_wait_slow</code>函数定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_semaphore_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout) &#123;</span><br><span class="line">    <span class="keyword">long</span> orig;</span><br><span class="line">    <span class="keyword">mach_timespec_t</span> _timeout;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">again:</span><br><span class="line">    orig = dsema-&gt;dsema_sent_ksignals;</span><br><span class="line">    <span class="keyword">while</span> (orig) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_sent_ksignals, orig, orig - <span class="number">1</span>, &amp;orig, relaxed)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> nsec = _dispatch_timeout(timeout);</span><br><span class="line">            _timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">            _timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">            kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_value;</span><br><span class="line">        <span class="keyword">while</span> (orig &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_value, orig, orig + <span class="number">1</span>, &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_semaphore_wait_slow</code>函数根据timeout的类型分成了三种情况处理：</p>
<ol>
<li>DISPATCH_TIME_NOW：若<code>desma_value</code>小于0，对其加一并返回超时信号KERN_OPERATION_TIMED_OUT，原子性加一是为了抵消<code>dispatch_semaphore_wait</code>函数开始的减一操作。</li>
<li>DISPATCH_TIME_FOREVER：调用系统的<code>semaphore_wait</code>方法，直到收到<code>signal</code>调用。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kr = semaphore_wait(dsema-&gt;dsema_port);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>default：调用内核方法<code>semaphore_timedwait</code>计时等待，直到有信号到来或者超时了。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br></pre></td></tr></table></figure>

<p><code>dispatch_semaphore_wait</code>的流程图可以用下图表示：</p>
<img src="/images/GCD/dispatch-semaphore-1.png" alt="img" style="zoom:80%;" />

<h4 id="4-dispatch-semaphore-signal"><a href="#4-dispatch-semaphore-signal" class="headerlink" title="4. dispatch_semaphore_signal"></a>4. dispatch_semaphore_signal</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_semaphore_signal</span><span class="params">(<span class="keyword">dispatch_semaphore_t</span> dsema)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(value &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value == LONG_MIN)) &#123;</span><br><span class="line">       <span class="comment">//Warning：value值有误会造成崩溃，详见下篇dispatch_group的分析</span></span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="string">&quot;Unbalanced call to dispatch_semaphore_signal()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_semaphore_signal_slow(dsema);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先将dsema_value调用原子方法加1，如果大于零就立即返回0，否则进入<code>_dispatch_semaphore_signal_slow</code>方法，该函数会调用内核的<code>semaphore_signal</code>函数唤醒在<code>dispatch_semaphore_wait</code>中等待的线程。代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> _dispatch_semaphore_signal_slow(<span class="keyword">dispatch_semaphore_t</span> dsema) &#123;</span><br><span class="line">    _dispatch_retain(dsema);</span><br><span class="line">    (<span class="keyword">void</span>)dispatch_atomic_inc2o(dsema, dsema_sent_ksignals, relaxed);</span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">    DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line"></span><br><span class="line">    _dispatch_release(dsema);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatch_semaphore_signal</code>的流程比较简单，可以用下图表示：</p>
<img src="/images/GCD/dispatch-semaphore-2.png" alt="img" style="zoom:80%;" />

<h4 id="5-总结篇"><a href="#5-总结篇" class="headerlink" title="5. 总结篇"></a>5. 总结篇</h4><p>Dispatch Semaphore信号量主要是<code>dispatch_semaphore_wait</code>和<code>dispatch_semaphore_signal</code>函数：</p>
<ul>
<li><code>wait</code>会将信号量值减一，如果大于等于0就立即返回，否则等待信号量唤醒或者超时；</li>
<li><code>signal</code>会将信号量值加一，如果value大于0立即返回，否则<strong>唤醒某个等待中的线程【会由系统唤醒最先等待的线程执行】</strong>。</li>
</ul>
<p>需要注意的是信号量在销毁或重新创建的时候如果还在使用则会引起崩溃，详见上面的分析。</p>
<h3 id="4-2-3-应用"><a href="#4-2-3-应用" class="headerlink" title="4.2.3 应用"></a>4.2.3 应用</h3><p>1、信号量常用于对资源进行加锁操作，防止多线程访问修改数据出现结果不一致甚至崩溃的问题，代码示例如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在init等函数初始化</span></span><br><span class="line">_lock = dispatch_semaphore_create(<span class="number">1</span>); </span><br><span class="line">dispatch_semaphore_wait(_lock, DISPATCH_TIME_FOREVER); </span><br><span class="line"><span class="comment">//修改Array或字典等数据的信息</span></span><br><span class="line"></span><br><span class="line">dispatch_semaphore_signal(_lock);</span><br></pre></td></tr></table></figure>

<p>2、信号量也可用于链式请求，比如用来限制请求频次：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//链式请求，限制网络请求串行执行，第一个请求成功后再开始第二个请求</span></span><br><span class="line">- (<span class="keyword">void</span>)chainRequestCurrentConfig &#123;</span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        NSArray *<span class="built_in">list</span> = @[@<span class="string">&quot;1&quot;</span>,@<span class="string">&quot;2&quot;</span>,@<span class="string">&quot;3&quot;</span>];</span><br><span class="line">        <span class="keyword">dispatch_semaphore_t</span> semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line">        [<span class="built_in">list</span> enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) &#123;</span><br><span class="line">            [self fetchConfigurationWithCompletion:^(NSDictionary *dict) &#123;</span><br><span class="line">                dispatch_semaphore_signal(semaphore);</span><br><span class="line">            &#125;];</span><br><span class="line">            dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)fetchConfigurationWithCompletion:(<span class="keyword">void</span>(^)(NSDictionary *dict))completion &#123;</span><br><span class="line">    <span class="comment">//AFNetworking或其他网络请求库</span></span><br><span class="line">    dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</span><br><span class="line">        <span class="comment">//模拟网络请求</span></span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        !completion ? nil : completion(nil);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-3-Dispatch-Group"><a href="#4-3-Dispatch-Group" class="headerlink" title="4.3 Dispatch Group"></a>4.3 Dispatch Group</h2><p>dispatch_group可以将GCD的任务合并到一个组里来管理。可以<strong>指定当追加到Dispatch Queue中的多个处理全部结束时，执行某种操作。</strong></p>
<p>无论是串行还是并行队列，Dispatch Group都可监视这些处理执行的结束。一旦检测到所有的处理执行结束，就可将结束的处理追加到Dispatch Queue中。</p>
<h3 id="4-3-1-dispatch-group-create"><a href="#4-3-1-dispatch-group-create" class="headerlink" title="4.3.1 dispatch_group_create"></a>4.3.1 dispatch_group_create</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 创建与block相关联的新group。 因为函数名中含有create，所以在使用结束后需要过&quot;dispatch_release&quot;函数释放。</span></span><br><span class="line"><span class="function"><span class="keyword">dispatch_group_t</span> <span class="title">dispatch_group_create</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>Dispatch Group的本质是一个初始value为LONG_MAX的semaphore，通过信号量来实现一组任务的管理，源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_group_t</span> <span class="title">dispatch_group_create</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申请内存空间</span></span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg = (<span class="keyword">dispatch_group_t</span>)_dispatch_alloc(</span><br><span class="line">            DISPATCH_VTABLE(group), <span class="keyword">sizeof</span>(struct dispatch_semaphore_s));</span><br><span class="line">    <span class="comment">//使用LONG_MAX初始化信号量结构体</span></span><br><span class="line">    _dispatch_semaphore_init(LONG_MAX, dg);</span><br><span class="line">    <span class="keyword">return</span> dg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>当value等于LONG_MAX时表示所有任务已完成。</strong></p>
<h3 id="4-3-2-dispatch-group-enter"><a href="#4-3-2-dispatch-group-enter" class="headerlink" title="4.3.2 dispatch_group_enter"></a>4.3.2 dispatch_group_enter</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 手动指示一个block已进入group</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_enter(<span class="keyword">dispatch_group_t</span> group);</span><br></pre></td></tr></table></figure>

<p><code>dispatch_group_enter</code> 的逻辑是将 <code>dispatch_group_t</code> 转换成 <code>dispatch_semaphore_t</code> 后将 <code>dsema_value</code> 的值减一。源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_enter</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_dec2o(dsema, dsema_value, acquire);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(</span><br><span class="line">                <span class="string">&quot;Too many nested calls to dispatch_group_enter()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-dispatch-group-leave"><a href="#4-3-3-dispatch-group-leave" class="headerlink" title="4.3.3 dispatch_group_leave"></a>4.3.3 dispatch_group_leave</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 手动指示group中的某个block已完成</span></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">dispatch_group_leave(<span class="keyword">dispatch_group_t</span> group);</span><br></pre></td></tr></table></figure>

<p><code>dispatch_group_leave</code> 的逻辑是将 <code>dispatch_group_t</code> 转换成 <code>dispatch_semaphore_t</code> 后将 <code>dsema_value</code> 的值加一。源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_leave</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="keyword">long</span> value = dispatch_atomic_inc2o(dsema, dsema_value, release);</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">        DISPATCH_CLIENT_CRASH(<span class="string">&quot;Unbalanced call to dispatch_group_leave()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (slowpath(value == LONG_MAX)) &#123;</span><br><span class="line">        (<span class="keyword">void</span>)_dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当value等于LONG_MAX时表示所有任务已完成，调用<code>_dispatch_group_wake</code>唤醒group，因此<code>dispatch_group_leave</code>与<code>dispatch_group_enter</code>需成对出现。</p>
<ul>
<li>当调用了<code>dispatch_group_enter</code>而没有调用<code>dispatch_group_leave</code>时，会造成value值不等于LONG_MAX而不会走到唤醒逻辑，<code>dispatch_group_notify</code>函数的block无法执行或者<code>dispatch_group_wait</code>收不到<code>semaphore_signal</code>信号而卡住线程。</li>
<li>当<code>dispatch_group_leave</code>比<code>dispatch_group_enter</code>多调用了一次时，dispatch_semaphore_t的value会等于LONGMAX+1（2147483647+1），即long的负数最小值 LONG_MIN(–2147483648)。因为此时value小于0，所以会出现”Unbalanced call to dispatch_group_leave()”的崩溃，这是一个特别需要注意的地方。</li>
</ul>
<h3 id="4-3-4-dispatch-group-async"><a href="#4-3-4-dispatch-group-async" class="headerlink" title="4.3.4 dispatch_group_async"></a>4.3.4 dispatch_group_async</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 将block提交到调度队列，并将block与给定的调度group关联。相比dispatch_async函数不同的是通过第一个参数，指定Block属于指定的Dispatch Group</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async</span><span class="params">(<span class="keyword">dispatch_group_t</span> group,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> db)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//封装调用dispatch_group_async_f函数</span></span><br><span class="line">    dispatch_group_async_f(dg, dq, _dispatch_Block_copy(db),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_async_f</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    _dispatch_retain(dg);</span><br><span class="line">    <span class="comment">//先调用dispatch_group_enter操作</span></span><br><span class="line">    dispatch_group_enter(dg);</span><br><span class="line">    dc = _dispatch_continuation_alloc();</span><br><span class="line">    <span class="comment">//DISPATCH_OBJ_GROUP_BIT会在_dispatch_continuation_pop方法中用来判断是否为group，如果为group会执行dispatch_group_leave</span></span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_GROUP_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dc-&gt;dc_data = dg;</span><br><span class="line">    <span class="keyword">if</span> (dq-&gt;dq_width != <span class="number">1</span> &amp;&amp; dq-&gt;do_targetq) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_async_f2(dq, dc);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatch_group_async</code> 的原理和 <code>dispatch_async</code> 比较类似，区别点在于group操作会带上DISPATCH_OBJ_GROUP_BIT标志位。添加group任务时会先执行 <code>dispatch_group_enter</code> ，然后在任务执行时会对带有该标记的执行 <code>dispatch_group_leave</code> 操作。</p>
<p><code>dispatch_group_async_f </code>与 <code>dispatch_async_f</code>代码类似，主要执行了以下操作：</p>
<ol>
<li><p>调用dispatch_group_enter</p>
</li>
<li><p>将block和queue等信息记录到dispatch_continuation_t中，并将它加入到group的链表中。</p>
</li>
<li><p>_dispatch_continuation_pop执行时会判断任务是否为group，是的话执行完任务再调用dispatch_group_leave以达到信号量value的平衡。</p>
</li>
</ol>
<p><code>_dispatch_continuation_pop</code>简化后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_continuation_pop(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = dou._dc, dc1;</span><br><span class="line">    <span class="keyword">dispatch_group_t</span> dg;</span><br><span class="line">    _dispatch_trace_continuation_pop(_dispatch_queue_get_current(), dou);</span><br><span class="line">    <span class="comment">//判断是否为队列，是的话执行队列的invoke函数</span></span><br><span class="line">    <span class="keyword">if</span> (DISPATCH_OBJ_IS_VTABLE(dou._do)) &#123;</span><br><span class="line">        <span class="keyword">return</span> dx_invoke(dou._do);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">//dispatch_continuation_t结构体，执行具体任务</span></span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_GROUP_BIT) &#123;</span><br><span class="line">        dg = dc-&gt;dc_data;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dg = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="keyword">if</span> (dg) &#123;</span><br><span class="line">       <span class="comment">//这是group操作，执行leave操作对应最初的enter</span></span><br><span class="line">        dispatch_group_leave(dg);</span><br><span class="line">        _dispatch_release(dg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-5-dispatch-group-wait"><a href="#4-3-5-dispatch-group-wait" class="headerlink" title="4.3.5 dispatch_group_wait"></a>4.3.5 dispatch_group_wait</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * 同步地等待，直到与一个group相关联的所有block都完成，或者直到指定的超时已经过去</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param timeout 指定等待时间 dispatch_time_t类型的值 (DISPATCH_TIME_FOREVER 一直)</span></span><br><span class="line"><span class="comment"> * @returrn  如果返回值不为0，表示经过等待，任务还在执行中; 如果为0，全部执行结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">intptr_t</span> <span class="title">dispatch_group_wait</span><span class="params">(<span class="keyword">dispatch_group_t</span> group, <span class="keyword">dispatch_time_t</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>源码分析：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">dispatch_group_wait</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_time_t</span> timeout)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timeout == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> _dispatch_group_wait_slow(dsema, timeout);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果当前value的值为初始值，表示任务都已经完成，直接返回0，如果timeout为0的话返回超时。其余情况会调用_dispatch_group_wait_slow方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wait_slow(<span class="keyword">dispatch_semaphore_t</span> dsema, <span class="keyword">dispatch_time_t</span> timeout) &#123;</span><br><span class="line">    <span class="keyword">long</span> orig;</span><br><span class="line">    <span class="keyword">mach_timespec_t</span> _timeout;</span><br><span class="line">    <span class="keyword">kern_return_t</span> kr;</span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    (<span class="keyword">void</span>)dispatch_atomic_inc2o(dsema, dsema_group_waiters, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (dsema-&gt;dsema_value == LONG_MAX) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_group_wake(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">    <span class="keyword">switch</span> (timeout) &#123;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">uint64_t</span> nsec = _dispatch_timeout(timeout);</span><br><span class="line">            _timeout.tv_sec = (typeof(_timeout.tv_sec))(nsec / NSEC_PER_SEC);</span><br><span class="line">            _timeout.tv_nsec = (typeof(_timeout.tv_nsec))(nsec % NSEC_PER_SEC);</span><br><span class="line">            kr = slowpath(semaphore_timedwait(dsema-&gt;dsema_port, _timeout));</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (kr != KERN_OPERATION_TIMED_OUT) &#123;</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_NOW:</span><br><span class="line">        orig = dsema-&gt;dsema_group_waiters;</span><br><span class="line">        <span class="keyword">while</span> (orig) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dispatch_atomic_cmpxchgvw2o(dsema, dsema_group_waiters, orig,</span><br><span class="line">                    orig - <span class="number">1</span>, &amp;orig, relaxed)) &#123;</span><br><span class="line">                <span class="keyword">return</span> KERN_OPERATION_TIMED_OUT;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">case</span> DISPATCH_TIME_FOREVER:</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            kr = semaphore_wait(dsema-&gt;dsema_port);</span><br><span class="line">        &#125; <span class="keyword">while</span> (kr == KERN_ABORTED);</span><br><span class="line">        DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">goto</span> again;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>可以看到跟dispatch_semaphore的<code>_dispatch_semaphore_wait_slow</code>方法很类似，不同点在于等待完之后调用的again函数会调用<code>_dispatch_group_wake</code>唤醒当前group。</p>
<h3 id="4-3-6-dispatch-group-notify"><a href="#4-3-6-dispatch-group-notify" class="headerlink" title="4.3.6 dispatch_group_notify"></a>4.3.6 dispatch_group_notify</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*!</span></span><br><span class="line"><span class="comment"> * 当与一个group相关联的所有block都完成时，将一个block提交到队列中。【或者当dispatch_group_enter、dispatch_group_leave调用次数匹配时】</span></span><br><span class="line"><span class="comment"> * 不管指定什么样的Dispatch Queue，在追加指定的Block时，之前与Dispatch Group相关联的block都已执行结束。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param group 要监视的Dispatch Group</span></span><br><span class="line"><span class="comment"> * @param queue/block 在追加到该Dispatch Group中的全部处理执行结束时，将第三个参数的Block追加到第二个参数的Dispatch Queue中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify</span><span class="params">(<span class="keyword">dispatch_group_t</span> group,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">dispatch_queue_t</span> <span class="built_in">queue</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">dispatch_block_t</span> block)</span></span>;</span><br></pre></td></tr></table></figure>

<p>源码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> db)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//封装调用dispatch_group_notify_f函数</span></span><br><span class="line">    dispatch_group_notify_f(dg, dq, _dispatch_Block_copy(db),</span><br><span class="line">            _dispatch_call_block_and_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真正的入口函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_group_notify_f</span><span class="params">(<span class="keyword">dispatch_group_t</span> dg, <span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">void</span> (*func)(<span class="keyword">void</span> *))</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_semaphore_t</span> dsema = (<span class="keyword">dispatch_semaphore_t</span>)dg;</span><br><span class="line">    <span class="comment">//封装结构体</span></span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> prev, dsn = _dispatch_continuation_alloc();</span><br><span class="line">    dsn-&gt;do_vtable = (<span class="keyword">void</span> *)DISPATCH_OBJ_ASYNC_BIT;</span><br><span class="line">    dsn-&gt;dc_data = dq;</span><br><span class="line">    dsn-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dsn-&gt;dc_func = func;</span><br><span class="line">    dsn-&gt;do_next = <span class="literal">NULL</span>;</span><br><span class="line">    _dispatch_retain(dq);</span><br><span class="line">    <span class="comment">//将结构体放到链表尾部，如果链表为空同时设置链表头部节点并唤醒group</span></span><br><span class="line">    prev = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, dsn, release);</span><br><span class="line">    <span class="keyword">if</span> (fastpath(prev)) &#123;</span><br><span class="line">        prev-&gt;do_next = dsn;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _dispatch_retain(dg);</span><br><span class="line">        dispatch_atomic_store2o(dsema, dsema_notify_head, dsn, seq_cst);</span><br><span class="line">        dispatch_atomic_barrier(seq_cst); <span class="comment">// &lt;rdar://problem/11750916&gt;</span></span><br><span class="line">        <span class="keyword">if</span> (dispatch_atomic_load2o(dsema, dsema_value, seq_cst) == LONG_MAX) &#123;</span><br><span class="line">            _dispatch_group_wake(dsema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dispatch_group_notify的具体实现在dispatch_group_notify_f函数里，逻辑就是将block和queue封装到dispatch_continuation_t里，并将它加到链表的尾部，如果链表为空同时还会设置链表的头部节点。如果dsema_value的值等于初始值，则调用_dispatch_group_wake执行唤醒逻辑。</p>
<h3 id="4-3-7-dispatch-group-wake-内部API"><a href="#4-3-7-dispatch-group-wake-内部API" class="headerlink" title="4.3.7 dispatch_group_wake(内部API)"></a>4.3.7 dispatch_group_wake(内部API)</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">long</span> _dispatch_group_wake(<span class="keyword">dispatch_semaphore_t</span> dsema) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> next, head, tail = <span class="literal">NULL</span>, dc;</span><br><span class="line">    <span class="keyword">long</span> rval;</span><br><span class="line">   <span class="comment">//将dsema的dsema_notify_head赋值为NULL，同时将之前的内容赋给head</span></span><br><span class="line">    head = dispatch_atomic_xchg2o(dsema, dsema_notify_head, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">        <span class="comment">//将dsema的dsema_notify_tail赋值为NULL，同时将之前的内容赋给tail</span></span><br><span class="line">        tail = dispatch_atomic_xchg2o(dsema, dsema_notify_tail, <span class="literal">NULL</span>, relaxed);</span><br><span class="line">    &#125;</span><br><span class="line">    rval = (<span class="keyword">long</span>)dispatch_atomic_xchg2o(dsema, dsema_group_waiters, <span class="number">0</span>, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (rval) &#123;</span><br><span class="line">        <span class="comment">// wake group waiters</span></span><br><span class="line">        _dispatch_semaphore_create_port(&amp;dsema-&gt;dsema_port);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">kern_return_t</span> kr = semaphore_signal(dsema-&gt;dsema_port);</span><br><span class="line">            DISPATCH_SEMAPHORE_VERIFY_KR(kr);</span><br><span class="line">        &#125; <span class="keyword">while</span> (--rval);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head) &#123;</span><br><span class="line">        <span class="comment">// async group notify blocks</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            next = fastpath(head-&gt;do_next);</span><br><span class="line">            <span class="keyword">if</span> (!next &amp;&amp; head != tail) &#123;</span><br><span class="line">                <span class="keyword">while</span> (!(next = fastpath(head-&gt;do_next))) &#123;</span><br><span class="line">                    dispatch_hardware_pause();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">dispatch_queue_t</span> dsn_queue = (<span class="keyword">dispatch_queue_t</span>)head-&gt;dc_data;</span><br><span class="line">            dc = _dispatch_continuation_free_cacheonly(head);</span><br><span class="line">            <span class="comment">//执行dispatch_group_notify的block，见dispatch_queue的分析</span></span><br><span class="line">            dispatch_async_f(dsn_queue, head-&gt;dc_ctxt, head-&gt;dc_func);</span><br><span class="line">            _dispatch_release(dsn_queue);</span><br><span class="line">            <span class="keyword">if</span> (slowpath(dc)) &#123;</span><br><span class="line">                _dispatch_continuation_free_to_cache_limit(dc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> ((head = next));</span><br><span class="line">        _dispatch_release(dsema);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatch_group_wake</code>首先会循环调用<code>semaphore_signal</code>唤醒等待group的信号量，使<code>dispatch_group_wait</code>函数中等待的线程得以唤醒；然后依次获取链表中的元素并调用<code>dispatch_async_f</code>异步执行<code>dispatch_group_notify</code>函数中注册的回调，使得notify中的block得以执行。</p>
<h3 id="4-3-8-dispatch-release"><a href="#4-3-8-dispatch-release" class="headerlink" title="4.3.8 dispatch_release"></a>4.3.8 dispatch_release</h3><p>与追加 Block 到 Dispatch Queue 时同样，Block 通过 dispatch_retain 函数持有 Dispatch Group，从而使得该 Block 属于 Dispatch Group，这样如果 Block 执行结束，该 Block 就通过 dispatch_release 函数释放持有的Dispatch Group。</p>
<p>一旦Dispatch Group使用结束，不用考虑属于该Dispatch Group的Block，立即通过dispatch_release函数释放即可。</p>
<h3 id="4-3-9-原理小结"><a href="#4-3-9-原理小结" class="headerlink" title="4.3.9 原理小结"></a>4.3.9 原理小结</h3><p>dispatch_group本质是个初始值为LONG_MAX的信号量，等待group中的任务完成其实是等待value恢复初始值。<br> <code>dispatch_group_enter </code> 和 <code>dispatch_group_leave</code> 必须成对出现：</p>
<ul>
<li>如果前者比后者多一次，则wait函数等待的线程不会被唤醒和注册notify的回调block不会执行；</li>
<li>如果后者比前者多一次，则会引起崩溃。</li>
</ul>
<h2 id="4-4-dispatch-barrier-async-变无序为有序"><a href="#4-4-dispatch-barrier-async-变无序为有序" class="headerlink" title="4.4 dispatch_barrier_async(变无序为有序)"></a>4.4 dispatch_barrier_async(变无序为有序)</h2><h3 id="4-4-1-使用"><a href="#4-4-1-使用" class="headerlink" title="4.4.1 使用"></a>4.4.1 使用</h3><p>当多线程并发读写同一个资源时，为了保证资源读写的正确性，可以用Barrier Block解决该问题。</p>
<p>Dispatch Barrier会确保队列中先于Barrier Block提交的任务都完成后再执行它，并且执行时队列不会同步执行其它任务，等Barrier Block执行完成后再开始执行其他任务。</p>
<p>代码示例如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建自定义并行队列</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;com.gcdTest.queue&quot;</span>, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;  	<span class="comment">// 第一步：执行dispatch_barrier_async之前的任务</span></span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work1&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_barrier_async</span>(queue, ^&#123;  <span class="comment">// 第二步：执行dispatch_barrier_async函数添加的任务</span></span><br><span class="line">    <span class="comment">// barrier block,可用于写操作</span></span><br><span class="line">    <span class="comment">// 确保资源更新过程中不会有其他线程读取</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work2&quot;</span>);</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123; <span class="comment">// 第三步：队列恢复为一般的动作，追加到Concurrent Dispatch Queue的处理又开始并行执行</span></span><br><span class="line">    <span class="comment">// 读操作</span></span><br><span class="line">    <span class="built_in">NSLog</span>(@<span class="string">&quot;work3&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这里有个需要注意也是官方文档上提到的一点，如果我们调用 <code>dispatch_barrier_async</code> 时将Barrier blocks提交到一个串行队列或global queue，则此函数的行为与 <code>dispatch_async()</code> 一致；</p>
<p><strong>只有将 Barrier blocks 提交到使用 DISPATCH_QUEUE_CONCURRENT 属性创建的并行queue时它才会表现的如同预期。</strong></p>
<h3 id="4-4-2-原理"><a href="#4-4-2-原理" class="headerlink" title="4.4.2 原理"></a>4.4.2 原理</h3><p><code>dispatch_barrier_async</code>是开发中解决多线程读写同一个资源比较好的方案，接下来看一下它的实现。<br>该函数封装调用了<code>dispatch_barrier_async_f</code>，它和dispatch_async_f类似，不同点在于vtable多了DISPATCH_OBJ_BARRIER_BIT标志位。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_barrier_async_f</span><span class="params">(<span class="keyword">dispatch_queue_t</span> dq, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc;</span><br><span class="line">    dc = <span class="built_in">fastpath</span>(_dispatch_continuation_alloc_cacheonly());</span><br><span class="line">    <span class="keyword">if</span> (!dc) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_async_f_slow(dq, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置do_vtable的标志位，从队列中取任务时会用到</span></span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line"></span><br><span class="line">    _dispatch_queue_push(dq, dc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatch_barrier_async</code>如果传入的是global queue，在唤醒队列时会执行<code>_dispatch_queue_wakeup_global</code>函数，故执行效果同<code>dispatch_async</code>一致，验证了使用篇中的备注内容；<br><code>dispatch_barrier_async</code>传的queue为自定义队列时，<code>_dispatch_continuation_pop</code>参数是自定义的queue，然后在<code>_dispatch_continuation_pop</code>中执行自定义队列的dx_invoke函数，即<code>dispatch_queue_invoke</code>。它的调用栈是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">_dispatch_queue_invoke</span><br><span class="line">└──_dispatch_queue_class_invoke</span><br><span class="line">    └──dispatch_queue_invoke2</span><br><span class="line">        └──_dispatch_queue_drain</span><br></pre></td></tr></table></figure>

<p>重点看一下_dispatch_queue_drain函数，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">_dispatch_thread_semaphore_t</span> _dispatch_queue_drain(<span class="keyword">dispatch_object_t</span> dou) &#123;</span><br><span class="line">    <span class="keyword">dispatch_queue_t</span> dq = dou._dq, orig_tq, old_dq;</span><br><span class="line">    old_dq = _dispatch_thread_getspecific(dispatch_queue_key);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_object_s</span> *<span class="title">dc</span>, *<span class="title">next_dc</span>;</span></span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema = <span class="number">0</span>;</span><br><span class="line">    orig_tq = dq-&gt;do_targetq;</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, dq);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (dq-&gt;dq_items_tail) &#123;</span><br><span class="line">        dc = _dispatch_queue_head(dq);</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">DISPATCH_OBJECT_SUSPENDED</span>(dq)) &#123;</span><br><span class="line">               <span class="comment">//barrier block执行时修改了do_suspend_cnt导致此时为YES</span></span><br><span class="line">               <span class="comment">//保证barrier block执行时其他block不会同时执行</span></span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dq-&gt;dq_running &gt; dq-&gt;dq_width) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">bool</span> redirect = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">fastpath</span>(dq-&gt;dq_width == <span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!<span class="built_in">DISPATCH_OBJ_IS_VTABLE</span>(dc) &amp;&amp;</span><br><span class="line">                        (<span class="keyword">long</span>)dc-&gt;do_vtable &amp; DISPATCH_OBJ_BARRIER_BIT) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (dq-&gt;dq_running &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">goto</span> out;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    redirect = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            next_dc = _dispatch_queue_next(dq, dc);</span><br><span class="line">            <span class="keyword">if</span> (redirect) &#123;</span><br><span class="line">                _dispatch_continuation_redirect(dq, dc);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//barrier block之前的block已经执行完，开始执行barrier block</span></span><br><span class="line">            <span class="keyword">if</span> ((sema = _dispatch_barrier_sync_f_pop(dq, dc, <span class="literal">true</span>))) &#123;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">            _dispatch_continuation_pop(dc);</span><br><span class="line">            _dispatch_perfmon_workitem_inc();</span><br><span class="line">        &#125; <span class="keyword">while</span> ((dc = next_dc));</span><br><span class="line">    &#125;</span><br><span class="line">out:</span><br><span class="line">    _dispatch_thread_setspecific(dispatch_queue_key, old_dq);</span><br><span class="line">    <span class="keyword">return</span> sema;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在while循环中依次取出任务并调用<code>_dispatch_continuation_redirect</code>函数，使得block并发执行。当遇到DISPATCH_OBJ_BARRIER_BIT标记时，会修改do_suspend_cnt标志以保证后续while循环时直接goto out。barrier block的任务执行完之后<code>_dispatch_queue_class_invoke</code>会将do_suspend_cnt重置回去，所以barrier block之后的任务会继续执行。</p>
<p><code>dispatch_barrier_async</code>的流程见下图：</p>
<img src="/images/GCD/dispatch_queue-8.png" alt="img" style="zoom:80%;" />

<h2 id="4-5-dispatch-apply"><a href="#4-5-dispatch-apply" class="headerlink" title="4.5 dispatch_apply"></a>4.5 dispatch_apply</h2><p>dispatch_apply 函数是 dispatch_sync 函数和 Dispatch Group 的关联 API。该函数 <strong>按指定的次数</strong> 将指定的Block追加到指定的队列中，并等待全部处理执行结束。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1：重复次数</span></span><br><span class="line"><span class="comment"> * 参数2：执行队列</span></span><br><span class="line"><span class="comment"> * 参数3：任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatch_get_global_queue</span>(DISPATCH_QUEUE_PRORITY_DEFAULT,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">dispatch_apply</span>(<span class="number">10</span>, queue, ^(<span class="keyword">size_t</span> index)&#123;</span><br><span class="line">   <span class="built_in">NSLog</span>(@<span class="string">&quot;%zu&quot;</span>,index);</span><br><span class="line">&#125;);</span><br><span class="line">NSLog（@<span class="string">&quot;done&quot;</span>）;</span><br></pre></td></tr></table></figure>

<ul>
<li>Global Dispatch Queue中执行，所以各个处理的执行时间不定，但是输出结果的最后必定是done，这是因为dispatch_apply函数会等待全部处理执行结束。</li>
<li>dispatch_apply和dispatch_sync函数一样，会等待处理执行结束，因此推荐在dispatch_async函数中非同步的执行dispatch_apply函数<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dispatch_queue_t</span> queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRORITY_DEFAULT,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Global Dispatch Queue中非同步执行</span></span><br><span class="line"><span class="built_in">dispatch_async</span>(queue, ^&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Global Dispatch Queue,等待dispatch_apply函数中全部处理执行结束</span></span><br><span class="line">    dispatch_apply([array count], queue, ^(size_t index)&#123;   </span><br><span class="line">  </span><br><span class="line">      <span class="comment">//并列处理包含在NSArray对象的全部对象  index为0-10</span></span><br><span class="line">       <span class="built_in">NSLog</span>(<span class="string">@&quot;%zu ：%@&quot;</span>,index,[array objectAtIndex:index]);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//dispatch_apply函数中的处理全部执行结束</span></span><br><span class="line">   <span class="comment">//在Main Dispatch Queue中非同步执行</span></span><br><span class="line">   <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(),^&#123;</span><br><span class="line">   </span><br><span class="line">     <span class="comment">//在Main Dispatch Queue中执行处理</span></span><br><span class="line">     <span class="built_in">NSLog</span>（<span class="string">@&quot;done&quot;</span>）;</span><br><span class="line">  &#125;);</span><br><span class="line">  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="4-6-dispatch-suspend-dispatch-resume"><a href="#4-6-dispatch-suspend-dispatch-resume" class="headerlink" title="4.6 dispatch_suspend/dispatch_resume"></a>4.6 dispatch_suspend/dispatch_resume</h2><p>队列的挂起与恢复</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dispatch_suspend函数挂起指定的Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_suspend</span>(queue)</span><br><span class="line"><span class="comment">//dispatch_suspend函数恢复指定的Dispatch Queue</span></span><br><span class="line"><span class="built_in">dispatch_resume</span>(queue)</span><br></pre></td></tr></table></figure>

<p>函数<strong>对已经执行的处理没有影响</strong>。</p>
<ul>
<li>挂起后，追加到Dispatch Queue中但尚未执行的处理，在此之后停止执行</li>
<li>恢复后使得这些处理能继续执行</li>
</ul>
<h2 id="4-7-dispatch-once"><a href="#4-7-dispatch-once" class="headerlink" title="4.7 dispatch_once"></a>4.7 dispatch_once</h2><p>dispatch_once函数时保证在应用程序执行中只执行一次指定处理的API，即使同时多线程调用也是<strong>线程安全</strong>的。</p>
<p>常用于创建单例、swizzeld method等功能。</p>
<h3 id="4-7-1-API介绍"><a href="#4-7-1-API介绍" class="headerlink" title="4.7.1 API介绍"></a>4.7.1 API介绍</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">dispatch_once_t</span> onceToken;</span><br><span class="line"><span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">    <span class="comment">//创建单例、method swizzled或其他任务</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="4-7-2-原理"><a href="#4-7-2-原理" class="headerlink" title="4.7.2 原理"></a>4.7.2 原理</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用dispatch_once_f来处理</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">dispatch_block_t</span> block)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">dispatch_once_f</span>(val, block, _dispatch_Block_invoke(block));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dispatch_once</code>封装调用了<code>dispatch_once_f</code>函数，其中通过_dispatch_Block_invoke来执行block任务，它的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//invoke是指触发block的具体实现，感兴趣的可以看一下Block_layout的结构体</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _dispatch_Block_invoke(bb) \</span></span><br><span class="line">        ((<span class="keyword">dispatch_function_t</span>)((struct Block_layout *)bb)-&gt;invoke)</span><br></pre></td></tr></table></figure>

<p>接着看一下具体的实现函数<code>dispatch_once_f</code>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_once_f</span><span class="params">(<span class="keyword">dispatch_once_t</span> *val, <span class="keyword">void</span> *ctxt, <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> * <span class="title">volatile</span> *<span class="title">vval</span> =</span></span><br><span class="line">            (struct _dispatch_once_waiter_s**)val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> <span class="title">dow</span> =</span> &#123; <span class="literal">NULL</span>, <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">dispatch_once_waiter_s</span> *<span class="title">tail</span>, *<span class="title">tmp</span>;</span></span><br><span class="line">    <span class="keyword">_dispatch_thread_semaphore_t</span> sema;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">dispatch_atomic_cmpxchg</span>(vval, <span class="literal">NULL</span>, &amp;dow, acquire)) &#123;</span><br><span class="line">        _dispatch_client_callout(ctxt, func);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dispatch_atomic_maximally_synchronizing_barrier</span>();</span><br><span class="line">        <span class="comment">// above assumed to contain release barrier</span></span><br><span class="line">        tmp = <span class="built_in">dispatch_atomic_xchg</span>(vval, DISPATCH_ONCE_DONE, relaxed);</span><br><span class="line">        tail = &amp;dow;</span><br><span class="line">        <span class="keyword">while</span> (tail != tmp) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!tmp-&gt;dow_next) &#123;</span><br><span class="line">                <span class="built_in">dispatch_hardware_pause</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            sema = tmp-&gt;dow_sema;</span><br><span class="line">            tmp = (struct _dispatch_once_waiter_s*)tmp-&gt;dow_next;</span><br><span class="line">            _dispatch_thread_semaphore_signal(sema);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dow.dow_sema = _dispatch_get_thread_semaphore();</span><br><span class="line">        tmp = *vval;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (tmp == DISPATCH_ONCE_DONE) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">dispatch_atomic_cmpxchgvw</span>(vval, tmp, &amp;dow, &amp;tmp, release)) &#123;</span><br><span class="line">                dow.dow_next = tmp;</span><br><span class="line">                _dispatch_thread_semaphore_wait(dow.dow_sema);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        _dispatch_put_thread_semaphore(dow.dow_sema);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由上面的代码可知<code>dispatch_once</code>的流程图大致如下：</p>
<img src="/images/GCD/dispatch_once.png" alt="img" style="zoom:80%;" />

<p>首先看一下<code>dispatch_once</code>中用的的原子性操作<code>dispatch_atomic_cmpxchg(vval, NULL, &amp;dow, acquire)</code>，它的宏定义展开之后会将$dow赋值给vval，如果vval的初始值为NULL，返回YES,否则返回NO。</p>
<p>接着结合上面的流程图来看下<code>dispatch_once</code>的代码逻辑：</p>
<p>首次调用<code>dispatch_once</code>时，因为外部传入的dispatch_once_t变量值为nil，故vval会为NULL，故if判断成立。然后调用<code>_dispatch_client_callout</code>执行block，然后在block执行完成之后将vval的值更新成<code>DISPATCH_ONCE_DONE</code>表示任务已完成。最后遍历链表的节点并调用<code>_dispatch_thread_semaphore_signal</code>来唤醒等待中的信号量；</p>
<p>当其他线程同时也调用<code>dispatch_once</code>时，因为if判断是原子性操作，故只有一个线程进入到if分支中，其他线程会进入else分支。在else分支中会判断block是否已完成，如果已完成则跳出循环；否则就是更新链表并调用<code>_dispatch_thread_semaphore_wait</code>阻塞线程，等待if分支中的block完成后再唤醒当前等待的线程。</p>
<h3 id="4-7-3-总结"><a href="#4-7-3-总结" class="headerlink" title="4.7.3 总结"></a>4.7.3 总结</h3><p><code>dispatch_once</code>用原子性操作block执行完成标记位，同时用信号量确保只有一个线程执行block，等block执行完再唤醒所有等待中的线程。</p>
<p><code>dispatch_once</code>常被用于创建单例、swizzeld method等功能。</p>
<h2 id="4-8-Dispatch-I-O与Dispatch-Data对象"><a href="#4-8-Dispatch-I-O与Dispatch-Data对象" class="headerlink" title="4.8 Dispatch I/O与Dispatch Data对象"></a>4.8 Dispatch I/O与Dispatch Data对象</h2><p>通过 Dispatch I/O 读写文件，使用 Global Dispatch Queue 将一个文件按大小 read/write。提升读取、写入速度</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建队列</span></span><br><span class="line">pipe_q = <span class="built_in">dispatch_queue_create</span>(<span class="string">&quot;PipeQ&quot;</span>,<span class="literal">NULL</span>);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建Dispatch I/O对象</span></span><br><span class="line">pipe_channel = <span class="built_in">dispatch_io_create</span>(DISPATCH_IO_STREAM,fd,pipe_q,^(<span class="keyword">int</span> err)&#123;</span><br><span class="line">   <span class="built_in">close</span>(fd);   <span class="comment">//发生错误时执行</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">*out_fd = fdpair[i];</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一次读取的最大字节</span></span><br><span class="line"><span class="built_in">dispatch_io_set_high_water</span>(pipe_channel, SIZE_MIN);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置一次读取的最小字节</span></span><br><span class="line"><span class="built_in">dispatch_io_set_low_water</span>(pipe_channel, SIZE_MAX);</span><br><span class="line"> </span><br><span class="line"><span class="comment">//开始异步读取</span></span><br><span class="line"><span class="built_in">dispatch_io_read</span>(pipe_channel,<span class="number">0</span>,SIZE_MAX,pipe_q, ^(<span class="keyword">bool</span> done,<span class="keyword">dispatch_data_t</span> pipe data,<span class="keyword">int</span> err)&#123;</span><br><span class="line"><span class="comment">//每当各个分割的文件快读取结束时，将含有文件块数据的Dispatch Data传递给dispatch_io_read函数指定的读取结束时回调用的Block。回调用的Block分析传递过来的Dispatch Data并进行结合处理</span></span><br><span class="line">    <span class="keyword">if</span>(err == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">size_t</span> len = <span class="built_in">dispatch_data_get_size</span>(pipe data);</span><br><span class="line">        <span class="keyword">if</span>(len &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *bytes = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">char</span> *encoded;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">dispatch_data_t</span> md = <span class="built_in">dispatch_data_create_map</span>(pipe data, (<span class="keyword">const</span> <span class="keyword">void</span> **)&amp;bytes, &amp;len);</span><br><span class="line">            <span class="built_in">asl_set</span>((aslmsg)merged_msg, ASL_KEY_AUX_DATA, encoded);</span><br><span class="line">            <span class="built_in">free</span>(encoded);</span><br><span class="line">            _asl_send_message(<span class="literal">NULL</span>, merged_msg, <span class="number">-1</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="built_in">asl_msg_release</span>(merged_msg);</span><br><span class="line">            <span class="built_in">dispatch_release</span>(md);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(done)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">dispatch_semaphore_signal</span>(sem);</span><br><span class="line">       <span class="built_in">dispatch_release</span>(pipe_channel);</span><br><span class="line">       <span class="built_in">dispatch_release</span>(pipe_q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="4-9-dispatch-source"><a href="#4-9-dispatch-source" class="headerlink" title="4.9 dispatch_source"></a>4.9 dispatch_source</h2><p>GCD中除了主要的Dispatch Queue外，还有不太引人注目的Dispatch Source。它是BSD系内核惯有功能<strong>kqueue的包装</strong>。</p>
<p>kqueue是XNU内核中发生各种事件时，在应用程序编程方执行处理的技术。其CPU负荷非常小，尽量不占用资源。kqueue可以说是应用程序处理XNU内核中发生的各种事件的方法中最优秀的一种。</p>
<p>Dispatch Source可处理以下事件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DISPATCH_SOURCE_TYPE_DATA_ADD   <span class="comment">// 变量增加</span></span><br><span class="line">DISPATCH_SOURCE_TYPE_DATA_OR    <span class="comment">// 变量OR</span></span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_SEND  <span class="comment">// MACH端口发送</span></span><br><span class="line">DISPATCH_SOURCE_TYPE_MACH_RECV  <span class="comment">// MACH端口接收</span></span><br><span class="line">DISPATCH_SOURCE_TYPE_PROC       <span class="comment">// 检测到与进程相关的事件</span></span><br><span class="line">DISPATCH_SOURCE_TYPE_READ       <span class="comment">// 可读取文件映像</span></span><br><span class="line">DISPATCH_SOURCE_TYPE_SIGNAL     <span class="comment">// 接收信号</span></span><br><span class="line">DISPATCH_SOURCE_TYPE_TIMER      <span class="comment">// 定时器</span></span><br><span class="line">DISPATCH_SOURCE_TYPE_VNODE      <span class="comment">// 文件系统有变更</span></span><br><span class="line">DISPATCH_SOURCE_TYPE_WRITE      <span class="comment">// 可写入文件映像</span></span><br></pre></td></tr></table></figure>

<p>当事件发生时，Dispatch Source会在指定的Dispatch Queue中执行事件的处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_queue_t</span> queue = <span class="built_in">dispatc_get_global_queue</span>(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  基于READ事件作成Dispatch Source</span></span><br><span class="line"><span class="comment"> */</span>  </span><br><span class="line"><span class="keyword">dispatch_source_t</span> source = <span class="built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_READ, sockfd, <span class="number">0</span> , queuq);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定发生READ事件时执行的处理 */</span>    </span><br><span class="line"><span class="built_in">dispatch_source_set_event_handler</span>(source, ^&#123;</span><br><span class="line">    <span class="comment">// 处理结束，取消Dispatch Source</span></span><br><span class="line">    <span class="built_in">dispatch_source_cancel</span>(source);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 指定取消Dispatch Source时的处理 */</span></span><br><span class="line"><span class="built_in">dispatch_source_set_cancel_handler</span>(source, ^&#123;</span><br><span class="line">    <span class="comment">/* 释放Dispatch Source(自身) */</span></span><br><span class="line">    <span class="built_in">dispatch_release</span>(source);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 启动Dispatch Source */</span></span><br><span class="line"><span class="built_in">dispatch_resume</span>(source);</span><br></pre></td></tr></table></figure>

<p>与上面代码非常相似的代码，使用在了Core Foundation框架的用于异步网络的<code>API CFSocket</code>中。因为<strong>Foundation框架的异步网络API是通过CFSocket实现</strong>的，所以可享受到仅使用Foundation框架的Dispatch Source(即GCD)带来的好处。</p>
<p>一旦将任务追加到Dispatch Queue中，就没有办法将任务取消，也没有办法在执行中取消任务。Dispatch Source是可以取消的，而且取消时的处理可以block的形式作为参数配置。<strong>在必须使用kqueue的情况下，推荐大家使用Dispatch Source，比较简单</strong>。</p>
<h3 id="4-9-1-kqueue"><a href="#4-9-1-kqueue" class="headerlink" title="4.9.1 kqueue"></a>4.9.1 kqueue</h3><p>kqueue是IO多路复用在BSD系统中的一种实现，它的接口主要包括 kqueue()、kevent() 两个系统调用和 struct kevent 结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// kqueue() 生成一个内核事件队列，返回该队列的文件描述符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kqueue</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// kevent() 提供向内核注册/反注册事件和返回就绪事件或错误事件。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kevent</span><span class="params">(<span class="keyword">int</span> kq, </span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">const</span> struct kevent *changelist, <span class="keyword">int</span> nchanges,</span></span></span><br><span class="line"><span class="function"><span class="params">         struct kevent *eventlist, <span class="keyword">int</span> nevents,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">const</span> struct timespec *timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// struct kevent 就是kevent()操作的最基本的事件结构。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kevent</span> &#123;</span> </span><br><span class="line">     <span class="keyword">uintptr_t</span> ident;        <span class="comment">/* 事件 ID */</span> </span><br><span class="line">     <span class="keyword">short</span>     filter;       <span class="comment">/* 事件过滤器 */</span> </span><br><span class="line">     u_short   flags;        <span class="comment">/* 行为标识 */</span> </span><br><span class="line">     u_int     fflags;       <span class="comment">/* 过滤器标识值 */</span> </span><br><span class="line">     <span class="keyword">intptr_t</span>  data;         <span class="comment">/* 过滤器数据 */</span> </span><br><span class="line">     <span class="keyword">void</span>      *udata;       <span class="comment">/* 应用透传数据 */</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在一个 kqueue 中，{ident, filter} 确定一个唯一的事件：</p>
<ul>
<li><p>ident 事件的 id，一般设置为文件描述符。</p>
</li>
<li><p>filter 可以将 kqueue filter 看作事件。内核检测 ident 上注册的 filter 的状态，状态发生了变化，就通知应用程序。kqueue 定义了较多的 filter：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVFILT_READ         (-1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVFILT_WRITE        (-2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVFILT_AIO          (-3)    <span class="comment">/* attached to aio requests */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVFILT_VNODE        (-4)    <span class="comment">/* attached to vnodes */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVFILT_PROC         (-5)    <span class="comment">/* attached to struct proc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVFILT_SIGNAL       (-6)    <span class="comment">/* attached to struct proc */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVFILT_TIMER        (-7)    <span class="comment">/* timers */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVFILT_MACHPORT     (-8)    <span class="comment">/* Mach portsets */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVFILT_FS           (-9)    <span class="comment">/* Filesystem events */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EVFILT_USER         (-10)   <span class="comment">/* User events */</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>行为标志flags：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ADD              0x0001      <span class="comment">/* add event to kq (implies enable) */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_DELETE           0x0002      <span class="comment">/* delete event from kq */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ENABLE           0x0004      <span class="comment">/* enable event */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_DISABLE          0x0008      <span class="comment">/* disable event (not reported) */</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-9-2-使用示例：定时器"><a href="#4-9-2-使用示例：定时器" class="headerlink" title="4.9.2 使用示例：定时器"></a>4.9.2 使用示例：定时器</h3><p>在使用定时器时，NSTimer是首先被想到的，但是由于NSTimer会受RunLoop影响，当RunLoop处理的任务很多时，就会导致NSTimer的精度降低，所以在一些对定时器精度要求很高的情况下，我们会考虑CADisplaylink，但是实际上也可以考虑使用GCD定时器。</p>
<p>dispatch_source最常见的用法就是用来实现定时器，代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dispatch_source_t</span> source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, dispatch_get_main_queue());</span><br><span class="line">dispatch_source_set_timer(source, dispatch_time(DISPATCH_TIME_NOW, <span class="number">0</span>), <span class="number">3</span> * NSEC_PER_SEC, <span class="number">0</span>);</span><br><span class="line">dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">    <span class="comment">//定时器触发时执行</span></span><br><span class="line">   NSLog(@<span class="string">&quot;timer响应了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//启动timer</span></span><br><span class="line">dispatch_resume(source);</span><br></pre></td></tr></table></figure>

<p><code>Dispatch Source</code>定时器的代码看似很简单，但其实是GCD中坑最多的API了，如果处理不好很容易引起Crash。关于<code>Dispatch Source</code>定时器需要注意的知识点请参考文章最后的总结篇。</p>
<h3 id="4-9-3-常用API"><a href="#4-9-3-常用API" class="headerlink" title="4.9.3 常用API"></a>4.9.3 常用API</h3><h4 id="1-dispatch-source-create"><a href="#1-dispatch-source-create" class="headerlink" title="1. dispatch_source_create"></a>1. dispatch_source_create</h4><p><code>dispatch_source_create</code>函数用来创建dispatch_source_t对象，简化后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">dispatch_source_t</span> <span class="title">dispatch_source_create</span><span class="params">(<span class="keyword">dispatch_source_type_t</span> type,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">uintptr_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">long</span> mask,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">dispatch_queue_t</span> q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//申请内存空间</span></span><br><span class="line">    ds = _dispatch_alloc(DISPATCH_VTABLE(source),</span><br><span class="line">            <span class="keyword">sizeof</span>(struct dispatch_source_s));</span><br><span class="line">    <span class="comment">//初始化ds</span></span><br><span class="line">    _dispatch_queue_init((<span class="keyword">dispatch_queue_t</span>)ds);</span><br><span class="line">    ds-&gt;dq_label = <span class="string">&quot;source&quot;</span>;</span><br><span class="line"></span><br><span class="line">    ds-&gt;do_ref_cnt++; <span class="comment">// the reference the manager queue holds</span></span><br><span class="line">    ds-&gt;do_ref_cnt++; <span class="comment">// since source is created suspended</span></span><br><span class="line">    <span class="comment">//默认处于暂状态，需要手动调用resume</span></span><br><span class="line">    ds-&gt;do_suspend_cnt = DISPATCH_OBJECT_SUSPEND_INTERVAL;</span><br><span class="line">    ds-&gt;do_targetq = &amp;_dispatch_mgr_q;</span><br><span class="line">    <span class="comment">// First item on the queue sets the user-specified target queue</span></span><br><span class="line">    <span class="comment">//设置事件回调的队列</span></span><br><span class="line">    dispatch_set_target_queue(ds, q);</span><br><span class="line">    _dispatch_object_debug(ds, <span class="string">&quot;%s&quot;</span>, __func__);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-dispatch-source-set-timer"><a href="#2-dispatch-source-set-timer" class="headerlink" title="2. dispatch_source_set_timer"></a>2. dispatch_source_set_timer</h4><p>dispatch_source_set_timer实际上调用了_dispatch_source_set_timer，看一下代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * start计时器起始时间，可以通过dispatch_time创建，如果使用DISPATCH_TIME_NOW，则创建后立即执行</span></span><br><span class="line"><span class="comment"> * interval计时器间隔时间，可以通过timeInterval * NSEC_PER_SEC来设置，其中，timeInterval为对应的秒数</span></span><br><span class="line"><span class="comment"> * leeway这个参数的理解，我觉得网上有处解释很直观也很易懂：“这个参数告诉系统我们需要计时器触发的精准程度。所有的计时器都不会保证100%精准，这个参数用来告诉系统你希望系统保证精准的努力程度。如果你希望一个计时器没五秒触发一次，并且越准越好，那么你传递0为参数。另外，如果是一个周期性任务，比如检查email，那么你会希望每十分钟检查一次，但是不用那么精准。所以你可以传入60，告诉系统60秒的误差是可接受的。这样有什么意义呢？简单来说，就是降低资源消耗。如果系统可以让cpu休息足够长的时间，并在每次醒来的时候执行一个任务集合，而不是不断的醒来睡去以执行任务，那么系统会更高效。如果传入一个比较大的leeway给你的计时器，意味着你允许系统拖延你的计时器来将计时器任务与其他任务联合起来一起执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> _dispatch_source_set_timer(<span class="keyword">dispatch_source_t</span> ds, </span><br><span class="line">                                              <span class="keyword">dispatch_time_t</span> start,</span><br><span class="line">                                              <span class="keyword">uint64_t</span> interval, </span><br><span class="line">                                              <span class="keyword">uint64_t</span> leeway, </span><br><span class="line">                                              <span class="keyword">bool</span> source_sync) &#123;</span><br><span class="line">    <span class="comment">//首先屏蔽非timer类型的source</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(!ds-&gt;ds_is_timer) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">ds_timer</span>(ds-&gt;ds_refs).flags &amp; DISPATCH_TIMER_INTERVAL)) &#123;</span><br><span class="line">        <span class="built_in">DISPATCH_CLIENT_CRASH</span>(<span class="string">&quot;Attempt to set timer on a non-timer source&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建dispatch_set_timer_params结构体绑定source和timer参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span>;</span></span><br><span class="line">    params = _dispatch_source_timer_params(ds, start, interval, leeway);</span><br><span class="line">    _dispatch_source_timer_telemetry(ds, params-&gt;ident, &amp;params-&gt;values);</span><br><span class="line">    <span class="built_in">dispatch_retain</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (source_sync) &#123;</span><br><span class="line">       <span class="comment">//将source当做队列使用，执行dispatch_barrier_async_f压入队列，</span></span><br><span class="line">       <span class="comment">//核心函数为_dispatch_source_set_timer2</span></span><br><span class="line">        <span class="keyword">return</span> _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, params,</span><br><span class="line">                _dispatch_source_set_timer2);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_source_set_timer2(params);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_source_set_timer</code>实际上是调用了<code>_dispatch_source_set_timer2</code>函数:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_timer2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="comment">// Called on the source queue</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span> =</span> context;</span><br><span class="line">    <span class="comment">//暂停队列，避免修改过程中定时器被触发了。</span></span><br><span class="line">    <span class="built_in">dispatch_suspend</span>(params-&gt;ds);</span><br><span class="line">    <span class="comment">//在_dispatch_mgr_q队列上执行_dispatch_source_set_timer3(params)</span></span><br><span class="line">    <span class="built_in">dispatch_barrier_async_f</span>(&amp;_dispatch_mgr_q, params,</span><br><span class="line">            _dispatch_source_set_timer3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>_dispatch_source_set_timer2</code>函数的逻辑是在_dispatch_mgr_q队列执行<code>_dispatch_source_set_timer3(params)</code>，接下来的逻辑如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_timer3(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="comment">// Called on the _dispatch_mgr_q</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dispatch_set_timer_params</span> *<span class="title">params</span> =</span> context;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = params-&gt;ds;</span><br><span class="line">    ds-&gt;ds_ident_hack = params-&gt;ident;</span><br><span class="line">    <span class="built_in">ds_timer</span>(ds-&gt;ds_refs) = params-&gt;values;</span><br><span class="line">    ds-&gt;ds_pending_data = <span class="number">0</span>;</span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_or2o</span>(ds, ds_atomic_flags, DSF_ARMED, release);</span><br><span class="line">    <span class="comment">//恢复队列，对应着_dispatch_source_set_timer2函数中的dispatch_suspend</span></span><br><span class="line">    <span class="built_in">dispatch_resume</span>(ds);</span><br><span class="line">    <span class="comment">// Must happen after resume to avoid getting disarmed due to suspension</span></span><br><span class="line">    <span class="comment">//根据下一次触发时间将timer进行排序</span></span><br><span class="line">    _dispatch_timers_update(ds);</span><br><span class="line">    <span class="built_in">dispatch_release</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (params-&gt;values.flags &amp; DISPATCH_TIMER_WALL_CLOCK) &#123;</span><br><span class="line">        _dispatch_mach_host_calendar_change_register();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当执行提交到_dispatch_mgr_q队列的block时，会调用&amp;_dispatch_mgr_q-&gt;do_invoke函数，即&amp;_dispatch_mgr_q的vtable中定义的<code>_dispatch_mgr_thread</code>。接下来会走到<code>_dispatch_mgr_invoke</code>函数。在这个函数里用I/O多路复用功能的select来实现定时器功能:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">r = <span class="built_in">select</span>(FD_SETSIZE, &amp;tmp_rfds, &amp;tmp_wfds, <span class="literal">NULL</span>,</span><br><span class="line">            poll ? (struct timeval*)&amp;timeout_immediately : <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>当内层的 <code>_dispatch_mgr_q</code> 队列被唤醒后，还会进一步唤醒外层的队列(当初用户指定的那个)，并在指定队列上执行 timer 触发时的 block。</p>
<h4 id="3-dispatch-source-set-event-handler"><a href="#3-dispatch-source-set-event-handler" class="headerlink" title="3. dispatch_source_set_event_handler"></a>3. dispatch_source_set_event_handler</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_source_set_event_handler</span><span class="params">(<span class="keyword">dispatch_source_t</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_block_t</span> handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将block进行copy后压入到队列中</span></span><br><span class="line">    handler = _dispatch_Block_copy(handler);</span><br><span class="line">    _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, handler,</span><br><span class="line">            _dispatch_source_set_event_handler2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_event_handler2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = (<span class="keyword">dispatch_source_t</span>)_dispatch_queue_get_current();</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(<span class="built_in">dx_type</span>(ds) == DISPATCH_SOURCE_KEVENT_TYPE);</span><br><span class="line">    <span class="keyword">dispatch_source_refs_t</span> dr = ds-&gt;ds_refs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ds-&gt;ds_handler_is_block &amp;&amp; dr-&gt;ds_handler_ctxt) &#123;</span><br><span class="line">        <span class="built_in">Block_release</span>(dr-&gt;ds_handler_ctxt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置上下文，保存提交的block等信息</span></span><br><span class="line">    dr-&gt;ds_handler_func = context ? _dispatch_Block_invoke(context) : <span class="literal">NULL</span>;</span><br><span class="line">    dr-&gt;ds_handler_ctxt = context;</span><br><span class="line">    ds-&gt;ds_handler_is_block = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-dispatch-source-set-cancel-handler"><a href="#4-dispatch-source-set-cancel-handler" class="headerlink" title="4. dispatch_source_set_cancel_handler"></a>4. dispatch_source_set_cancel_handler</h4><p><code>dispatch_source_set_cancel_handler</code>与<code>dispatch_source_set_event_handler</code>功能类似，保存一下取消事件处理的上下文信息。代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_source_set_cancel_handler</span><span class="params">(<span class="keyword">dispatch_source_t</span> ds,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">dispatch_block_t</span> handler)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将block进行copy后压入到队列中</span></span><br><span class="line">    handler = _dispatch_Block_copy(handler);</span><br><span class="line">    _dispatch_barrier_trysync_f((<span class="keyword">dispatch_queue_t</span>)ds, handler,</span><br><span class="line">            _dispatch_source_set_cancel_handler2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> _dispatch_source_set_cancel_handler2(<span class="keyword">void</span> *context) &#123;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = (<span class="keyword">dispatch_source_t</span>)_dispatch_queue_get_current();</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(<span class="built_in">dx_type</span>(ds) == DISPATCH_SOURCE_KEVENT_TYPE);</span><br><span class="line">    <span class="keyword">dispatch_source_refs_t</span> dr = ds-&gt;ds_refs;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ds-&gt;ds_cancel_is_block &amp;&amp; dr-&gt;ds_cancel_handler) &#123;</span><br><span class="line">        <span class="built_in">Block_release</span>(dr-&gt;ds_cancel_handler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存事件取消的信息</span></span><br><span class="line">    dr-&gt;ds_cancel_handler = context;</span><br><span class="line">    ds-&gt;ds_cancel_is_block = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-dispatch-resume-dispatch-suspend"><a href="#5-dispatch-resume-dispatch-suspend" class="headerlink" title="5. dispatch_resume/dispatch_suspend"></a>5. dispatch_resume/dispatch_suspend</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//恢复</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_resume</span><span class="params">(<span class="keyword">dispatch_object_t</span> dou)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DISPATCH_OBJECT_TFB</span>(_dispatch_objc_resume, dou);</span><br><span class="line">    <span class="comment">// Global objects cannot be suspended or resumed.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">dx_type</span>(dou._do) == DISPATCH_QUEUE_ROOT_TYPE)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将do_suspend_cnt原子性减二，并返回之前存储的值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> suspend_cnt = <span class="built_in">dispatch_atomic_sub_orig2o</span>(dou._do,</span><br><span class="line">             do_suspend_cnt, DISPATCH_OBJECT_SUSPEND_INTERVAL, relaxed);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(suspend_cnt &gt; DISPATCH_OBJECT_SUSPEND_INTERVAL)) &#123;</span><br><span class="line">        <span class="keyword">return</span> _dispatch_release(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">fastpath</span>(suspend_cnt == DISPATCH_OBJECT_SUSPEND_INTERVAL)) &#123;</span><br><span class="line">        _dispatch_wakeup(dou._do);</span><br><span class="line">     <span class="keyword">return</span> _dispatch_release(dou._do);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DISPATCH_CLIENT_CRASH</span>(<span class="string">&quot;Over-resume of an object&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//暂停</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_suspend</span><span class="params">(<span class="keyword">dispatch_object_t</span> dou)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">DISPATCH_OBJECT_TFB</span>(_dispatch_objc_suspend, dou);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dou._do-&gt;do_ref_cnt == DISPATCH_OBJECT_GLOBAL_REFCNT) ||</span><br><span class="line">            <span class="built_in">slowpath</span>(<span class="built_in">dx_type</span>(dou._do) == DISPATCH_QUEUE_ROOT_TYPE)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//将do_suspend_cnt原子性加二</span></span><br><span class="line">    (<span class="keyword">void</span>)<span class="built_in">dispatch_atomic_add2o</span>(dou._do, do_suspend_cnt,</span><br><span class="line">            DISPATCH_OBJECT_SUSPEND_INTERVAL, relaxed);</span><br><span class="line">    _dispatch_retain(dou._do);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断队列是否暂停的依据是do_suspend_cnt是否大于等于2,全局队列和主队列默认都是小于2的，即处于启动状态。<br>而dispatch_source_create方法中，do_suspend_cnt初始为DISPATCH_OBJECT_SUSPEND_INTERVAL，即默认处于暂停状态，需要手动调用resume开启。<br>代码定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPEND_LOCK        1u</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPEND_INTERVAL    2u</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DISPATCH_OBJECT_SUSPENDED(x) \</span></span><br><span class="line">        ((x)-&gt;do_suspend_cnt &gt;= DISPATCH_OBJECT_SUSPEND_INTERVAL)</span><br></pre></td></tr></table></figure>

<h3 id="4-9-4-总结"><a href="#4-9-4-总结" class="headerlink" title="4.9.4 总结"></a>4.9.4 总结</h3><p>Dispatch Source使用最多的就是用来实现定时器，source创建后默认是暂停状态，需要手动调用<code>dispatch_resume</code>启动定时器。<code>dispatch_after</code>只是封装调用了dispatch source定时器，然后在回调函数中执行定义的block。</p>
<p>Dispatch Source定时器使用时也有一些需要注意的地方，不然很可能会引起crash：</p>
<ol>
<li>循环引用：因为dispatch_source_set_event_handler回调是个block，在添加到source的链表上时会执行copy并被source强引用，如果block里持有了self，self又持有了source的话，就会引起循环引用。正确的方法是使用weak+strong或者提前调用dispatch_source_cancel取消timer。</li>
<li><code>dispatch_resume</code>和<code>dispatch_suspend</code>调用次数需要平衡，如果重复调用dispatch_resume则会崩溃,因为重复调用会让<code>dispatch_resume</code>代码里if分支不成立，从而执行了DISPATCH_CLIENT_CRASH(“Over-resume of an object”)导致崩溃。</li>
<li>source在suspend状态下，如果直接设置source = nil或者重新创建source都会造成crash。正确的方式是在resume状态下调用dispatch_source_cancel(source)后再重新创建。</li>
</ol>
<h2 id="4-10-dispatch-after-延迟执行"><a href="#4-10-dispatch-after-延迟执行" class="headerlink" title="4.10 dispatch_after(延迟执行)"></a>4.10 dispatch_after(延迟执行)</h2><h3 id="4-10-1-使用"><a href="#4-10-1-使用" class="headerlink" title="4.10.1 使用"></a>4.10.1 使用</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取精确时间点</span></span><br><span class="line"><span class="comment">typedef uint64_t dispatch_time_t;</span></span><br><span class="line"><span class="comment">		#define DISPATCH_TIME_NOW (0ull)</span></span><br><span class="line"><span class="comment">		#define DISPATCH_TIME_FOREVER (~0ull)</span></span><br><span class="line"><span class="comment">* 参数1: 开始时间  DISPATCH_TIME_NOW(现在的时间)</span></span><br><span class="line"><span class="comment">* 参数2：多久后  数值和NSEC_PER_SEC的乘积得到单位为毫微秒的数值，ull是C语言的数值字面量，是显示表明类型时使用的字符串（表示‘unsigned long long’） ，NSEC_PER_MSEC表示毫秒单位</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">dispatch_time_t time = dispatch_time(DISPATCH_TIME_NOW , <span class="number">3</span>ull * <span class="built_in">NSEC_PER_SEC</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 参数1：指定时间用的dispatch_time_t类型的值，dispatch_time_t类型的值使用dispatch_time函数或者dispatch _walltime函数生成</span></span><br><span class="line"><span class="comment"> * 参数2：指定要追加处理的Dispatch Queue</span></span><br><span class="line"><span class="comment"> * 参数3：指定记述要执行处理的Block</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">dispatch_after(time , dispatch_get_main_queue(), ^&#123;</span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@&quot;waited at least three seconds &quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>dispatch_after 函数并不是在指定时间后执行处理，而只是在指定时间追加处理到 Dispatch Queue，上述代码与3秒后用 dispatch_async 函数追加 Block 到 Main Dispatch Queue 的相同。</li>
<li>因为 Main Dispatch Queue 在主线程的 RunLoop 中执行，所以在比如每隔 1/60 秒执行的 RunLoop 中，Block 最快在3秒后执行，最慢在 3秒+1/60秒 后执行，并且在 Main Dispatch Queue 有大量处理追加或主线程的处理本身有延迟是，这个时间会更长。</li>
</ul>
<p><code>dispatch_walltime</code> 函数由 POSLX 中使用的 struct timespec 类型的时间得到 dispatch _time_t 类型的值。</p>
<p><code>dispatch_time</code> 函数通常用于计算相对时间。</p>
<p><code>dispatch_walltime</code> 函数用于计算绝对时间，需要指定精确时间参数，可作为粗略的闹钟功能使用。</p>
<h3 id="4-10-2-原理"><a href="#4-10-2-原理" class="headerlink" title="4.10.2 原理"></a>4.10.2 原理</h3><p><code>dispatch_after</code>是基于Dispatch Source的定时器实现的，函数内部直接调用<code>dispatch_after_f</code>，代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatch_after_f</span><span class="params">(<span class="keyword">dispatch_time_t</span> when, <span class="keyword">dispatch_queue_t</span> queue, <span class="keyword">void</span> *ctxt,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">dispatch_function_t</span> func)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">uint64_t</span> delta, leeway;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds;</span><br><span class="line">    <span class="comment">//屏蔽DISPATCH_TIME_FOREVER类型</span></span><br><span class="line">    <span class="keyword">if</span> (when == DISPATCH_TIME_FOREVER) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DISPATCH_DEBUG</span></span><br><span class="line">        <span class="built_in">DISPATCH_CLIENT_CRASH</span>(</span><br><span class="line">                <span class="string">&quot;dispatch_after_f() called with &#x27;when&#x27; == infinity&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    delta = _dispatch_timeout(when);</span><br><span class="line">    <span class="keyword">if</span> (delta == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dispatch_async_f</span>(queue, ctxt, func);</span><br><span class="line">    &#125;</span><br><span class="line">    leeway = delta / <span class="number">10</span>; <span class="comment">// &lt;rdar://problem/13447496&gt;</span></span><br><span class="line">    <span class="keyword">if</span> (leeway &lt; NSEC_PER_MSEC) leeway = NSEC_PER_MSEC;</span><br><span class="line">    <span class="keyword">if</span> (leeway &gt; <span class="number">60</span> * NSEC_PER_SEC) leeway = <span class="number">60</span> * NSEC_PER_SEC;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// this function can and should be optimized to not use a dispatch source</span></span><br><span class="line">    <span class="comment">//创建dispatch_source</span></span><br><span class="line">    ds = <span class="built_in">dispatch_source_create</span>(DISPATCH_SOURCE_TYPE_TIMER, <span class="number">0</span>, <span class="number">0</span>, queue);</span><br><span class="line">    <span class="built_in">dispatch_assert</span>(ds);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = _dispatch_continuation_alloc();</span><br><span class="line">    dc-&gt;do_vtable = (<span class="keyword">void</span> *)(DISPATCH_OBJ_ASYNC_BIT | DISPATCH_OBJ_BARRIER_BIT);</span><br><span class="line">    dc-&gt;dc_func = func;</span><br><span class="line">    dc-&gt;dc_ctxt = ctxt;</span><br><span class="line">    dc-&gt;dc_data = ds;</span><br><span class="line">    <span class="comment">//将dispatch_continuation_t存储到上下文中</span></span><br><span class="line">    <span class="built_in">dispatch_set_context</span>(ds, dc);</span><br><span class="line">    <span class="comment">//设置timer并启动</span></span><br><span class="line">    <span class="built_in">dispatch_source_set_event_handler_f</span>(ds, _dispatch_after_timer_callback);</span><br><span class="line">    <span class="built_in">dispatch_source_set_timer</span>(ds, when, DISPATCH_TIME_FOREVER, leeway);</span><br><span class="line">    <span class="built_in">dispatch_resume</span>(ds);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>timer到时之后，会调用<code>_dispatch_after_timer_callback</code>函数，在这里取出上下文里的block并执行：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _dispatch_after_timer_callback(<span class="keyword">void</span> *ctxt) &#123;</span><br><span class="line">    <span class="keyword">dispatch_continuation_t</span> dc = ctxt, dc1;</span><br><span class="line">    <span class="keyword">dispatch_source_t</span> ds = dc-&gt;dc_data;</span><br><span class="line">    dc1 = _dispatch_continuation_free_cacheonly(dc);</span><br><span class="line">    <span class="comment">//执行任务的block并执行</span></span><br><span class="line">    _dispatch_client_callout(dc-&gt;dc_ctxt, dc-&gt;dc_func);</span><br><span class="line">    <span class="comment">//清理数据</span></span><br><span class="line">    <span class="built_in">dispatch_source_cancel</span>(ds);</span><br><span class="line">    <span class="built_in">dispatch_release</span>(ds);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">slowpath</span>(dc1)) &#123;</span><br><span class="line">        _dispatch_continuation_free_to_cache_limit(dc1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="五、参考链接"><a href="#五、参考链接" class="headerlink" title="五、参考链接"></a>五、参考链接</h1><ul>
<li><a target="_blank" rel="noopener" href="https://xiaozhuanlan.com/iOSDevNotes">iOS开发笔记 — 小专栏</a></li>
</ul>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="https://tenloy.github.io">Tenloy</a>
            <p>原文链接：<a href="https://tenloy.github.io/2020/09/11/GCD.html">https://tenloy.github.io/2020/09/11/GCD.html</a>
            <p>发表日期：2020.09.11 , 9:12 AM</p>
            <p>更新日期：2025.02.05 , 2:45 PM</p>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Crative Commons 4.0 许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2020/10/28/runtime-data-structure.html" title= "Objc Runtime总结">
                    <div class="nextTitle">Objc Runtime总结</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/09/06/oc-block.html" title= "Objective-C — Block">
                    <div class="prevTitle">Objective-C — Block</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:luotengoto@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/Tenloy" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <a href="https://www.jianshu.com/u/8db1bc12db9f" class="iconfont-jian jianshu" target="_blank" title=jianshu></a>
            
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:40vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%9F"><span class="toc-text">一、什么是多线程编程？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C"><span class="toc-text">1.1 代码的运行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%87%A0%E5%AF%B9%E6%A6%82%E5%BF%B5"><span class="toc-text">1.2 几对概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-text">1.2.1 并发和并行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-text">1.2.2 同步和异步</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E5%BC%82%E6%AD%A5-%E2%89%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.2.3 异步 ≠ 多线程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text">1.3 上下文切换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-text">1.4 多线程编程的优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-%E4%B8%BB%E7%BA%BF%E7%A8%8B"><span class="toc-text">1.5 主线程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81GCD%E7%9A%84%E6%A6%82%E8%BF%B0%E5%8F%8A%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">二、GCD的概述及基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-DISPATCH-DECL"><span class="toc-text">2.1 DISPATCH_DECL</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-fastpath-vs-slowpath"><span class="toc-text">2.2 fastpath vs slowpath</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-TSD-TLS"><span class="toc-text">2.3 TSD&#x2F;TLS</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81GCD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">三、GCD的常用数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-dispatch-object-s%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">3.1 dispatch_object_s结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-dispatch-continuation-s%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">3.2 dispatch_continuation_s结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-dispatch-object-t%E8%81%94%E5%90%88%E4%BD%93"><span class="toc-text">3.3 dispatch_object_t联合体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-4-DISPATCH-VTABLE-HEADER%E5%AE%8F"><span class="toc-text">3.4 DISPATCH_VTABLE_HEADER宏</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-5-dispatch-queue-s-%E9%98%9F%E5%88%97%E7%BB%93%E6%9E%84"><span class="toc-text">3.5 dispatch_queue_s(队列结构)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81GCD%E7%9A%84API"><span class="toc-text">四、GCD的API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-Dispatch-Queue-%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="toc-text">4.1 Dispatch Queue(调度队列)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">4.1.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-%E4%BD%BF%E7%94%A8"><span class="toc-text">4.1.2 使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-dispatch-queue-create-%E4%B8%B2%E8%A1%8C%E4%B8%8E%E5%B9%B6%E8%A1%8C"><span class="toc-text">1. dispatch_queue_create(串行与并行)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-dispatch-async%E4%B8%8Edispatch-sync-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5"><span class="toc-text">2. dispatch_async与dispatch_sync(同步与异步)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-GCD-NSOperation%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text">3. GCD&#x2F;NSOperation设置优先级</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-dispatch-set-target-queue"><span class="toc-text">4. dispatch_set_target_queue</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-%E5%AE%9E%E7%8E%B0-%E2%80%94-Root-Queue-%E4%B8%8E-%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">4.1.3 实现 — Root Queue 与 线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0"><span class="toc-text">1. 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-GCD%E7%9A%8416%E4%B8%AAroot-queue"><span class="toc-text">2. GCD的16个root queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Queue%E8%AE%BE%E5%AE%9A%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E6%95%B0%E9%87%8F"><span class="toc-text">3. Queue设定的线程池的数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E9%98%9F%E5%88%97%E4%B8%8E%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text">4. 队列与线程之间的关系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-4-%E5%AE%9E%E7%8E%B0-%E2%80%94-%E7%9B%B8%E5%85%B3API%E7%9A%84%E6%BA%90%E7%A0%81%E9%80%BB%E8%BE%91"><span class="toc-text">4.1.4 实现 — 相关API的源码逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-dispatch-get-global-queue-8%E7%A7%8D%E7%B1%BB%E5%9E%8B"><span class="toc-text">1. dispatch_get_global_queue(8种类型)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-dispatch-get-main-queue"><span class="toc-text">2. dispatch_get_main_queue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-dispatch-queue-create"><span class="toc-text">3. dispatch_queue_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-dispatch-async"><span class="toc-text">4. dispatch_async</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-dispatch-sync"><span class="toc-text">5. dispatch_sync</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-5-Dispatch-Quene%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.1.5 Dispatch Quene机制的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Dispatch-Quene%E5%AE%9E%E7%8E%B0%E6%89%80%E9%9C%80"><span class="toc-text">1. Dispatch Quene实现所需</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">2. 执行上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-Dispatch-Queue%E6%89%A7%E8%A1%8CBlock%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-text">3. Dispatch Queue执行Block的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-6-%E6%80%BB%E7%BB%93"><span class="toc-text">4.1.6 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Dispatch-Semaphore"><span class="toc-text">4.2 Dispatch Semaphore</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-API%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.2.1 API介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E5%8E%9F%E7%90%86"><span class="toc-text">4.2.2 原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-dispatch-semaphore-t"><span class="toc-text">1.dispatch_semaphore_t</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-dispatch-semaphore-create"><span class="toc-text">2. dispatch_semaphore_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-dispatch-semaphore-wait"><span class="toc-text">3. dispatch_semaphore_wait</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-dispatch-semaphore-signal"><span class="toc-text">4. dispatch_semaphore_signal</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%80%BB%E7%BB%93%E7%AF%87"><span class="toc-text">5. 总结篇</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E5%BA%94%E7%94%A8"><span class="toc-text">4.2.3 应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Dispatch-Group"><span class="toc-text">4.3 Dispatch Group</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-dispatch-group-create"><span class="toc-text">4.3.1 dispatch_group_create</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-dispatch-group-enter"><span class="toc-text">4.3.2 dispatch_group_enter</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-dispatch-group-leave"><span class="toc-text">4.3.3 dispatch_group_leave</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-dispatch-group-async"><span class="toc-text">4.3.4 dispatch_group_async</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-dispatch-group-wait"><span class="toc-text">4.3.5 dispatch_group_wait</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-6-dispatch-group-notify"><span class="toc-text">4.3.6 dispatch_group_notify</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-7-dispatch-group-wake-%E5%86%85%E9%83%A8API"><span class="toc-text">4.3.7 dispatch_group_wake(内部API)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-8-dispatch-release"><span class="toc-text">4.3.8 dispatch_release</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-9-%E5%8E%9F%E7%90%86%E5%B0%8F%E7%BB%93"><span class="toc-text">4.3.9 原理小结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-dispatch-barrier-async-%E5%8F%98%E6%97%A0%E5%BA%8F%E4%B8%BA%E6%9C%89%E5%BA%8F"><span class="toc-text">4.4 dispatch_barrier_async(变无序为有序)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-1-%E4%BD%BF%E7%94%A8"><span class="toc-text">4.4.1 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-2-%E5%8E%9F%E7%90%86"><span class="toc-text">4.4.2 原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-dispatch-apply"><span class="toc-text">4.5 dispatch_apply</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-6-dispatch-suspend-dispatch-resume"><span class="toc-text">4.6 dispatch_suspend&#x2F;dispatch_resume</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-7-dispatch-once"><span class="toc-text">4.7 dispatch_once</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-1-API%E4%BB%8B%E7%BB%8D"><span class="toc-text">4.7.1 API介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-2-%E5%8E%9F%E7%90%86"><span class="toc-text">4.7.2 原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-3-%E6%80%BB%E7%BB%93"><span class="toc-text">4.7.3 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-8-Dispatch-I-O%E4%B8%8EDispatch-Data%E5%AF%B9%E8%B1%A1"><span class="toc-text">4.8 Dispatch I&#x2F;O与Dispatch Data对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-9-dispatch-source"><span class="toc-text">4.9 dispatch_source</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-1-kqueue"><span class="toc-text">4.9.1 kqueue</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">4.9.2 使用示例：定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-3-%E5%B8%B8%E7%94%A8API"><span class="toc-text">4.9.3 常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-dispatch-source-create"><span class="toc-text">1. dispatch_source_create</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-dispatch-source-set-timer"><span class="toc-text">2. dispatch_source_set_timer</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-dispatch-source-set-event-handler"><span class="toc-text">3. dispatch_source_set_event_handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-dispatch-source-set-cancel-handler"><span class="toc-text">4. dispatch_source_set_cancel_handler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-dispatch-resume-dispatch-suspend"><span class="toc-text">5. dispatch_resume&#x2F;dispatch_suspend</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-9-4-%E6%80%BB%E7%BB%93"><span class="toc-text">4.9.4 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-10-dispatch-after-%E5%BB%B6%E8%BF%9F%E6%89%A7%E8%A1%8C"><span class="toc-text">4.10 dispatch_after(延迟执行)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-1-%E4%BD%BF%E7%94%A8"><span class="toc-text">4.10.1 使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-10-2-%E5%8E%9F%E7%90%86"><span class="toc-text">4.10.2 原理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5"><span class="toc-text">五、参考链接</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    
    
    
    
        <span class="sidebar-category-name" data-categories="数据结构与算法"><span class="iconfont-archer">&#xe60a;</span>数据结构与算法</span>
    
        <span class="sidebar-category-name" data-categories="计算机组成原理"><span class="iconfont-archer">&#xe60a;</span>计算机组成原理</span>
    
        <span class="sidebar-category-name" data-categories="计算机网络"><span class="iconfont-archer">&#xe60a;</span>计算机网络</span>
    
        <span class="sidebar-category-name" data-categories="汇编语言"><span class="iconfont-archer">&#xe60a;</span>汇编语言</span>
    
        <span class="sidebar-category-name" data-categories="数据的存储与传输"><span class="iconfont-archer">&#xe60a;</span>数据的存储与传输</span>
    
        <span class="sidebar-category-name" data-categories="操作系统"><span class="iconfont-archer">&#xe60a;</span>操作系统</span>
    
        <span class="sidebar-category-name" data-categories="互联网标准RFC"><span class="iconfont-archer">&#xe60a;</span>互联网标准RFC</span>
    
        <span class="sidebar-category-name" data-categories="编译链接与装载"><span class="iconfont-archer">&#xe60a;</span>编译链接与装载</span>
    
        <span class="sidebar-category-name" data-categories="iOS"><span class="iconfont-archer">&#xe60a;</span>iOS</span>
    
        <span class="sidebar-category-name" data-categories="架构与设计模式"><span class="iconfont-archer">&#xe60a;</span>架构与设计模式</span>
    
        <span class="sidebar-category-name" data-categories="图形处理与渲染"><span class="iconfont-archer">&#xe60a;</span>图形处理与渲染</span>
    
        <span class="sidebar-category-name" data-categories="软件工程"><span class="iconfont-archer">&#xe60a;</span>软件工程</span>
    
        <span class="sidebar-category-name" data-categories="音视频处理"><span class="iconfont-archer">&#xe60a;</span>音视频处理</span>
    
        <span class="sidebar-category-name" data-categories="DSL"><span class="iconfont-archer">&#xe60a;</span>DSL</span>
    
        <span class="sidebar-category-name" data-categories="Swift"><span class="iconfont-archer">&#xe60a;</span>Swift</span>
    
        <span class="sidebar-category-name" data-categories="Git"><span class="iconfont-archer">&#xe60a;</span>Git</span>
    
        <span class="sidebar-category-name" data-categories="Web"><span class="iconfont-archer">&#xe60a;</span>Web</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 75
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-side-search"> 
                <span class="iconfont-jian search-icon">&#xe7fc;搜索</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2022 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span><a class="archive-post-title" href= "/2022/05/05/sqlite.html" >iOS SQLite的使用与优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href= "/2022/04/28/mmap.html" >内存映射mmap函数的原理与应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/18</span><a class="archive-post-title" href= "/2022/03/18/avfoundation.html" >AVFoundation Programming Guide(译)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span><a class="archive-post-title" href= "/2022/03/17/avframework.html" >iOS音视频库概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2022/02/09/OAuth.html" >[转] OAuth 2.0简述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/18</span><a class="archive-post-title" href= "/2022/01/18/wkwebview-buges.html" >WKWebView使用过程中遇到的坑</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/22</span><a class="archive-post-title" href= "/2021/11/22/bit-calculation.html" >[转] 位运算实现加、减、乘、除运算</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span><a class="archive-post-title" href= "/2021/11/10/git-use.html" >Git的使用总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/21</span><a class="archive-post-title" href= "/2021/10/21/dyld-objc.html" >(六) dyld与Runtime—_objc_init、map_images、load_images</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/18</span><a class="archive-post-title" href= "/2021/10/18/compile-dynamic-link.html" >(五) Mach-O 文件的动态链接、库、Dyld(含dlopen)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span><a class="archive-post-title" href= "/2021/10/10/compile-load.html" >(四) Mach-O 文件的装载、ASLR及符号地址</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/08</span><a class="archive-post-title" href= "/2021/10/08/compile-static-link.html" >(三) Mach-O 文件的静态链接</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/06</span><a class="archive-post-title" href= "/2021/10/06/compile-macho.html" >(二) Mach-O 文件结构</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2021/10/05/compile-clang-llvm.html" >(一) Clang/LLVM 介绍、OC 程序的编译过程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/02</span><a class="archive-post-title" href= "/2021/10/02/makefile.html" >[转] Make 命令的使用与NodeJS案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/2021/09/28/architectural-pattern.html" >常见架构模式: MVC、MVP、MVVM、VIPER</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href= "/2021/09/25/design-pattern.html" >常见的设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href= "/2021/09/20/program-thought.html" >常见的编程范式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing-case.html" >图形处理(三) - 图形处理实践案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing.html" >图形处理(二) - 图形与视频处理相关的框架</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2021/09/13/image-encode-decode.html" >图形处理(一) - 图片的加载与编解码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/12</span><a class="archive-post-title" href= "/2021/09/12/iOS-Render.html" >[转] iOS离屏渲染原理及优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2021/09/11/core-animation03.html" >Core-Animation(三) - 渲染流程探究及性能分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/09</span><a class="archive-post-title" href= "/2021/09/09/core-animation02.html" >Core Animation(二) - 隐式动画、CATransaction与CAAction</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/07</span><a class="archive-post-title" href= "/2021/09/07/core-animation01.html" >Core Animation(一) - UIView与CALayer、布局与绘制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span><a class="archive-post-title" href= "/2021/09/05/AFN-Analyse.html" >[转] AFN框架实现解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/04</span><a class="archive-post-title" href= "/2021/09/04/nrl-session.html" >NSURLSession概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2021/09/02/Log.html" >移动端日志库设计</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href= "/2021/08/01/Crash-Monitor.html" >iOS崩溃监控与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2021/07/30/Lag-Monitor.html" >iOS卡顿监控与堆栈获取</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/SwiftUI.html" >SwiftUI</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/Swift-Version-History.html" >Swift版本更新API介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/26</span><a class="archive-post-title" href= "/2021/07/26/RunLoop-Reposted-From-ibireme.html" >[转] 深入理解RunLoop—ibireme</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2021/07/25/Protocol-Buffer.html" >Protocol Buffer的基本介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href= "/2021/07/24/base64.html" >Base64编码及iOS中的Base64</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span><a class="archive-post-title" href= "/2021/07/23/chinese-encode.html" >[转] 彻底弄懂常见的7种中文字符编码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/10</span><a class="archive-post-title" href= "/2021/07/10/p-npc-np.html" >P问题、NP问题、NPC、NP-Hard、P=NP?</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href= "/2021/06/30/probability.html" >(六) 概率算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/28</span><a class="archive-post-title" href= "/2021/06/28/branch-bound.html" >(五) 分支限界算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/26</span><a class="archive-post-title" href= "/2021/06/26/back-track.html" >(四) 回溯法(试探算法)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/24</span><a class="archive-post-title" href= "/2021/06/24/greed.html" >(三) 贪心算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/22</span><a class="archive-post-title" href= "/2021/06/22/dynamic-programming.html" >(二) 动态规划算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href= "/2021/06/20/divide-and-conquer.html" >(一) 分治算法及减治、变治算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span><a class="archive-post-title" href= "/2021/06/18/several-programming.html" >穷举、递推、迭代(辗转法)、递归算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/15</span><a class="archive-post-title" href= "/2021/06/15/datastruction-overview.html" >数据结构与算法概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/06</span><a class="archive-post-title" href= "/2021/06/06/Web-Module.html" >前端各种模块化方案总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Fiber.html" >[转] 最通俗的 React Fiber(时间分片)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Coroutine.html" >[转] 什么是协程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href= "/2021/05/19/DSL.html" >[转] 谈谈DSL以及DSL的应用（以CocoaPods 为例）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href= "/2021/05/03/iOS-private-pod.html" >私有Pod库部署</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/29</span><a class="archive-post-title" href= "/2021/04/29/iOS-ComRouter.html" >[转] iOS的组件化方案</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/27</span><a class="archive-post-title" href= "/2021/04/27/iOS-CI.html" >iOS的持续集成</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/26</span><a class="archive-post-title" href= "/2021/04/26/Containers.html" >常见的容器概念：Linux容器、Docker容器、服务器容器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span><a class="archive-post-title" href= "/2021/04/24/Dock-Reprinted-from-RuanYIFeng.html" >[转] Docker入门教程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span><a class="archive-post-title" href= "/2021/04/20/Sync-Async.html" >同步和异步解读及编程中的使用场景</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span><a class="archive-post-title" href= "/2021/04/17/Arm64-Handbook.html" >ARM64指令简易手册</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span><a class="archive-post-title" href= "/2021/04/16/Arm64-Introduce.html" >iOS需要了解的ARM64汇编</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span><a class="archive-post-title" href= "/2021/04/13/Command-Line.html" >CLI Shell、Terminal、脚本(语言)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href= "/2021/04/10/Ins-SysCall-Kernel-Shell.html" >指令、系统调用、库、Shell、APP的层次关系</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span><a class="archive-post-title" href= "/2021/04/08/ISA-Microarch-Soc.html" >指令集、微架构、手机芯片(Soc)及ARM的介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span><a class="archive-post-title" href= "/2021/04/02/Engineering.html" >工程化、动态化、容器化、组件化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2021/04/01/GithubPages-Hexo.html" >使用Hexo+Github Pages搭建个人博客</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/22</span><a class="archive-post-title" href= "/2020/12/22/aes.html" >数据加密 — 对称加密(以AES为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href= "/2020/12/21/aes-standard.html" >[转] AES标准及Rijndael算法解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span><a class="archive-post-title" href= "/2020/12/20/asymmetric.html" >数据加密 — 非对称加密(加签/加密，以RSA为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/09</span><a class="archive-post-title" href= "/2020/12/09/pki.html" >常见的PKI标准(X.509、PKCS)及证书相关介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href= "/2020/10/28/runtime-data-structure.html" >Objc Runtime总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2020/09/11/GCD.html" >Objective-C — 深入浅出GCD常用API</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/06</span><a class="archive-post-title" href= "/2020/09/06/oc-block.html" >Objective-C — Block</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/26</span><a class="archive-post-title" href= "/2020/08/26/AutoreleasePool.html" >AutoreleasePool</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/24</span><a class="archive-post-title" href= "/2020/08/24/oc-memory-manage.html" >Objective-C — 内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href= "/2020/08/01/ui-navigation-bar.html" >[转] 导航栏的架构介绍及使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/15</span><a class="archive-post-title" href= "/2020/07/15/symbol-decl.html" >变量声明、函数声明的作用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2020/07/01/ios-apns.html" >iOS APNS接收逻辑梳理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/2020/06/13/ios-vest.html" >iOS制作马甲总结</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="AutoreleasePool"><span class="iconfont-archer">&#xe606;</span>AutoreleasePool</span>
    
        <span class="sidebar-tag-name" data-tags="GCD"><span class="iconfont-archer">&#xe606;</span>GCD</span>
    
        <span class="sidebar-tag-name" data-tags="hexo"><span class="iconfont-archer">&#xe606;</span>hexo</span>
    
        <span class="sidebar-tag-name" data-tags="ISA"><span class="iconfont-archer">&#xe606;</span>ISA</span>
    
        <span class="sidebar-tag-name" data-tags="Microarch"><span class="iconfont-archer">&#xe606;</span>Microarch</span>
    
        <span class="sidebar-tag-name" data-tags="Soc"><span class="iconfont-archer">&#xe606;</span>Soc</span>
    
        <span class="sidebar-tag-name" data-tags="ARM64"><span class="iconfont-archer">&#xe606;</span>ARM64</span>
    
        <span class="sidebar-tag-name" data-tags="Docker"><span class="iconfont-archer">&#xe606;</span>Docker</span>
    
        <span class="sidebar-tag-name" data-tags="CLI"><span class="iconfont-archer">&#xe606;</span>CLI</span>
    
        <span class="sidebar-tag-name" data-tags="Shell"><span class="iconfont-archer">&#xe606;</span>Shell</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="协程"><span class="iconfont-archer">&#xe606;</span>协程</span>
    
        <span class="sidebar-tag-name" data-tags="DSL"><span class="iconfont-archer">&#xe606;</span>DSL</span>
    
        <span class="sidebar-tag-name" data-tags="Fiber"><span class="iconfont-archer">&#xe606;</span>Fiber</span>
    
        <span class="sidebar-tag-name" data-tags="dp"><span class="iconfont-archer">&#xe606;</span>dp</span>
    
        <span class="sidebar-tag-name" data-tags="RunLoop"><span class="iconfont-archer">&#xe606;</span>RunLoop</span>
    
        <span class="sidebar-tag-name" data-tags="SwiftUI"><span class="iconfont-archer">&#xe606;</span>SwiftUI</span>
    
        <span class="sidebar-tag-name" data-tags="LagMonitor"><span class="iconfont-archer">&#xe606;</span>LagMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="Swift-Syntax"><span class="iconfont-archer">&#xe606;</span>Swift-Syntax</span>
    
        <span class="sidebar-tag-name" data-tags="CrashMonitor"><span class="iconfont-archer">&#xe606;</span>CrashMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="Log"><span class="iconfont-archer">&#xe606;</span>Log</span>
    
        <span class="sidebar-tag-name" data-tags="AFN"><span class="iconfont-archer">&#xe606;</span>AFN</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Tenloy"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


