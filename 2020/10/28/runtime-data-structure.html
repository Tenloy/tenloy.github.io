<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Tenloy">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Tenloy">
    
    <meta name="keywords" content="Tenloy,iOS,Swift">
    
    <meta name="description" content="学习 生活 记录 回忆">
    <meta name="description" content="内容骨架来自戴铭老师文章Objc Runtime 总结，因为发布有些久远，一些内容已经过时，修正了一下，并填充了一些自己的知识总结。 更新：以下源码来自objc4-756.2，2019年下半年随着macOS 10.15发布了objc4-779.1，其后陆续对cache_t、class_rw_t等结构进行了一些调整。  一、Runtime概述1.1 Runtime做了什么？Objective-C跟">
<meta property="og:type" content="article">
<meta property="og:title" content="Objc Runtime总结">
<meta property="og:url" content="https://tenloy.github.io/2020/10/28/runtime-data-structure.html">
<meta property="og:site_name" content="Tenloy&#39;s Blog">
<meta property="og:description" content="内容骨架来自戴铭老师文章Objc Runtime 总结，因为发布有些久远，一些内容已经过时，修正了一下，并填充了一些自己的知识总结。 更新：以下源码来自objc4-756.2，2019年下半年随着macOS 10.15发布了objc4-779.1，其后陆续对cache_t、class_rw_t等结构进行了一些调整。  一、Runtime概述1.1 Runtime做了什么？Objective-C跟">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tenloy.github.io/images/runtime/04.jpg">
<meta property="og:image" content="https://tenloy.github.io/images/compilelink/36.png">
<meta property="og:image" content="https://tenloy.github.io/images/runtime/08.png">
<meta property="og:image" content="https://tenloy.github.io/images/runtime/05.png">
<meta property="og:image" content="https://tenloy.github.io/images/runtime/06.png">
<meta property="og:image" content="https://tenloy.github.io/images/runtime/07.png">
<meta property="og:image" content="https://tenloy.github.io/images/runtime/01.png">
<meta property="og:image" content="https://tenloy.github.io/images/runtime/02.png">
<meta property="og:image" content="https://tenloy.github.io/images/runtime/03.png">
<meta property="article:published_time" content="2020-10-28T02:26:09.000Z">
<meta property="article:modified_time" content="2024-05-09T02:53:16.000Z">
<meta property="article:author" content="Tenloy">
<meta property="article:tag" content="Tenloy, iOS, Tenloy Blog, 博客，Swift, 编译, 计算机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tenloy.github.io/images/runtime/04.jpg">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>Objc Runtime总结 · Tenloy&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"Search for Posts","hits_empty":"没有找到任何搜索结果: ${query}","hits_stats":"找到约${hits}条结果（用时${time}ms）"}')

            var algolia = {
                applicationID: 'V0HYXBS9FB',
                apiKey: '6550d5de786935564142097c3e78c380',
                indexName: 'law_blog_index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Tenloy's Blog" type="application/atom+xml">
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Tenloy&#39;s Blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Objc Runtime总结</a>
            </div>
    </div>
    
    <!-- 将home-link的操作改为应用到header-top-right上 -->
    <div class="header-top-right">
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-search">
                <span class="iconfont-jian tl-search-icon">&#xe7fc;搜索</span>
            </div>
            
        <a class="home-link" href=/>Tenloy's Blog</a>
    </div>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:40vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Objc Runtime总结
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">18.9k</span>Reading time: <span class="post-count reading-time">82 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/10/28</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <blockquote>
<p>内容骨架来自戴铭老师文章<a target="_blank" rel="noopener" href="https://ming1016.github.io/2015/04/01/objc-runtime/">Objc Runtime 总结</a>，因为发布有些久远，一些内容已经过时，修正了一下，并填充了一些自己的知识总结。</p>
<p>更新：以下源码来自objc4-756.2，2019年下半年随着macOS 10.15发布了objc4-779.1，其后陆续对cache_t、class_rw_t等结构进行了一些调整。</p>
</blockquote>
<h1 id="一、Runtime概述"><a href="#一、Runtime概述" class="headerlink" title="一、Runtime概述"></a>一、Runtime概述</h1><h2 id="1-1-Runtime做了什么？"><a href="#1-1-Runtime做了什么？" class="headerlink" title="1.1 Runtime做了什么？"></a>1.1 Runtime做了什么？</h2><p>Objective-C跟C、C++等语言有着很大的不同，是一门动态性比较强的编程语言。允许很多操作推迟到程序运行时再进行，其可以在运行过程中修改之前编译好的行为，比如程序运行时创建，检查，修改类、对象和它们的方法。</p>
<blockquote>
<p>维基：<strong>动态编程语言</strong>是高级编程语言的一个类别，是一类在运行时可以改变其结构的语言，或者说可以在运行时执行静态编程语言在编译期间执行的许多常见编程行为。例如：程序的扩展、添加新代码，已有的函数可以被删除或修改、扩展对象、定义或修改类型系统等。</p>
</blockquote>
<p>而Objective-C的动态性是由Runtime来支撑和实现的。</p>
<blockquote>
<p>很久之前孙源老师的一篇文章中说道：objc = C + objc编译器 + runtime</p>
</blockquote>
<p>Runtime做了什么：</p>
<ul>
<li>建立了支持objc语言的数据结构。使得C具有了面向对象能力</li>
<li>建立了消息机制</li>
</ul>
<img src="/images/runtime/04.jpg" alt="04" style="zoom:60%;" />

<h2 id="1-2-学习链接"><a href="#1-2-学习链接" class="headerlink" title="1.2 学习链接"></a>1.2 学习链接</h2><ul>
<li>Runtime是C和汇编编写的，是开源的，<a target="_blank" rel="noopener" href="https://opensource.apple.com/source/objc4/">下载地址</a>；</li>
<li>GNU也有一个开源的runtime版本，他们都努力的保持一致。</li>
<li>苹果官方的<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a>。</li>
<li>Runtime系统是由一系列的函数和数据结构组成的公共接口动态共享库，在/usr/include/objc目录下可以看到头文件，可以用其中一些函数通过C语言实现objectivec中一样的功能。可以在苹果官方文档<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/objectivec/objective-c_runtime?language=objc">Objective-C Runtime Reference</a>中查看 Runtime 库函数的详细解释。<ul>
<li>当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，如果发现没有代码提示，函数里面的参数和描述也没有了。可以在 <code>Build Setting</code> 中设置 <code>Enable Strict Checking of objc_msgSend Calls</code> 为 NO。</li>
</ul>
</li>
</ul>
<p>写在前面：</p>
<ul>
<li>后缀 <code>_t</code> 意味着 type/typedef(类型) ，是一种命名规范，类似于全局变量加前缀 <code>g_</code>。</li>
<li><code>_np</code>表示不可移植(np意指non portable, 不可移植)。</li>
</ul>
<h1 id="二、Object、Class与MetaClass"><a href="#二、Object、Class与MetaClass" class="headerlink" title="二、Object、Class与MetaClass"></a>二、Object、Class与MetaClass</h1><h2 id="关系简图"><a href="#关系简图" class="headerlink" title="关系简图"></a>关系简图</h2><img src="/images/compilelink/36.png" alt="36" style="zoom:88%;" />

<p>class_ro_t里面的baseMethodList、baseProtocols、ivars、baseProperties是一维数组，是只读的，包含了类的初始内容。</p>
<p>class_rw_t里面的methods、properties、protocols是二维数组，是可读可写的，包含了类的初始内容、分类的内容。</p>
<p>objc_class 1.0和2.0的差别示意图：</p>
<img src="/images/runtime/08.png" alt="08" style="zoom:67%;" />

<h2 id="2-1-objc-object与id"><a href="#2-1-objc-object与id" class="headerlink" title="2.1 objc_object与id"></a>2.1 objc_object与id</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 类的实例结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;</span><br><span class="line">    <span class="comment">//方法略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// A pointer to an instance of a class. id是一个objc_object结构类型的指针，这个类型的对象能够转换成任何一种对象。</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> *<span class="title">id</span>;</span></span><br></pre></td></tr></table></figure>

<h3 id="对象是什么？"><a href="#对象是什么？" class="headerlink" title="对象是什么？"></a>对象是什么？</h3><p><strong>看到 objc_object 的结构后，此处有个结论：任何结构体，只要以一个指向 Class 结构体的指针开始，都可以视为一个 objc_object (对象)。</strong></p>
<blockquote>
<ul>
<li><strong>32位中，只要一个数据结构的前4个字节，是个指针(Class isa)，就是个对象。</strong></li>
<li><strong>64位中，只要一个数据结构的前8个字节，是个isa_t类型的变量(isa_t isa)，就是个对象。</strong></li>
</ul>
</blockquote>
<p><strong>反之，Objc中的对象是一个指向ClassObject地址的变量，即 id obj = &amp;ClassObject ， 而对象的实例变量 void *ivar = &amp;obj + offset(N)</strong></p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *name;</span><br><span class="line">- (<span class="keyword">void</span>)speak;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Sark</span></span></span><br><span class="line">- (<span class="keyword">void</span>)speak &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;my name&#x27;s %@&quot;</span>, <span class="keyword">self</span>.name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line">    <span class="keyword">id</span> cls = [Sark <span class="keyword">class</span>];</span><br><span class="line">    <span class="keyword">void</span> *obj = &amp;cls;</span><br><span class="line">    [(__bridge <span class="keyword">id</span>)obj speak];  </span><br><span class="line">    <span class="comment">// obj的前8个字节是指向Class Sark的数据，所以其能视为Sark类对象的。</span></span><br><span class="line">    <span class="comment">// 但是在-speak中，取obj的name，本质是取obj后偏移的第9-16字节的数据，此处会取出-viewDidLoad函数栈中的数据，错乱掉。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span> </span><br></pre></td></tr></table></figure>

<h2 id="2-2-objc-class"><a href="#2-2-objc-class" class="headerlink" title="2.2 objc_class"></a>2.2 objc_class</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Objc的类的本身也是一个Object，类的类型我们称为元类Meta Class，记录类方法、属性。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// 继承了isa_t isa;</span></span><br><span class="line">    Class superclass;          <span class="comment">// 指向父类的指针，用于组织类的继承链；</span></span><br><span class="line">    <span class="keyword">cache_t</span> cache;             <span class="comment">// 缓存调用过的method。对象接到一个消息会根据isa指针查找消息对象，这时会在methodLists中遍历，如果cache了，常用的方法调用时就能够提高调用的效率。(以前缓存指针pointer和vtable)</span></span><br><span class="line">    <span class="keyword">class_data_bits_t</span> bits;    </span><br><span class="line">       <span class="comment">// class_rw_t * plus custom rr/alloc flags. </span></span><br><span class="line">       <span class="comment">// 表示class_data_bits_t其实是class_rw_t* 加上自定义的rr/alloc标志，rr/alloc标志是指含有的retain/release/autorelease/retainCount/alloc等</span></span><br><span class="line">  </span><br><span class="line">       <span class="comment">// class_data_bits_t结构体主要用于记录，保存类的数据的`class_rw_t`结构体的内存地址。通过`date()`方法访问`bits`的有效位域指向的内存空间，返回`class_rw_t`结构体；`setData(class_rw_t *newData)`用于设置`bits`的值；</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span> *<span class="title">data</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> bits.<span class="built_in">data</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span> </span>&#123;</span><br><span class="line">        bits.<span class="built_in">setData</span>(newData);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-1-成员-isa-t-isa"><a href="#2-2-1-成员-isa-t-isa" class="headerlink" title="2.2.1 成员: isa_t isa"></a>2.2.1 成员: isa_t isa</h3><p>在arm64架构之前，isa就是一个普通的指针(Class _Nonnull isa)，存储着Class、Meta-Class对象的内存地址 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> &#123;</span></span><br><span class="line">    Class isa OBJC_ISA_AVAILABILITY;</span><br><span class="line">&#125; OBJC2_UNAVAILABLE;</span><br></pre></td></tr></table></figure>

<p>从arm64架构开始：</p>
<ul>
<li>明确的将objc_class定义为一个Object，继承自struct objc_object。</li>
<li>对isa进行了优化，变成了一个共用体（union）结构，使用位域来存储了更多的信息。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> &#123;</span></span><br><span class="line">    <span class="keyword">isa_t</span> isa;   <span class="comment">// isa(is a)指向它的类。当向object发送消息时，Runtime库会根据object的isa指针找到这个实例object所属于的类，然后在类的方法列表以及父类方法列表寻找对应的方法运行。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_class</span> :</span> objc_object &#123;</span><br><span class="line">    <span class="comment">// 继承了isa_t isa;    // class的isa指针指向class的类(术语称为Meta Class)，因为Objc的类的本身也是一个Object，为了处理这个关系，runtime就创造了Meta Class，当给类发送[NSObject alloc]这样消息时，实际上是把这个消息发给了Class Object。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MASK        0x0000000ffffffff8ULL  取类指针值的掩码</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ISA_MAGIC_MASK  0x000003f000000001ULL  取MAGIC值的掩码</span></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">isa_t</span> &#123;</span></span><br><span class="line">    <span class="built_in">isa_t</span>() &#123; &#125;</span><br><span class="line">    <span class="built_in">isa_t</span>(<span class="keyword">uintptr_t</span> value) : <span class="built_in">bits</span>(value) &#123; &#125;</span><br><span class="line">    Class cls;</span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> nonpointer        : <span class="number">1</span>;  <span class="comment">// 代表是否开启isa指针优化。0 代表普通的指针，存储着Class、Meta-Class对象的内存地址； 1 代表优化过，使用位域存储更多的信息</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_assoc         : <span class="number">1</span>;  <span class="comment">// 是否设置或曾经过关联对象(associatedObject)，如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_cxx_dtor      : <span class="number">1</span>;  <span class="comment">// 是否有C++ 或者 Objc的析构函数（.cxx_destruct），如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> shiftcls          : <span class="number">33</span>; <span class="comment">// 类指针。存储着Class、Meta-Class对象的内存地址信息。源码中isa.shiftcls = (uintptr_t)cls &gt;&gt; 3; 将当前地址右移三位的主要原因是用于将 Class 指针中无用的后三位清除减小内存的消耗，因为类的指针要按照字节（8 bits）对齐内存，其指针后三位都是没有意义的 0。</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> magic             : <span class="number">6</span>;  <span class="comment">// 用于在调试时分辨对象是否未完成初始化</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> weakly_referenced : <span class="number">1</span>;  <span class="comment">// 对象被指向或者曾经指向一个 ARC 的弱变量。如果没有，释放时会更快</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> deallocating      : <span class="number">1</span>;  <span class="comment">// 对象是否正在释放</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> has_sidetable_rc  : <span class="number">1</span>;  <span class="comment">// 引用计数器是否过大无法存储在isa(extra_rc字段)中。如果为1，那么引用计数会存储在一个叫SideTable的类的属性中</span></span><br><span class="line">        <span class="keyword">uintptr_t</span> extra_rc          : <span class="number">19</span>  <span class="comment">// 里面存储的值是引用计数器减1（比如对象引用计数器是1，这里就是0）</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;                                     </span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="关于Tagged-Pointer"><a href="#关于Tagged-Pointer" class="headerlink" title="关于Tagged Pointer"></a>关于Tagged Pointer</h4><p>在2013年9月，苹果推出了<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/IPhone_5S">iPhone5s</a>，与此同时，iPhone5s配备了首个采用64位架构的<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://en.wikipedia.org/wiki/Apple_A7">A7双核处理器</a>，为了节省内存和提高执行效率，苹果提出了Tagged Pointer的概念。对于64位程序，引入Tagged Pointer后，相关逻辑能减少一半的内存占用，以及3倍的访问速度提升，100倍的创建、销毁速度提升。</p>
<p>在WWDC2013的《Session 404 Advanced in Objective-C》视频中，苹果介绍了 Tagged Pointer。 Tagged Pointer用于优化NSNumber、NSDate、NSString等小对象的存储，其存在主要是为了节省内存。我们知道，对象的指针大小一般是与机器字长有关，在32位系统中，一个指针的大小是32位（4字节），而在64位系统中，一个指针的大小将是64位（8字节）。</p>
<p>假设我们要存储一个NSNumber对象，其值是一个整数。正常情况下，如果这个整数只是一个NSInteger的普通变量，那么它所占用的内存是与CPU的位数有关，在32位CPU下占4个字节，在64位CPU下是占8个字节的。而指针类型的大小通常也是与CPU位数相关，一个指针所占用的内存在32位CPU下为4个字节，在64位CPU下也是8个字节。如果没有Tagged Pointer对象，从32位机器迁移到64位机器中后，虽然逻辑没有任何变化，但这种NSNumber、NSDate一类的对象所占用的内存会翻倍。</p>
<p>苹果提出了Tagged Pointer对象。由于NSNumber、NSDate一类的变量本身的值需要占用的内存大小常常不需要8个字节，拿整数来说，4个字节所能表示的有符号整数就可以达到20多亿（注：2^31=2147483648，另外1位作为符号位)，对于绝大多数情况都是可以处理的。如下图所示：</p>
<img src="/images/runtime/05.png" alt="05" style="zoom:75%;" />

<h3 id="2-2-2-成员-cache-t-cache"><a href="#2-2-2-成员-cache-t-cache" class="headerlink" title="2.2.2 成员: cache_t cache"></a>2.2.2 成员: cache_t cache</h3><blockquote>
<p>cache: 用于缓存调用过的method</p>
</blockquote>
<p>Cache的作用主要是为了优化方法调用的性能。</p>
<p>假如，当对象receiver调用方法message时：</p>
<ol>
<li>首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法；</li>
<li>如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。</li>
</ol>
<p>这样查找方式效率就太低了，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cache_t</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> *_<span class="title">buckets</span>;</span>  <span class="comment">// 是一个散列表，用来存储Method的链表</span></span><br><span class="line">    <span class="keyword">mask_t</span> _mask;               <span class="comment">// 分配用来缓存bucket的总数。散列表的长度 - 1</span></span><br><span class="line">    <span class="keyword">mask_t</span> _occupied;           <span class="comment">// 目前实际占用的缓存bucket的个数。因为缓存是以散列表的形式存在的，所以会有空槽，而occupied表示当前被占用的数目</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="keyword">uint32_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uint32_t</span> <span class="keyword">mask_t</span>;  <span class="comment">// x86_64 &amp; arm64 asm are less efficient with 16-bits</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span>  <span class="keyword">uintptr_t</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">uintptr_t</span> <span class="keyword">cache_key_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bucket_t</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">uintptr_t</span> _imp;  <span class="comment">// 函数指针，指向了一个方法的具体实现</span></span><br><span class="line">  SEL _sel;        <span class="comment">// SEL作为key</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 散列函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">mask_t</span> <span class="title">cache_hash</span><span class="params">(SEL sel, <span class="keyword">mask_t</span> mask)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">mask_t</span>)(<span class="keyword">uintptr_t</span>)sel &amp; mask;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="要点："><a href="#要点：" class="headerlink" title="要点："></a>要点：</h4><ul>
<li><strong>不管是在本类、父类、基类中找到的，只要不在本类的cache中，就填充缓存。</strong>详见4.3节</li>
<li>关于缓存的扩容以及限制：<ul>
<li>初始大小为4；</li>
<li>当缓存使用达到3/4后，进行缓存扩容，扩容系数为2；</li>
<li>扩容时，会清空缓存，否则hash值就不对了；</li>
<li>旧版本中，类的方法缓存大小是有没有限制的，在新的runtime中增加了限制；<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Initial cache bucket count. INIT_CACHE_SIZE must be a power of two. */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">    INIT_CACHE_SIZE_LOG2 = <span class="number">2</span>,</span><br><span class="line">    INIT_CACHE_SIZE      = (<span class="number">1</span> &lt;&lt; INIT_CACHE_SIZE_LOG2),</span><br><span class="line">    MAX_CACHE_SIZE_LOG2  = <span class="number">16</span>,</span><br><span class="line">    MAX_CACHE_SIZE       = (<span class="number">1</span> &lt;&lt; MAX_CACHE_SIZE_LOG2),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cache_t::insert</span><span class="params">(Class cls, SEL sel, IMP imp, id receiver)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    capacity = capacity ? capacity * <span class="number">2</span> : INIT_CACHE_SIZE;</span><br><span class="line">    <span class="keyword">if</span> (capacity &gt; MAX_CACHE_SIZE) &#123;</span><br><span class="line">        capacity = MAX_CACHE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reallocate</span>(oldCapacity, capacity, <span class="literal">true</span>);   </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>为什么类的方法列表不直接做成散列表呢，做成list，还要单独缓存，多费事？这个问题么，我觉得有以下三个原因：<ul>
<li>散列表是没有顺序的，Objective-C的方法列表是一个list，是有顺序的；Objective-C在查找方法的时候会顺着list依次寻找，并且category的方法在原始方法list的前面，需要先被找到，如果直接用hash存方法，方法的顺序就没法保证。</li>
<li>list的方法还保存了除了selector和imp之外其他很多属性</li>
<li>散列表是有空槽的，会浪费空间</li>
</ul>
</li>
</ul>
<h3 id="2-2-3-成员-class-data-bits-t-bits"><a href="#2-2-3-成员-class-data-bits-t-bits" class="headerlink" title="2.2.3 成员: class_data_bits_t bits"></a>2.2.3 成员: class_data_bits_t bits</h3><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><blockquote>
<p><code>bits</code>：<code>class_data_bits_t</code>结构体类型，该结构体主要用于记录，保存类的数据的<code>class_rw_t</code>结构体的内存地址。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK        0xfffffffcUL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK        0x00007ffffffffff8UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_data_bits_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> bits;  <span class="comment">// 仅有一个成员 bits 指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">getBit</span><span class="params">(<span class="keyword">uintptr_t</span> bit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> bits &amp; bit;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 获取类的数据。获取 bits 成员的 4~47 位域(FAST_DATA_MASK)中保存的 class_rw_t 结构体地址。</span></span><br><span class="line">    <span class="function"><span class="keyword">class_rw_t</span>* <span class="title">data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">class_rw_t</span> *)(bits &amp; FAST_DATA_MASK);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置类的数据</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setData</span><span class="params">(<span class="keyword">class_rw_t</span> *newData)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 仅在类注册、构建阶段才允许调用setData</span></span><br><span class="line">        <span class="built_in">assert</span>(!<span class="built_in">data</span>()  ||  (newData-&gt;flags &amp; (RW_REALIZING | RW_FUTURE)));</span><br><span class="line">        <span class="keyword">uintptr_t</span> newBits = (bits &amp; ~FAST_DATA_MASK) | (<span class="keyword">uintptr_t</span>)newData;</span><br><span class="line">        <span class="built_in">atomic_thread_fence</span>(memory_order_release);</span><br><span class="line">        bits = newBits;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="2-class-rw-t与class-ro-t简介"><a href="#2-class-rw-t与class-ro-t简介" class="headerlink" title="2. class_rw_t与class_ro_t简介"></a>2. class_rw_t与class_ro_t简介</h4><p><code>class_rw_t</code>、<code>class_ro_t</code>结构体名中，<code>rw</code>是 read write 的缩写，<code>ro</code>是 read only 的缩写，可见<code>class_ro_t</code>的保存类的只读信息，这些信息在类完成注册后不可改变。</p>
<p>即分类等运行期添加的数据保存在<code>class_rw_t</code>结构体中，编译时期就能确定的部分保存在<code>ro</code>指针指向的<code>class_ro_t</code>结构体中。</p>
<p>以类的成员变量列表为例（成员变量列表保存在<code>class_ro_t</code>结构体中）。若应用类注册到内存后，使用类构建了若干实例，此时若能够添加成员变量，那必然需要对内存中的这些类重新分配内存，这个操作的花销是相当大的。若考虑再极端一些，为根类<code>NSObject</code>添加成员变量，则内存中基本所有 Objective-C 对象都需要重新分配内存，如此庞大的计算量在运行时是不可接受的。</p>
<h4 id="3-bits在编译、运行期间值的改变"><a href="#3-bits在编译、运行期间值的改变" class="headerlink" title="3. bits在编译、运行期间值的改变"></a>3. bits在编译、运行期间值的改变</h4><p>注意：<strong>在编译期，类的结构中的 class_data_bits_t的 class_rw_t</strong> *<strong>data() 取出的是一个指向 class_ro_t 的指针。</strong></p>
<img src="/images/runtime/06.png" alt="06" style="zoom:80%;" />

<p>在运行时调用 realizeClass方法，会做以下3件事情：</p>
<ol>
<li>从 class_data_bits_t调用 data方法，将结果从 class_rw_t强制转换为 class_ro_t指针；</li>
<li>初始化一个 class_rw_t结构体；</li>
<li>设置结构体 ro的值以及 flag；</li>
<li>最后设置正确的 <code>data</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> ro = (<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)cls-&gt;<span class="built_in">data</span>();</span><br><span class="line"><span class="keyword">auto</span> isMeta = ro-&gt;flags &amp; RO_META;</span><br><span class="line">rw = objc::zalloc&lt;<span class="keyword">class_rw_t</span>&gt;();</span><br><span class="line">rw-&gt;<span class="built_in">set_ro</span>(ro);</span><br><span class="line">rw-&gt;flags = RW_REALIZED|RW_REALIZING|isMeta;</span><br><span class="line">cls-&gt;<span class="built_in">setData</span>(rw);</span><br></pre></td></tr></table></figure>

<p>但是，在这段代码运行之后 <code>class_rw_t</code> 中的方法，属性以及协议列表均为空。这时需要 <code>realizeClass</code> 调用 <code>methodizeClass</code> 方法来<strong>将类自己实现的方法（包括分类）、属性和遵循的协议加载到 <code>methods</code>、 <code>properties</code> 和 <code>protocols</code> 列表中</strong>。</p>
<img src="/images/runtime/07.png" alt="06" style="zoom:80%;" />

<p>更加详细的分析，请看<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=https://github.com/Draveness">@Draveness</a> 的这篇文章<a target="_blank" rel="noopener" href="https://draveness.me/method-struct/">深入解析 ObjC 中方法的结构</a>。</p>
<h3 id="2-2-4-方法-类加载过程中，状态读写"><a href="#2-2-4-方法-类加载过程中，状态读写" class="headerlink" title="2.2.4 方法: 类加载过程中，状态读写"></a>2.2.4 方法: 类加载过程中，状态读写</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// objc_class结构体中与类的加载过程相关的方法：</span></span><br><span class="line"><span class="comment">// 查询是否正在初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_INITIALIZING;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记为正在初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitializing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line">    <span class="built_in">ISA</span>()-&gt;<span class="built_in">setInfo</span>(RW_INITIALIZING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否已完成初始化（initializing）</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInitialized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getMeta</span>()-&gt;<span class="built_in">data</span>()-&gt;flags &amp; RW_INITIALIZED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setInitialized</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Class metacls;</span><br><span class="line">    Class cls;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line"></span><br><span class="line">    cls = (Class)<span class="keyword">this</span>;</span><br><span class="line">    metacls = cls-&gt;<span class="built_in">ISA</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关于alloc/dealloc/Retain/Release等特殊方法的判断及处理</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">    metacls-&gt;<span class="built_in">changeInfo</span>(RW_INITIALIZED, RW_INITIALIZING);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLoadable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// any class registered for +load is definitely loadable</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取load方法的IMP</span></span><br><span class="line"><span class="function">IMP <span class="title">objc_class::getLoadMethod</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    runtimeLock.<span class="built_in">assertLocked</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">method_list_t</span> *mlist;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">ISA</span>()-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="built_in">assert</span>(!<span class="built_in">isMetaClass</span>());</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">ISA</span>()-&gt;<span class="built_in">isMetaClass</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在类的基础方法列表中查询load方法的IMP</span></span><br><span class="line">    mlist = <span class="built_in">ISA</span>()-&gt;<span class="built_in">data</span>()-&gt;ro-&gt;<span class="built_in">baseMethods</span>();</span><br><span class="line">    <span class="keyword">if</span> (mlist) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; meth : *mlist) &#123;</span><br><span class="line">            <span class="keyword">const</span> <span class="keyword">char</span> *name = <span class="built_in">sel_cname</span>(meth.name);</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> == <span class="built_in">strcmp</span>(name, <span class="string">&quot;load&quot;</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> meth.imp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runtime是否已认识/实现类</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRealized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_REALIZED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否future class</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isFuture</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;flags &amp; RW_FUTURE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-5-方法-类状态获取"><a href="#2-2-5-方法-类状态获取" class="headerlink" title="2.2.5 方法: 类状态获取"></a>2.2.5 方法: 类状态获取</h3><p><code>objc_class</code>结构体中类的基本状态查询的函数代码如下。注意<code>Class getMeta()</code>获取元类时：对于元类，<code>getMeta()</code>返回的结果与<code>ISA()</code>返回的结果不相同，对于非元类，两者则是相同的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isARC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;flags &amp; RO_IS_ARC;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMetaClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;flags &amp; RO_META;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isMetaClassMaybeUnrealized</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bits.<span class="built_in">safe_ro</span>()-&gt;flags &amp; RO_META;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Class <span class="title">getMeta</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isMetaClass</span>()) <span class="keyword">return</span> (Class)<span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">ISA</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRootClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> superclass == nil;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isRootMetaclass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">ISA</span>() == (Class)<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">mangledName</span><span class="params">()</span> </span>&#123; </span><br><span class="line">    <span class="built_in">assert</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isRealized</span>()  ||  <span class="built_in">isFuture</span>()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;name;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in"><span class="keyword">return</span></span> ((<span class="keyword">const</span> <span class="keyword">class_ro_t</span> *)<span class="built_in">data</span>())-&gt;name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">demangledName</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">nameForLogging</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-6-方法-内存分配"><a href="#2-2-6-方法-内存分配" class="headerlink" title="2.2.6 方法: 内存分配"></a>2.2.6 方法: 内存分配</h3><p>根据类的信息构建对象时，需要根据类的继承链上的所有成员变量的内存布局为成员变量数据分配内存空间，分配内存空间的大小固定的，并按 WORD 对齐，调用<code>size_t class_getInstanceSize(Class cls)</code>实际是调用了<code>objc_class</code>结构体的<code>uint32_t alignedInstanceSize()</code>函数。</p>
<p>成员变量在实例内存空间中偏移量同样也是固定的，同样也是按 WORD 对齐。实例的第一个成员变量内存空间的在实例空间中的偏移量，实际是通过调用<code>objc_class</code>结构体的<code>uint32_t alignedInstanceStart()</code>函数获取。</p>
<p><code>objc_class</code>结构体中涉及内存分配的函数代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 类的实例的成员变量起始地址可能不按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">unalignedInstanceStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;instanceStart;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例的成员变量起始地址按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceStart</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类的实例大小可能因为ivar的alignment值而不按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">unalignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">data</span>()-&gt;ro-&gt;instanceSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例大小按WORD对齐</span></span><br><span class="line">    <span class="function"><span class="keyword">uint32_t</span> <span class="title">alignedInstanceSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">word_align</span>(<span class="built_in">unalignedInstanceSize</span>());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取类的实例大小</span></span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">instanceSize</span><span class="params">(<span class="keyword">size_t</span> extraBytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">size_t</span> size = <span class="built_in">alignedInstanceSize</span>() + extraBytes;</span><br><span class="line">        <span class="comment">// CF requires all objects be at least 16 bytes. （TODO：不懂为啥）</span></span><br><span class="line">        <span class="keyword">if</span> (size &lt; <span class="number">16</span>) size = <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 配置类的实例大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setInstanceSize</span><span class="params">(<span class="keyword">uint32_t</span> newSize)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(<span class="built_in">isRealized</span>());</span><br><span class="line">        <span class="keyword">if</span> (newSize != <span class="built_in">data</span>()-&gt;ro-&gt;instanceSize) &#123;</span><br><span class="line">            <span class="built_in">assert</span>(<span class="built_in">data</span>()-&gt;flags &amp; RW_COPIED_RO);</span><br><span class="line">            *<span class="keyword">const_cast</span>&lt;<span class="keyword">uint32_t</span> *&gt;(&amp;<span class="built_in">data</span>()-&gt;ro-&gt;instanceSize) = newSize;</span><br><span class="line">        &#125;</span><br><span class="line">        bits.<span class="built_in">setFastInstanceSize</span>(newSize);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-3-class-rw-t"><a href="#2-3-class-rw-t" class="headerlink" title="2.3 class_rw_t"></a>2.3 class_rw_t</h2><p>类的主要数据保存在<code>bits</code>中，<code>bits</code>以位图保存<code>class_rw_t</code>结构体，用于记录类的关键数据，如成员变量列表、方法列表、属性列表、协议列表等等，<code>class_rw_t</code>仅包含三个基本的位操作方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __ARM_ARCH_7K__ &gt;= 2  ||  (__arm64__ &amp;&amp; !__LP64__)</span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_INDEXED_ISA 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#   <span class="meta-keyword">define</span> SUPPORT_INDEXED_ISA 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_rw_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;       <span class="comment">// 标记类的状态;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> version;     <span class="comment">// 标记类的类型，0表示类为非元类，7表示类为元类；</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">class_ro_t</span> *ro; <span class="comment">// 保存类的只读数据，注册类后ro中的数据标记为只读，成员变量列表保存在ro中；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">method_array_t</span> methods;      <span class="comment">// 方法列表，其类型method_array_t  为二维数组容器；</span></span><br><span class="line">    <span class="keyword">property_array_t</span> properties; <span class="comment">// 属性列表，其类型property_array_t为二维数组容器；</span></span><br><span class="line">    <span class="keyword">protocol_array_t</span> protocols;  <span class="comment">// 协议列表，其类型protocol_array_t为二维数组容器；</span></span><br><span class="line">    </span><br><span class="line">    Class firstSubclass;    <span class="comment">// 类的首个子类，与nextSiblingClass记录所有类的继承链组织成的继承树；</span></span><br><span class="line">    Class nextSiblingClass; <span class="comment">// 类的下一个兄弟类；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> *demangledName;    <span class="comment">// 类名，来自Swift的类会包含一些特别前缀，demangledName是处理后的类名；</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> SUPPORT_INDEXED_ISA</span></span><br><span class="line">    <span class="keyword">uint32_t</span> index;      <span class="comment">// 标记类的对象的isa是否为index类型；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置set指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setFlags</span><span class="params">(<span class="keyword">uint32_t</span> set)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">OSAtomicOr32Barrier</span>(set, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清空clear指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clearFlags</span><span class="params">(<span class="keyword">uint32_t</span> clear)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">OSAtomicXor32Barrier</span>(clear, &amp;flags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置set指定的位，清空clear指定的位</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeFlags</span><span class="params">(<span class="keyword">uint32_t</span> set, <span class="keyword">uint32_t</span> clear)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>((set &amp; clear) == <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">uint32_t</span> oldf, newf;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldf = flags;</span><br><span class="line">            newf = (oldf | set) &amp; ~clear;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!<span class="built_in">OSAtomicCompareAndSwap32Barrier</span>(oldf, newf, (<span class="keyword">volatile</span> <span class="keyword">int32_t</span> *)&amp;flags));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="2-4-class-ro-t"><a href="#2-4-class-ro-t" class="headerlink" title="2.4 class_ro_t"></a>2.4 class_ro_t</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">class_ro_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;         <span class="comment">// 标记类的状态。需要注意class_ro_t的flags的值和前面介绍的class_rw_t的flags的值是完全不同的；</span></span><br><span class="line">    <span class="keyword">uint32_t</span> instanceStart; <span class="comment">// 类的成员变量，在实例的内存空间中的起始偏移量；</span></span><br><span class="line">    <span class="keyword">uint32_t</span> instanceSize;  <span class="comment">// 类的实例占用的内存空间大小；</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __LP64__</span></span><br><span class="line">    <span class="keyword">uint32_t</span> reserved;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * ivarLayout;     <span class="comment">// strong成员变量内存布局。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> * name;              <span class="comment">// 类名；</span></span><br><span class="line">    <span class="keyword">method_list_t</span> * baseMethodList; <span class="comment">// 基础方法列表，在类定义时指定的方法列表；</span></span><br><span class="line">    <span class="keyword">protocol_list_t</span> * baseProtocols;<span class="comment">// 协议列表；</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">ivar_list_t</span> * ivars;      <span class="comment">// 成员变量列表；</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint8_t</span> * weakIvarLayout; <span class="comment">// weak成员变量布局；</span></span><br><span class="line">    <span class="keyword">property_list_t</span> *baseProperties;<span class="comment">// 基础属性列表，在类定义时指定的属性列表；</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">method_list_t</span> *<span class="title">baseMethods</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> baseMethodList;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">class_ro_t</span> *<span class="title">duplicate</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (flags &amp; RO_HAS_SWIFT_INITIALIZER) &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>) + <span class="built_in"><span class="keyword">sizeof</span></span>(_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">memdup</span>(<span class="keyword">this</span>, size);</span><br><span class="line">            ro-&gt;_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>] = <span class="keyword">this</span>-&gt;_swiftMetadataInitializer_NEVER_USE[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">return</span> ro;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = <span class="built_in"><span class="keyword">sizeof</span></span>(*<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">class_ro_t</span> *ro = (<span class="keyword">class_ro_t</span> *)<span class="built_in">memdup</span>(<span class="keyword">this</span>, size);</span><br><span class="line">            <span class="keyword">return</span> ro;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-1-ivarLayout与weakIvarLayout"><a href="#2-4-1-ivarLayout与weakIvarLayout" class="headerlink" title="2.4.1 ivarLayout与weakIvarLayout"></a>2.4.1 ivarLayout与weakIvarLayout</h3><h4 id="1-值的存储格式"><a href="#1-值的存储格式" class="headerlink" title="1. 值的存储格式"></a>1. 值的存储格式</h4><p>ivarLayout 和 weakIvarLayout 这两个编码值，结合起来，就可以确定<strong>自上而下</strong>，哪些 ivar 是strong、weak，确定了这两种之后，剩余的就都是基本类型和 __unsafe_unretained 的对象类型。</p>
<p>这两者都是 <code>const uint8_t *</code> 类型，但读取值的时候，需要注意，不是以char(1字节)为单位来读取的，而是：</p>
<ul>
<li><strong>4bit为一位，1字节为一对</strong>，即<strong>从两者首地址开始，1字节分为一对</strong>来读取</li>
<li>以两位 <strong>00</strong> 为结束符，就像 cstring 的 <strong>\0</strong> 一样</li>
</ul>
<p>ivarLayout 的每1位(4bit)依次表示：成员变量自上而下，多少个 <strong>非 strong</strong> 成员变量、多少个 <strong>strong</strong> 成员变量…(<strong>循环</strong>)…直到最后一个strong出现的位置(后面的就不记录了)。</p>
<p>weakIvarLayout 的每1位(4bit)依次表示：成员变量自上而下，多少个 <strong>非 weak</strong> 成员变量、多少个 <strong>weak</strong> 成员变量…(<strong>循环</strong>)…直到最后一个weak出现的位置(后面的就不记录了)。</p>
<h4 id="2-操作函数"><a href="#2-操作函数" class="headerlink" title="2. 操作函数"></a>2. 操作函数</h4><p>这两个值可以通过 runtime 提供的几个 API 来访问：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> <span class="keyword">uint8_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="title">class_getIvarLayout</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">uint8_t</span> *<span class="title">class_getWeakIvarLayout</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setIvarLayout</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *layout)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setWeakIvarLayout</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">uint8_t</span> *layout)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-示例"><a href="#3-示例" class="headerlink" title="3. 示例"></a>3. 示例</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Foo</span> : <span class="title">NSObject</span></span>&#123;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar0;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar1;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> ivar2;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar3;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar4;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar5;</span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> ivar6;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar7;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> ivar8;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="keyword">id</span> ivv;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span> ivv1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="keyword">const</span> uint8_t * strongLayout = class_getIvarLayout(Foo.class);</span><br><span class="line"><span class="keyword">const</span> uint8_t * weakLayout = class_getWeakIvarLayout(Foo.class);</span><br><span class="line"></span><br><span class="line">(lldb) p strongLayout</span><br><span class="line">(<span class="keyword">const</span> uint8_t *) $<span class="number">0</span> = <span class="number">0x000000010d6c1246</span> <span class="string">&quot;\U00000011!#&quot;</span></span><br><span class="line">(lldb) p weakLayout</span><br><span class="line">(<span class="keyword">const</span> uint8_t *) $<span class="number">1</span> = <span class="number">0x000000010d6c124a</span> <span class="string">&quot;\U00000001!\U000000121&quot;</span></span><br><span class="line">(lldb) x/<span class="number">4</span>xb $<span class="number">0</span></span><br><span class="line"><span class="number">0x10d6c1246</span>: <span class="number">0x11</span> <span class="number">0x21</span> <span class="number">0x23</span> <span class="number">0x00</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   解释：</span></span><br><span class="line"><span class="comment">   0x11: 1个非strong、1个strong</span></span><br><span class="line"><span class="comment">   0x21: 2个非strong、1个strong</span></span><br><span class="line"><span class="comment">   0x23: 2个非strong、3个strong （后面还有个weak就不记录了）</span></span><br><span class="line"><span class="comment">   0x00: 结束符</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">(lldb) x/<span class="number">5</span>xb $<span class="number">1</span></span><br><span class="line"><span class="number">0x10d6c124a</span>: <span class="number">0x01</span> <span class="number">0x21</span> <span class="number">0x12</span> <span class="number">0x31</span> <span class="number">0x00</span></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   解释：</span></span><br><span class="line"><span class="comment">   0x01: 0个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x21: 2个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x12: 1个非weak、2个weak</span></span><br><span class="line"><span class="comment">   0x31: 3个非weak、1个weak</span></span><br><span class="line"><span class="comment">   0x00: 结束符</span></span><br><span class="line"><span class="comment">   */</span></span><br></pre></td></tr></table></figure>

<h4 id="4-使用场景"><a href="#4-使用场景" class="headerlink" title="4. 使用场景"></a>4. 使用场景</h4><p><a target="_blank" rel="noopener" href="http://blog.sunnyxx.com/2015/09/13/class-ivar-layout/">原文链接：Objective-C Class Ivar Layout 探索</a></p>
<p>当我们定义一个类的实例变量的时候，可以指定其修饰符：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Sark</span> : <span class="title">NSObject</span> </span>&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">id</span> _gayFriend; <span class="comment">// 无修饰符的对象默认会加 __strong</span></span><br><span class="line">    __<span class="keyword">weak</span> <span class="keyword">id</span> _girlFriend;</span><br><span class="line">    __<span class="keyword">unsafe_unretained</span> <span class="keyword">id</span> _company;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>这使得 ivar (instance variable) 可以像属性一样在 ARC 下进行正确的引用计数管理。</p>
<p>那么问题来了，假如这个类是动态生成的：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">class</span> = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">&quot;Sark&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">objc_registerClassPair(<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure>

<p>该如何像上面一样来添加 ivar 的属性修饰符呢？假如依次设置strong、weak、strong修饰符</p>
<p>第一步：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在objc_registerClassPair(class);前加上这么两句</span></span><br><span class="line">class_setIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x01\x11\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">class_setWeakIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x11\x10\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br></pre></td></tr></table></figure>

<p>第二步：</p>
<p>此时，strong 和 weak 的内存管理并没有生效，继续研究发现， class 的 flags 中有一个标记位记录这个类是否 ARC，正常编译的类，且标识了 <strong>-fobjc-arc</strong> flag 时，这个标记位为 1，而动态创建的类并没有设置它。所以只能继续黑魔法，运行时把这个标记位设置上，探索过程不赘述了，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fixup_class_arc</span><span class="params">(Class class)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        Class isa;</span><br><span class="line">        Class superclass;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">void</span> *_buckets;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __LP64__</span></span><br><span class="line">            <span class="keyword">uint32_t</span> _mask;</span><br><span class="line">            <span class="keyword">uint32_t</span> _occupied;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">            <span class="keyword">uint16_t</span> _mask;</span><br><span class="line">            <span class="keyword">uint16_t</span> _occupied;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        &#125; cache;</span><br><span class="line">        <span class="keyword">uintptr_t</span> bits;</span><br><span class="line">    &#125; *objcClass = (__bridge <span class="built_in">typeof</span>(objcClass))class;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !__LP64__</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK 0xfffffffcUL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FAST_DATA_MASK 0x00007ffffffffff8UL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="keyword">uint32_t</span> flags;</span><br><span class="line">        <span class="keyword">uint32_t</span> version;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="keyword">uint32_t</span> flags;</span><br><span class="line">        &#125; *ro;</span><br><span class="line">    &#125; *objcRWClass = (<span class="built_in">typeof</span>(objcRWClass))(objcClass-&gt;bits &amp; FAST_DATA_MASK);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RO_IS_ARR 1&lt;&lt;7    </span></span><br><span class="line">    objcRWClass-&gt;ro-&gt;flags |= RO_IS_ARR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把这个 fixup 放在 <code>objc_registerClassPair(class);</code> 之后，这个动态的类终于可以像静态编译的类一样操作 ivar 了。</p>
<p>完整的示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">Class <span class="keyword">class</span> = objc_allocateClassPair(<span class="built_in">NSObject</span>.class, <span class="string">&quot;Sark&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_addIvar(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>, <span class="keyword">sizeof</span>(<span class="keyword">id</span>), log2(<span class="keyword">sizeof</span>(<span class="keyword">id</span>)), <span class="keyword">@encode</span>(<span class="keyword">id</span>));</span><br><span class="line">class_setIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x01\x11\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">class_setWeakIvarLayout(<span class="keyword">class</span>, (<span class="keyword">const</span> uint8_t *)<span class="string">&quot;\x11\x10\x00&quot;</span>); <span class="comment">// &lt;--- new</span></span><br><span class="line">objc_registerClassPair(<span class="keyword">class</span>);</span><br><span class="line">fixup_class_arc(<span class="keyword">class</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> sark = [<span class="keyword">class</span> new];</span><br><span class="line">Ivar strongIvar = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_gayFriend&quot;</span>);</span><br><span class="line">Ivar weakIvar = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_girlFriend&quot;</span>);</span><br><span class="line">Ivar strongIvar2 = class_getInstanceVariable(<span class="keyword">class</span>, <span class="string">&quot;_company&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">id</span> boy = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">id</span> girl = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    <span class="keyword">id</span> boy2 = [<span class="built_in">NSObject</span> new];</span><br><span class="line">    object_setIvar(sark, strongIvar, boy);</span><br><span class="line">    object_setIvar(sark, weakIvar, girl);</span><br><span class="line">    object_setIvar(sark, strongIvar2, boy2);</span><br><span class="line">&#125; <span class="comment">// ARC 在这里会对大括号内的 girl、boy、boy2 做一次release</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %@, %@&quot;</span>, object_getIvar(sark, strongIvar),  <span class="comment">//&lt;NSObject: 0x600000934660&gt;</span></span><br><span class="line">                     object_getIvar(sark, weakIvar),    <span class="comment">//nil</span></span><br><span class="line">                     object_getIvar(sark, strongIvar2));<span class="comment">//&lt;NSObject: 0x6000009346a0&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-4-2-几点总结"><a href="#2-4-2-几点总结" class="headerlink" title="2.4.2 几点总结"></a>2.4.2 几点总结</h3><ul>
<li>property在编译期会生成 _propertyName 的ivar，和相应的get/set方法。</li>
<li>ivars在编译期确定，但不完全确定，offset属性在运行时会修改。</li>
<li>对象的大小是由ivars决定的，当有继承体系时，父类的ivars永远放在子类之前。</li>
<li>class_ro_t 的 instanceStart 和 instanceSize 会在运行时调整。</li>
<li>class_ro_t 的 ivarLayout 和 weakIvarLayout 存放的是强ivar和弱ivar的存储规则。</li>
</ul>
<h2 id="2-5-元类-Meta-Class"><a href="#2-5-元类-Meta-Class" class="headerlink" title="2.5 元类(Meta Class)"></a>2.5 元类(Meta Class)</h2><h3 id="2-5-1-为什么存在元类？"><a href="#2-5-1-为什么存在元类？" class="headerlink" title="2.5.1 为什么存在元类？"></a>2.5.1 为什么存在元类？</h3><p><strong>在调用类方法的时候，为了和对象查找方法的机制一致，遂引入了元类(meta-class)的概念。</strong></p>
<ul>
<li>对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。</li>
<li>类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</li>
</ul>
<p>meta-class之所以重要，是因为它存储着一个类的所有类方法。每个类都会有自己独一无二的meta-class，因为每个类的类方法基本不可能完全相同。</p>
<blockquote>
<p>以下元类的相关内容，都来自 <a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.cocoawithlove.com/2010/01/what-is-meta-class-in-objective-c.html">What is a meta-class in Objective-C?</a> 这篇文章。</p>
</blockquote>
<h3 id="2-5-2-元类的isa-—-类"><a href="#2-5-2-元类的isa-—-类" class="headerlink" title="2.5.2 元类的isa — 类"></a>2.5.2 元类的isa — 类</h3><p>元类，和类的结构是一样的 objc_class，所以也是一个对象。这表示你能够对元类调用方法。自然的，这表示它必须也有一个类指针。</p>
<ul>
<li>类创建对象，调用的是实例方法</li>
<li>元类创建类对象，调用的是类方法。</li>
</ul>
<p>所有元类使用基类的元类（即继承链顶端的类的元类）作为它们的类，而所有类的基类都是 NSObject（大多数类是这样的）。所以：</p>
<ul>
<li>大多数元类使用 NSObject 的元类作为它的类。</li>
<li>基类的元类就是它自己的类，即NSObject的元类的isa指针指向的是它自己（它是一个它自己的实例）。</li>
</ul>
<h3 id="2-5-3-元类的superclass-—-父类"><a href="#2-5-3-元类的superclass-—-父类" class="headerlink" title="2.5.3 元类的superclass — 父类"></a>2.5.3 元类的superclass — 父类</h3><p>同样的，类使用 super_class 指针指向他们的 superclass，元类也有 super_class 指针来指向 superclass。</p>
<p>这里又有一个奇怪的地方，基类的元类设置的 superclass 是基类自己 (<strong>NSObject-&gt;isa-&gt;superclass = NSObject</strong>)。</p>
<p>这种继承结构导致的结果是所有结构中的实例、类以及元类都继承自结构中的基类。</p>
<h3 id="2-5-4-总结"><a href="#2-5-4-总结" class="headerlink" title="2.5.4 总结"></a>2.5.4 总结</h3><p>所有这些用文字描述起来可能比较容易让人困惑。<a target="_blank" rel="noopener" href="https://link.jianshu.com/?t=http://www.sealiesoftware.com/blog/archive/2009/04/14/objc_explain_Classes_and_metaclasses.html">Greg Parker的文章</a>中有一张附图描述了实例、类和元类以及他们的super class是如何完美的共存的。</p>
<img src="/images/runtime/01.png" alt="01" style="zoom:85%;" />

<p>可以看到，所有的meta class 与 Root class 的 isa 都指向 Root class 的meta class，这样能够形成一个闭环。</p>
<p>实现了：</p>
<ul>
<li>所有 NSObject 的实例方法，都能够被 <strong>任何实例、类、元类</strong> 来使用；</li>
<li>所有 NSObject 的类方法，都能够被 <strong>任何类、元类</strong> 来使用。</li>
</ul>
<p>即实现了<strong>Objc中的任意 objc_object 对象，都继承自NSObject。NSObject为所有的对象定义了一些相同的特性</strong>。</p>
<h2 id="2-6-类与对象操作函数"><a href="#2-6-类与对象操作函数" class="headerlink" title="2.6 类与对象操作函数"></a>2.6 类与对象操作函数</h2><p>runtime有很多的函数可以操作类和对象。通常，操作类的是class为前缀，操作对象的是objc或object_为前缀(因为class也是一种Object，所以有的objc或object为前缀的函数也可以操作类对象)。</p>
<h3 id="2-6-1-类型获取和判断函数"><a href="#2-6-1-类型获取和判断函数" class="headerlink" title="2.6.1 类型获取和判断函数"></a>2.6.1 类型获取和判断函数</h3><h4 id="1-类型获取"><a href="#1-类型获取" class="headerlink" title="1. 类型获取"></a>1. 类型获取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  传入字符串类名，返回对应的类对象</span></span><br><span class="line"><span class="comment">  Return the id of the named class.  If the class does not exist, call _objc_classLoader and then objc_classHandler, either of which may create a new class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!aClassName) <span class="keyword">return</span> Nil;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NO unconnected, YES class handler</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">look_up_class</span>(aClassName, NO, YES);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 传入的obj可能是instance对象、class对象、meta-class对象</span></span><br><span class="line"><span class="comment"> 返回:</span></span><br><span class="line"><span class="comment">  a) 如果是instance对象，返回class对象</span></span><br><span class="line"><span class="comment">  b) 如果是class对象，返回meta-class对象</span></span><br><span class="line"><span class="comment">  c) 如果是meta-class对象，返回NSObject（基类）的meta-class对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj) <span class="keyword">return</span> obj-&gt;<span class="built_in">getIsa</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Nil;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 返回的就是类对象</span></span><br><span class="line">- (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getClass</span>(self);</span><br><span class="line">&#125;</span><br><span class="line">+ (Class)<span class="class"><span class="keyword">class</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-类型判断"><a href="#2-类型判断" class="headerlink" title="2. 类型判断"></a>2. 类型判断</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者的类是不是cls类</span></span><br><span class="line"><span class="comment">    id person = [[MJPerson alloc] init];</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isMemberOfClass:[MJPerson class]]);  // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isMemberOfClass:[NSObject class]]);  // 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> [self class] == cls;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者(类对象)的类(即元类)是不是cls。(cls需要传入元类，才有可能返回YES)</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isMemberOfClass:object_getClass([MJPerson class])]); // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isMemberOfClass:[NSObject class]]); // 0 类对象的类怎么可能还是class</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)isMemberOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">object_getClass</span>((id)self) == cls;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者的类是不是cls类、或者cls子类</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isKindOfClass:[MJPerson class]]);  // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [person isKindOfClass:[NSObject class]]);  // 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = [self class]; tcls; tcls = tcls.superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 判断调用者(类对象)的类(即元类)是不是cls、或者cls子类。(cls需要传入元类，才有可能返回YES)</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:object_getClass([NSObject class])]); // 1</span></span><br><span class="line"><span class="comment">    NSLog(@&quot;%d&quot;, [MJPerson isKindOfClass:[NSObject class]]); // 1 特殊的NSObject，NSObject是所有元类的最顶部父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (BOOL)isKindOfClass:(Class)cls &#123;</span><br><span class="line">    <span class="keyword">for</span> (Class tcls = <span class="built_in">object_getClass</span>((id)self); tcls; tcls = tcls.superclass) &#123;</span><br><span class="line">        <span class="keyword">if</span> (tcls == cls) <span class="keyword">return</span> YES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-判断是否是元类"><a href="#3-判断是否是元类" class="headerlink" title="3. 判断是否是元类"></a>3. 判断是否是元类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断给定的Class是否是一个meta class</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_isMetaClass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> NO;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">isMetaClass</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-2-类相关操作函数"><a href="#2-6-2-类相关操作函数" class="headerlink" title="2.6.2 类相关操作函数"></a>2.6.2 类相关操作函数</h3><h4 id="1-获取name"><a href="#1-获取name" class="headerlink" title="1. 获取name"></a>1. 获取name</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">class_getName</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="string">&quot;nil&quot;</span>;</span><br><span class="line">    <span class="comment">// fixme lldb calls class_getName() on unrealized classes (rdar://27258517)</span></span><br><span class="line">    <span class="comment">// ASSERT(cls-&gt;isRealized()  ||  cls-&gt;isFuture());</span></span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">demangledName</span>(<span class="comment">/* needs lock */</span><span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>名字修饰</strong>（name decoration），也称为<strong>名字重整</strong>、<strong>名字改编</strong>（name mangling），是现代计算机程序设计语言的编译器用于解决由于程序实体的名字必须唯一而导致的问题的一种技术。</p>
<p>demangledName: 去除修饰的名称。</p>
</blockquote>
<h4 id="2-获取super-class"><a href="#2-获取super-class" class="headerlink" title="2. 获取super_class"></a>2. 获取super_class</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取类的父类</span></span><br><span class="line"><span class="function">Class <span class="title">class_getSuperclass</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;superclass;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-获取instance-size"><a href="#3-获取instance-size" class="headerlink" title="3. 获取instance_size"></a>3. 获取instance_size</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取实例大小</span></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">class_getInstanceSize</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">alignedInstanceSize</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-成员变量-ivars-操作"><a href="#4-成员变量-ivars-操作" class="headerlink" title="4. 成员变量(ivars)操作"></a>4. 成员变量(ivars)操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;</span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类中指定名称实例成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getInstanceVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls  ||  !name) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> _class_getVariable(cls, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类成员变量的信息</span></span><br><span class="line"><span class="function">Ivar <span class="title">class_getClassVariable</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> nil;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">class_getInstanceVariable</span>(cls-&gt;<span class="built_in">ISA</span>(), name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加成员变量(这个只能够向在runtime时创建的类添加成员变量)</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span><span class="params">(Class cls, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">size_t</span> size, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uint8_t</span> alignment, </span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 获取整个成员变量列表(必须使用free()来释放这个数组)</span></span></span><br><span class="line"><span class="function">Ivar * <span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="5-方法操作"><a href="#5-方法操作" class="headerlink" title="5. 方法操作"></a>5. 方法操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取实例方法。注意：如果这个类中没有实现selector这个方法，会沿着继承链向上找到为止，即可能会返回它某父类中的Method对象</span></span><br><span class="line"><span class="function">Method <span class="title">class_getInstanceMethod</span> <span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取类方法</span></span><br><span class="line"><span class="function">Method <span class="title">class_getClassMethod</span> <span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有方法的数组</span></span><br><span class="line"><span class="function">Method * <span class="title">class_copyMethodList</span> <span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加方法. 和成员变量不同的是可以为类动态添加方法。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  class_addMethod可以添加父类中方法实现的override，但不会替换该类中的现有实现。</span></span><br><span class="line"><span class="comment">  如果已有同名的方法实现（包含分类中的方法）会返回NO。要更改现有的实现，请使用method_setImplementation。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 替代方法的实现。返回cls标识的类中，name标识的方法的以前实现。</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果通过名称标识的方法还不存在(本类、分类中都没实现)，就会像调用class_addMethod一样添加它。使用由types指定的类型编码。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回：NULL</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果通过名称标识的方法确实存在(本类或分类中实现了)，那么它的IMP将被替换，就像调用了method_setImplementation一样。类型指定的类型编码将被忽略。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回：SEL name之前的实现IMP</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">IMP <span class="title">class_replaceMethod</span><span class="params">(Class cls, SEL name, IMP imp, <span class="keyword">const</span> <span class="keyword">char</span> *types)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回方法的具体实现</span></span></span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"><span class="function">IMP <span class="title">class_getMethodImplementation_stret</span><span class="params">(Class cls, SEL name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类实例是否响应指定的selector</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_respondsToSelector</span><span class="params">(Class cls, SEL sel)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="6-协议操作"><a href="#6-协议操作" class="headerlink" title="6. 协议操作"></a>6. 协议操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addProtocol</span><span class="params">(Class cls, Protocol *protocol_gen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类是否实现指定的协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">class_conformsToProtocol</span><span class="params">(Class cls, Protocol *proto_gen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回类实现的协议列表</span></span><br><span class="line"><span class="function">Protocol * <span class="title">class_copyProtocolList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="7-获取版本号"><a href="#7-获取版本号" class="headerlink" title="7. 获取版本号"></a>7. 获取版本号</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取版本号 0表示类为非元类，7表示类为元类；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">class_getVersion</span><span class="params">(Class cls)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!cls) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">assert</span>(cls-&gt;<span class="built_in">isRealized</span>());</span><br><span class="line">    <span class="keyword">return</span> cls-&gt;<span class="built_in">data</span>()-&gt;version;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置版本号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_setVersion</span> <span class="params">( Class cls, <span class="keyword">int</span> version )</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="8-示例"><a href="#8-示例" class="headerlink" title="8. 示例"></a>8. 示例</h4><p>通过示例来消化下上面的那些函数</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// MyClass.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> : <span class="title">NSObject</span> &lt;<span class="title">NSCopying</span>, <span class="title">NSCoding</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSArray</span> *array;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="built_in">NSString</span> *string;</span><br><span class="line">- (<span class="keyword">void</span>)method1;</span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line">+ (<span class="keyword">void</span>)classMethod1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// MyClass.m</span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyClass</span> () </span>&#123;</span><br><span class="line"><span class="built_in">NSInteger</span> _instance1;</span><br><span class="line"><span class="built_in">NSString</span> * _instance2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">assign</span>) <span class="built_in">NSUInteger</span> integer;</span><br><span class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)classMethod1 &#123;&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123; <span class="built_in">NSLog</span>(<span class="string">@&quot;call method method1&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123; &#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)method3WithArg1:(<span class="built_in">NSInteger</span>)arg1 arg2:(<span class="built_in">NSString</span> *)arg2 &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;arg1 : %ld, arg2 : %@&quot;</span>, arg1, arg2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//-----------------------------------------------------------</span></span><br><span class="line"><span class="comment">// main.h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MyClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&quot;MySubClass.h&quot;</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> main(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[]) &#123;</span><br><span class="line">     <span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">          MyClass *myClass = [[MyClass alloc] init];</span><br><span class="line">          <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">          Class cls = myClass.class;</span><br><span class="line">          <span class="comment">// 类名</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;class name: %s&quot;</span>, class_getName(cls));    </span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 父类</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;super class name: %s&quot;</span>, class_getName(class_getSuperclass(cls)));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 是否是元类</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is %@ a meta-class&quot;</span>, (class_isMetaClass(cls) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot;not&quot;</span>));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          Class meta_class = objc_getMetaClass(class_getName(cls));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&#x27;s meta-class is %s&quot;</span>, class_getName(cls), class_getName(meta_class));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 变量实例大小</span></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;instance size: %zu&quot;</span>, class_getInstanceSize(cls));</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 成员变量</span></span><br><span class="line">          Ivar *ivars = class_copyIvarList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               Ivar ivar = ivars[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;instance variable&#x27;s name: %s at index: %d&quot;</span>, ivar_getName(ivar), i);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(ivars);</span><br><span class="line"></span><br><span class="line">          Ivar string = class_getInstanceVariable(cls, <span class="string">&quot;_string&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (string != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;instace variable %s&quot;</span>, ivar_getName(string));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 属性操作</span></span><br><span class="line">          objc_property_t * properties = class_copyPropertyList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               objc_property_t property = properties[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;property&#x27;s name: %s&quot;</span>, property_getName(property));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(properties);</span><br><span class="line"></span><br><span class="line">          objc_property_t array = class_getProperty(cls, <span class="string">&quot;array&quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> (array != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;property %s&quot;</span>, property_getName(array));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 方法操作</span></span><br><span class="line">          Method *methods = class_copyMethodList(cls, &amp;outCount);</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               Method method = methods[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;method&#x27;s signature: %s&quot;</span>, method_getName(method));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          free(methods);</span><br><span class="line"></span><br><span class="line">          Method method1 = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(method1));</span><br><span class="line">          <span class="keyword">if</span> (method1 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;method %s&quot;</span>, method_getName(method1));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          Method classMethod = class_getClassMethod(cls, <span class="keyword">@selector</span>(classMethod1));</span><br><span class="line">          <span class="keyword">if</span> (classMethod != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;class method : %s&quot;</span>, method_getName(classMethod));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is%@ responsd to selector: method3WithArg1:arg2:&quot;</span>, class_respondsToSelector(cls, <span class="keyword">@selector</span>(method3WithArg1:arg2:)) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot; not&quot;</span>);</span><br><span class="line"></span><br><span class="line">          IMP imp = class_getMethodImplementation(cls, <span class="keyword">@selector</span>(method1));</span><br><span class="line">          imp();</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 协议</span></span><br><span class="line">          Protocol * __<span class="keyword">unsafe_unretained</span> * protocols = class_copyProtocolList(cls, &amp;outCount);</span><br><span class="line">          Protocol * protocol;</span><br><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">               protocol = protocols[i];</span><br><span class="line">               <span class="built_in">NSLog</span>(<span class="string">@&quot;protocol name: %s&quot;</span>, protocol_getName(protocol));</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;MyClass is%@ responsed to protocol %s&quot;</span>, class_conformsToProtocol(cls, protocol) ? <span class="string">@&quot;&quot;</span> : <span class="string">@&quot; not&quot;</span>, protocol_getName(protocol));</span><br><span class="line"></span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;==========================================================&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.452</span> RuntimeTest <span class="keyword">class</span> name: MyClass</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.453</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest <span class="keyword">super</span> <span class="keyword">class</span> name: <span class="built_in">NSObject</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest MyClass is not a meta-<span class="keyword">class</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.454</span> RuntimeTest MyClass<span class="string">&#x27;s meta-class is MyClass</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance size: 48</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance variable&#x27;</span>s name: _instance1 at index: <span class="number">0</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.455</span> RuntimeTest instance variable<span class="string">&#x27;s name: _instance2 at index: 1</span></span><br><span class="line"><span class="string">19:41:37.455 RuntimeTest instance variable&#x27;</span>s name: _array at index: <span class="number">2</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.455</span> RuntimeTest instance variable<span class="string">&#x27;s name: _string at index: 3</span></span><br><span class="line"><span class="string">19:41:37.463 RuntimeTest instance variable&#x27;</span>s name: _integer at index: <span class="number">4</span></span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest instace variable _string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest ====================================================</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.463</span> RuntimeTest property<span class="string">&#x27;s name: array</span></span><br><span class="line"><span class="string">19:41:37.463 RuntimeTest property&#x27;</span>s name: string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest property<span class="string">&#x27;s name: integer</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest property array</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest ====================================================</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest method&#x27;</span>s signature: method1</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.464</span> RuntimeTest method<span class="string">&#x27;s signature: method2</span></span><br><span class="line"><span class="string">19:41:37.464 RuntimeTest method&#x27;</span>s signature: method3WithArg1:arg2:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: integer</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: setInteger:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: array</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: string</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.465</span> RuntimeTest method<span class="string">&#x27;s signature: setString:</span></span><br><span class="line"><span class="string">19:41:37.465 RuntimeTest method&#x27;</span>s signature: setArray:</span><br><span class="line"><span class="number">19</span>:<span class="number">41</span>:<span class="number">37.466</span> RuntimeTest method<span class="string">&#x27;s signature: .cxx_destruct</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest method method1</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest class method : classMethod1</span></span><br><span class="line"><span class="string">19:41:37.466 RuntimeTest MyClass is responsd to selector: method3WithArg1:arg2:</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest call method method1</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest =====================================================</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest protocol name: NSCopying</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest protocol name: NSCoding</span></span><br><span class="line"><span class="string">19:41:37.467 RuntimeTest MyClass is responsed to protocol NSCoding</span></span><br><span class="line"><span class="string">19:41:37.468 RuntimeTest ======================================</span></span><br></pre></td></tr></table></figure>

<h3 id="2-6-3-动态创建类和对象"><a href="#2-6-3-动态创建类和对象" class="headerlink" title="2.6.3 动态创建类和对象"></a>2.6.3 动态创建类和对象</h3><h4 id="1-动态创建类"><a href="#1-动态创建类" class="headerlink" title="1. 动态创建类"></a>1. 动态创建类</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 创建一个新类和元类。Creates a new class and metaclass.</span></span><br><span class="line"><span class="comment"> * @prama superclass 如果创建的是root class，则superclass为Nil</span></span><br><span class="line"><span class="comment"> * @prama sextraBytes 通常为0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Class <span class="title">objc_allocateClassPair</span><span class="params">(Class superclass, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> extraBytes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建新类后，使用class_addMethod，class_addIvar函数为新类添加方法、实例变量和属性。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在应用中注册由objc_allocateClassPair创建的类。再之后就能够用了。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerClassPair</span><span class="params">(Class cls)</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 销毁一个类及其相关联的类。在运行中还存在或存在子类实例，就不能够调用这个。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_disposeClassPair</span><span class="params">(Class cls)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>问题：什么是”class pair（类对）”？函数 objc_allocateClassPair 只返回一个值：类。那么这个”class pair（类对）”的另一半呢？从方法注释可以看出来，是元类。</p>
</blockquote>
<p>使用示例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class cls = objc_allocateClassPair(MyClass.class, <span class="string">&quot;MySubClass&quot;</span>, <span class="number">0</span>);</span><br><span class="line">class_addMethod(cls, <span class="keyword">@selector</span>(submethod1), (IMP)imp_submethod1, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">class_replaceMethod(cls, <span class="keyword">@selector</span>(method1), (IMP)imp_submethod1, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">class_addIvar(cls, <span class="string">&quot;_ivar1&quot;</span>, <span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *), log(<span class="keyword">sizeof</span>(<span class="built_in">NSString</span> *)), <span class="string">&quot;i&quot;</span>);</span><br><span class="line"></span><br><span class="line">objc_property_attribute_t type = &#123;<span class="string">&quot;T&quot;</span>, <span class="string">&quot;@\&quot;NSString\&quot;&quot;</span>&#125;;</span><br><span class="line">objc_property_attribute_t ownership = &#123; <span class="string">&quot;C&quot;</span>, <span class="string">&quot;&quot;</span> &#125;;</span><br><span class="line">objc_property_attribute_t backingivar = &#123; <span class="string">&quot;V&quot;</span>, <span class="string">&quot;_ivar1&quot;</span>&#125;;</span><br><span class="line">objc_property_attribute_t attrs[] = &#123;type, ownership, backingivar&#125;;</span><br><span class="line"></span><br><span class="line">class_addProperty(cls, <span class="string">&quot;property2&quot;</span>, attrs, <span class="number">3</span>);</span><br><span class="line">objc_registerClassPair(cls);</span><br><span class="line"></span><br><span class="line"><span class="keyword">id</span> instance = [[cls alloc] init];</span><br><span class="line">[instance performSelector:<span class="keyword">@selector</span>(submethod1)];</span><br><span class="line">[instance performSelector:<span class="keyword">@selector</span>(method1)];</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></span><br><span class="line"><span class="number">11</span>:<span class="number">35</span>:<span class="number">31.006</span> RuntimeTest[<span class="number">3800</span>:<span class="number">66152</span>] run sub method <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h4 id="2-动态创建对象"><a href="#2-动态创建对象" class="headerlink" title="2. 动态创建对象"></a>2. 动态创建对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建类实例。会在heap里给类分配内存。这个方法和+alloc方法类似。</span></span><br><span class="line"><span class="function">id <span class="title">class_createInstance</span><span class="params">(Class cls, <span class="keyword">size_t</span> extraBytes)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 在指定位置创建类实例</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 在bytes所指向的位置创建cls的实例。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * bytes必须至少指向对齐的零填充内存的class_getInstanceSize(cls)字节。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 设置新对象的isa。调用任何c++构造函数。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果成功返回bytes。如果cls或bytes为nil，或c++构造函数失败，则返回nil。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 注意: class_createInstance()和class_createInstances()对此进行了预检。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function">id <span class="title">objc_constructInstance</span><span class="params">(Class cls, <span class="keyword">void</span> *bytes)</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 销毁类实例</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 销毁实例而不释放内存。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 调用 C++ 析构函数。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 调用 ARC ivar 清理。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 移除除关联引用。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回obj。如果obj为nil，则什么都不做。</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">objc_destructInstance</span><span class="params">(id obj)</span> </span>; <span class="comment">//不会释放移除任何相关引用</span></span><br></pre></td></tr></table></figure>

<p>测试下效果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以看出class_createInstance和alloc的不同</span></span><br><span class="line"><span class="keyword">id</span> theObject = class_createInstance(<span class="built_in">NSString</span>.class, <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span>));</span><br><span class="line"><span class="keyword">id</span> str1 = [theObject init];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str1 <span class="keyword">class</span>]);</span><br><span class="line"><span class="keyword">id</span> str2 = [[<span class="built_in">NSString</span> alloc] initWithString:<span class="string">@&quot;test&quot;</span>];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, [str2 <span class="keyword">class</span>]);</span><br></pre></td></tr></table></figure>

<p>输出结果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] <span class="built_in">NSString</span></span><br><span class="line"><span class="number">12</span>:<span class="number">46</span>:<span class="number">50.781</span> RuntimeTest[<span class="number">4039</span>:<span class="number">89088</span>] __NSCFConstantString</span><br></pre></td></tr></table></figure>

<h3 id="2-6-4-实例对象相关操作函数"><a href="#2-6-4-实例对象相关操作函数" class="headerlink" title="2.6.4 实例对象相关操作函数"></a>2.6.4 实例对象相关操作函数</h3><p>这些函数是针对创建的实例对象的一系列操作函数。</p>
<h4 id="1-操作-整个对象-的函数"><a href="#1-操作-整个对象-的函数" class="headerlink" title="1. 操作 整个对象 的函数"></a>1. 操作 整个对象 的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定对象的一份拷贝</span></span><br><span class="line"><span class="function">id <span class="title">object_copy</span><span class="params">(id oldObj, <span class="keyword">size_t</span> extraBytes)</span></span>;</span><br><span class="line"><span class="comment">// 释放指定对象占用的内存</span></span><br><span class="line"><span class="function">id <span class="title">object_dispose</span><span class="params">(id obj)</span></span>;</span><br></pre></td></tr></table></figure>

<p>应用场景</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把a转换成占用更多空间的子类b</span></span><br><span class="line"><span class="built_in">NSObject</span> *a = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> newB = object_copy(a, class_getInstanceSize(MyClass.class));</span><br><span class="line">object_setClass(newB, MyClass.class);</span><br><span class="line">object_dispose(a);</span><br></pre></td></tr></table></figure>

<h4 id="2-操作-对象的类-的函数"><a href="#2-操作-对象的类-的函数" class="headerlink" title="2. 操作 对象的类 的函数"></a>2. 操作 对象的类 的函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定对象的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">object_getClassName</span><span class="params">(id obj)</span></span>;</span><br><span class="line"><span class="comment">// 返回对象的类</span></span><br><span class="line"><span class="function">Class <span class="title">object_getClass</span><span class="params">(id obj)</span></span>;</span><br><span class="line"><span class="comment">// 设置对象的类</span></span><br><span class="line"><span class="function">Class <span class="title">object_setClass</span><span class="params">(id obj, Class cls)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-5-获取类定义"><a href="#2-6-5-获取类定义" class="headerlink" title="2.6.5 获取类定义"></a>2.6.5 获取类定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取已注册的类定义的列表。返回值为已注册类的总数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">objc_getClassList</span><span class="params">(Class *buffer, <span class="keyword">int</span> bufferLen)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 创建并返回一个指向所有已注册类的指针列表</span></span></span><br><span class="line"><span class="function">Class *<span class="title">objc_copyClassList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回指定类的类定义</span></span></span><br><span class="line"><span class="function">Class <span class="title">objc_lookUpClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br><span class="line"><span class="function">Class <span class="title">objc_getRequiredClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>; <span class="comment">// 与objc_getClass相同，但如果没有找到类，则终止进程。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定类的元类</span></span><br><span class="line"><span class="function">Class <span class="title">objc_getMetaClass</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *aClassName)</span></span>;</span><br></pre></td></tr></table></figure>

<p>演示如何使用</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> numClasses;</span><br><span class="line">Class * classes = <span class="literal">NULL</span>;</span><br><span class="line">numClasses = objc_getClassList(<span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (numClasses &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     classes = malloc(<span class="keyword">sizeof</span>(Class) * numClasses);</span><br><span class="line">     numClasses = objc_getClassList(classes, numClasses);</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;number of classes: %d&quot;</span>, numClasses);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numClasses; i++) &#123;</span><br><span class="line">          Class cls = classes[i];</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;class name: %s&quot;</span>, class_getName(cls));</span><br><span class="line">     &#125;</span><br><span class="line">     free(classes);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>结果如下：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">81</span>] number of classes: <span class="number">1282</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.589</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: DDTokenRegexp</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: _NSMostCommonKoreanCharsKeySet</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: OS_xpc_dictionary</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSFileCoordinator</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSAssertionHandler</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.590</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: PFUbiquityTransactionLogMigrator</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSNotification</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: <span class="built_in">NSKeyValueNilSetEnumerator</span></span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: OS_tcp_connection_tls_session</span><br><span class="line"><span class="number">16</span>:<span class="number">20</span>:<span class="number">52.591</span> RuntimeTest[<span class="number">81</span>] <span class="keyword">class</span> name: _PFRoutines</span><br><span class="line">......还有大量输出</span><br></pre></td></tr></table></figure>

<h1 id="三、成员变量、属性与关联对象"><a href="#三、成员变量、属性与关联对象" class="headerlink" title="三、成员变量、属性与关联对象"></a>三、成员变量、属性与关联对象</h1><h2 id="3-1-实例变量类型Ivar"><a href="#3-1-实例变量类型Ivar" class="headerlink" title="3.1 实例变量类型Ivar"></a>3.1 实例变量类型Ivar</h2><blockquote>
<p>实例变量是指在类的声明中，属性是用变量来表示的。 这种变量就称为实例变量，也叫对象变量、类成员变量；</p>
</blockquote>
<h3 id="3-1-1-Ivar结构"><a href="#3-1-1-Ivar结构" class="headerlink" title="3.1.1 Ivar结构"></a>3.1.1 Ivar结构</h3><p>Ivar是指向 ivar_t 结构体的指针，ivar指针地址是根据class结构体的地址加上基地址偏移字节得到的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> *offset;   <span class="comment">// 基地址偏移字节</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 变量名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *type;  <span class="comment">// 变量类型</span></span><br><span class="line">    <span class="comment">// alignment is sometimes -1; use alignment() instead</span></span><br><span class="line">    <span class="keyword">uint32_t</span> alignment_raw;</span><br><span class="line">    <span class="keyword">uint32_t</span> size;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ivar_t</span> *<span class="title">Ivar</span>;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取成员变量的偏移量</span></span><br><span class="line"><span class="function"><span class="keyword">ptrdiff_t</span> <span class="title">ivar_getOffset</span><span class="params">(Ivar ivar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getName</span><span class="params">(Ivar ivar)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取成员变量类型编码</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">ivar_getTypeEncoding</span><span class="params">(Ivar ivar)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-Ivar的获取和添加"><a href="#3-1-2-Ivar的获取和添加" class="headerlink" title="3.1.2 Ivar的获取和添加"></a>3.1.2 Ivar的获取和添加</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取整个成员变量列表(必须使用free()来释放这个数组)</span></span><br><span class="line"><span class="function">Ivar *<span class="title">class_copyIvarList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function">  </span></span><br><span class="line"><span class="function"><span class="comment">// 添加成员变量(这个只能够向在runtime时创建的类添加成员变量)</span></span></span><br><span class="line"><span class="function"><span class="comment">// This function may only be called after objc_allocateClassPair and before objc_registerClassPair. </span></span></span><br><span class="line"><span class="function"><span class="comment">// Adding an instance variable to an existing class is not supported.</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">class_addIvar</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> size, <span class="keyword">uint8_t</span> alignment, <span class="keyword">const</span> <span class="keyword">char</span> *type)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-3-实例变量操作函数"><a href="#3-1-3-实例变量操作函数" class="headerlink" title="3.1.3 实例变量操作函数"></a>3.1.3 实例变量操作函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改类实例的实例变量的值</span></span><br><span class="line"><span class="function">Ivar <span class="title">object_setInstanceVariable</span><span class="params">(id obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> *value)</span></span>;</span><br><span class="line"><span class="comment">// 获取对象实例变量的值</span></span><br><span class="line"><span class="function">Ivar <span class="title">object_getInstanceVariable</span><span class="params">(id obj, <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">void</span> **value)</span></span>;</span><br><span class="line"><span class="comment">// 返回指向给定对象分配的任何额外字节的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">object_getIndexedIvars</span><span class="params">(id obj)</span></span></span><br><span class="line"><span class="function"><span class="comment">// 返回对象中实例变量的值</span></span></span><br><span class="line"><span class="function">id <span class="title">object_getIvar</span><span class="params">(id obj, Ivar ivar)</span></span>;</span><br><span class="line"><span class="comment">// 设置对象中实例变量的值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">object_setIvar</span><span class="params">(id obj, Ivar ivar, id value)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-属性类型property-t"><a href="#3-2-属性类型property-t" class="headerlink" title="3.2 属性类型property_t"></a>3.2 属性类型property_t</h2><h3 id="3-2-1-property-t结构和objc-property-t"><a href="#3-2-1-property-t结构和objc-property-t" class="headerlink" title="3.2.1 property_t结构和objc_property_t"></a>3.2.1 property_t结构和objc_property_t</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;       <span class="comment">// property的名称</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *attributes; <span class="comment">// property的属性</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">property_t</span> *<span class="title">objc_property_t</span>;</span></span><br></pre></td></tr></table></figure>

<p>属性attributes是一个字符串：<code>T&lt;属性的类型&gt;,[属性修饰符,[属性修饰符, ...]]V&lt;实例变量名&gt;</code></p>
<ul>
<li>该字符串以T开头</li>
<li>后面跟着属性的类型(<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encodings</a>)、属性修饰符（<em>见下图</em>），以逗号分隔。</li>
<li>然后是V，后面跟着实例变量的名称。(<em>官方文档 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtPropertyIntrospection.html#//apple_ref/doc/uid/TP40008048-CH101-SW24">Declared Properties</a>，不过官方文档中的示例貌似有误或是过时，以下方示例为准</em>)</li>
</ul>
<img src="/images/runtime/02.png" alt="02" style="zoom:90%;" />

<p>获取name、attributes的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取属性名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getName</span><span class="params">(<span class="keyword">objc_property_t</span> prop)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性特性描述字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">property_getAttributes</span><span class="params">(<span class="keyword">objc_property_t</span> prop)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-property的获取和添加"><a href="#3-2-2-property的获取和添加" class="headerlink" title="3.2.2 property的获取和添加"></a>3.2.2 property的获取和添加</h3><p>获取类和协议的属性列表</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 返回一个包含类中声明的属性的堆块(heap block)，如果类没有声明属性，则返回nil。呼叫者必须释放区块。</span></span><br><span class="line"><span class="comment"> * 不复制任何超类的属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">class_copyPropertyList</span><span class="params">(Class cls, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">protocol_copyPropertyList</span><span class="params">(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure>

<p>通过给出的名称来在类和协议中获取属性的引用:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">class_getProperty</span><span class="params">(Class cls, <span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">protocol_getProperty</span><span class="params">(Protocol *proto, <span class="keyword">const</span> <span class="keyword">char</span> *name, BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br></pre></td></tr></table></figure>

<p>添加和修改：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于已经存在的类我们用class_addProperty方法来添加属性。</span></span><br><span class="line"><span class="comment">记得同时使用class_addMethod()添加setter和getter方法。但这样添加的属性没有对应的成员变量，所以得自己在setter和getter方法中决定数据的存取逻辑。</span></span><br><span class="line"><span class="comment">对于已经存在的类，class_addIvar是不能够添加属性的。class_addIvar只能为动态创建的类添加属性。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_addProperty</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> * _Nullable attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                  <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">class_replaceProperty</span><span class="params">(Class _Nullable cls, <span class="keyword">const</span> <span class="keyword">char</span> * _Nonnull name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> * _Nullable attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">unsigned</span> <span class="keyword">int</span> attributeCount)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-property的特性attributes"><a href="#3-2-3-property的特性attributes" class="headerlink" title="3.2.3 property的特性attributes"></a>3.2.3 property的特性attributes</h3><p>objc_property_attribute_t也是结构体，定义属性的attribute</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 特性名</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *value; <span class="comment">// 特性值</span></span><br><span class="line">&#125; <span class="keyword">objc_property_attribute_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取属性中指定的特性</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">property_copyAttributeValue</span><span class="params">(<span class="keyword">objc_property_t</span> property, <span class="keyword">const</span> <span class="keyword">char</span> *attributeName)</span></span>;</span><br><span class="line"><span class="comment">// 获取属性的特性列表</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_attribute_t</span> *<span class="title">property_copyAttributeList</span><span class="params">(<span class="keyword">objc_property_t</span> prop, </span></span></span><br><span class="line"><span class="function"><span class="params">                                                      <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-4-示例"><a href="#3-2-4-示例" class="headerlink" title="3.2.4 示例"></a>3.2.4 示例</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> : <span class="title">NSObject</span> </span></span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">float</span> alone;</span><br><span class="line"><span class="keyword">@property</span> <span class="keyword">char</span> charDefault;</span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">copy</span>)<span class="keyword">id</span> idReadonlyCopyNonatomic;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取属性列表</span></span><br><span class="line"><span class="keyword">id</span> LenderClass = objc_getClass(<span class="string">&quot;Lender&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount, i;</span><br><span class="line">objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line"></span><br><span class="line">    objc_property_t property = properties[i];</span><br><span class="line">    fprintf(stdout, <span class="string">&quot;%s %s\n&quot;</span>, property_getName(property), property_getAttributes(property)); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> outCount2, j;</span><br><span class="line">    objc_property_attribute_t * attries = property_copyAttributeList(property, &amp;outCount2);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; outCount2; j++) &#123;</span><br><span class="line">        objc_property_attribute_t attr = attries[j];</span><br><span class="line">        fprintf(stdout, <span class="string">&quot;%s %s\n&quot;</span>, attr.name, attr.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">alone Tf,V_alone</span><br><span class="line">T f</span><br><span class="line">V _alone</span><br><span class="line">  </span><br><span class="line">charDefault Tc,V_charDefault</span><br><span class="line">T c</span><br><span class="line">V _charDefault</span><br><span class="line">  </span><br><span class="line">idReadonlyCopyNonatomic T@,R,C,N,V_idReadonlyCopyNonatomic</span><br><span class="line">T @</span><br><span class="line">R </span><br><span class="line">C </span><br><span class="line">N </span><br><span class="line">V _idReadonlyCopyNonatomic</span><br></pre></td></tr></table></figure>

<h2 id="3-3-关联对象"><a href="#3-3-关联对象" class="headerlink" title="3.3 关联对象"></a>3.3 关联对象</h2><p>关联对象是在运行时添加的类似成员。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置对象 的一个关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key, id value, objc_AssociationPolicy policy)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//获取对象 指定的关联对象</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> <span class="keyword">void</span> *key)</span></span>;</span><br><span class="line">  </span><br><span class="line"><span class="comment">//移除对象 所有关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//上面方法以键值对的形式动态的向对象添加，获取或者删除关联值。其中关联政策是一组枚举常量。这些常量对应着引用关联值机制，也就是Objc内存管理的引用计数机制。</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> &#123;</span></span><br><span class="line">     OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,</span><br><span class="line">     OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>,</span><br><span class="line">     OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,</span><br><span class="line">     OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,</span><br><span class="line">     OBJC_ASSOCIATION_COPY = <span class="number">01403</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>


<p>示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//动态的将一个Tap手势操作连接到任何UIView中。</span></span><br><span class="line">- (<span class="keyword">void</span>)setTapActionWithBlock:(<span class="built_in"><span class="keyword">void</span></span> (^)(<span class="keyword">void</span>))block</span><br><span class="line">&#123;</span><br><span class="line">     UITapGestureRecognizer *gesture = <span class="built_in">objc_getAssociatedObject</span>(self, &amp;kDTActionHandlerTapGestureKey);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!gesture)</span><br><span class="line">     &#123;</span><br><span class="line">          gesture = [[UITapGestureRecognizer alloc] initWithTarget:self action:@<span class="built_in">selector</span>(__handleActionForTapGesture:)];</span><br><span class="line">          [self addGestureRecognizer:gesture];</span><br><span class="line">          <span class="comment">//将创建的手势对象和block作为关联对象</span></span><br><span class="line">          <span class="built_in">objc_setAssociatedObject</span>(self, &amp;kDTActionHandlerTapGestureKey, gesture, OBJC_ASSOCIATION_RETAIN);</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="built_in">objc_setAssociatedObject</span>(self, &amp;kDTActionHandlerTapBlockKey, block, OBJC_ASSOCIATION_COPY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//手势识别对象的target和action</span></span><br><span class="line">- (<span class="keyword">void</span>)__handleActionForTapGesture:(UITapGestureRecognizer *)gesture</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">if</span> (gesture.state == UIGestureRecognizerStateRecognized)</span><br><span class="line">     &#123;</span><br><span class="line">          <span class="built_in"><span class="keyword">void</span></span>(^action)(<span class="keyword">void</span>) = <span class="built_in">objc_getAssociatedObject</span>(self, &amp;kDTActionHandlerTapBlockKey);</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (action)</span><br><span class="line">          &#123;</span><br><span class="line">               <span class="built_in">action</span>();</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="四、Method和消息"><a href="#四、Method和消息" class="headerlink" title="四、Method和消息"></a>四、Method和消息</h1><h2 id="4-1-method-t、SEL和IMP"><a href="#4-1-method-t、SEL和IMP" class="headerlink" title="4.1 method_t、SEL和IMP"></a>4.1 method_t、SEL和IMP</h2><h3 id="4-1-1-method-t结构和Method"><a href="#4-1-1-method-t结构和Method" class="headerlink" title="4.1.1 method_t结构和Method"></a>4.1.1 method_t结构和Method</h3><p>method_t结构，用于表示类定义中的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> &#123;</span></span><br><span class="line">    SEL name;          <span class="comment">// 方法名</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 编码，是个char指针，存储着方法的返回值类型、参数类型</span></span><br><span class="line">    IMP imp;           <span class="comment">// 指向函数实现的指针(函数地址)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">method_t</span> *<span class="title">Method</span>;</span></span><br></pre></td></tr></table></figure>

<p>iOS中提供了一个叫做@encode的指令，可以将具体的类型表示成字符串编码。(<a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html#//apple_ref/doc/uid/TP40008048-CH100-SW1">Type Encodings</a>)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   v16@0:8</span></span><br><span class="line"><span class="comment">   v - 返回值void</span></span><br><span class="line"><span class="comment">   @ - 参数1: id self</span></span><br><span class="line"><span class="comment">   : - 参数2: SEL _cmd</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">int</span>)test:(<span class="keyword">int</span>)age height:(<span class="keyword">float</span>)height;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   i24@0:8i16f20</span></span><br><span class="line"><span class="comment">   i  - 返回值</span></span><br><span class="line"><span class="comment">   24 - 表示接下来的参数总共占多少个字节</span></span><br><span class="line"><span class="comment">   @  - 参数1: id self</span></span><br><span class="line"><span class="comment">   0  - 对应参数1，表示参数1的数据是从第几个字节开始的。后面的8 16 20分别对应参数234对应的开始位置</span></span><br><span class="line"><span class="comment">   :  - 参数2: SEL _cmd</span></span><br><span class="line"><span class="comment">   i  - 参数3: int</span></span><br><span class="line"><span class="comment">   f  - 参数4: float</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-2-SEL"><a href="#4-1-2-SEL" class="headerlink" title="4.1.2 SEL"></a>4.1.2 SEL</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SEL代表方法\函数名，一般叫做选择器，底层结构跟char *类似.(可以简单的理解为是个字符串).</span></span><br><span class="line">  <span class="comment">// 可以通过@selector()和sel_registerName()获得.</span></span><br><span class="line">  <span class="comment">// 可以通过sel_getName()和NSStringFromSelector()转成字符串.</span></span><br><span class="line">  <span class="comment">// 不同类中相同名字的方法，所对应的方法选择器是相同的.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_selector</span> *<span class="title">SEL</span>;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//objc_selector编译时会根据每个方法名字参数序列生成唯一标识</span></span><br><span class="line">SEL sel1 = @<span class="built_in">selector</span>(load);</span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;sel : %p&quot;</span>, sel1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">18</span>:<span class="number">40</span>:<span class="number">07.518</span> RuntimeTest[<span class="number">52</span>:<span class="number">46</span>] sel : <span class="number">0x7fff606203c3</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-IMP"><a href="#4-1-3-IMP" class="headerlink" title="4.1.3 IMP"></a>4.1.3 IMP</h3><p>是函数指针，指向方法的首地址，得到了IMP，就可以跳过Runtime消息传递机制直接执行函数，比直接向对象发消息高效。定义如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMP代表函数的具体实现</span></span><br><span class="line"><span class="keyword">typedef</span> id _Nullable (*IMP)(id _Nonnull, SEL _Nonnull, ...);</span><br></pre></td></tr></table></figure>

<h2 id="4-2-Method相关操作函数"><a href="#4-2-Method相关操作函数" class="headerlink" title="4.2 Method相关操作函数"></a>4.2 Method相关操作函数</h2><h3 id="4-2-1-获取Method的信息"><a href="#4-2-1-获取Method的信息" class="headerlink" title="4.2.1 获取Method的信息"></a>4.2.1 获取Method的信息</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取方法名。如果希望获得方法明的C字符串，使用sel_getName(method_getName(method))</span></span><br><span class="line"><span class="function">SEL <span class="title">method_getName</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 返回方法的实现</span></span><br><span class="line"><span class="function">IMP <span class="title">method_getImplementation</span><span class="params">(Method m)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取描述方法参数和返回值类型的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">method_copyReturnType</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的返回值类型的字符串：通过引用返回，这种参数又称为传出参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_getReturnType</span><span class="params">(Method m, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> dst_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回方法的参数的个数</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(Method m)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> * <span class="title">method_copyArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index)</span></span>;</span><br><span class="line"><span class="comment">// 获取方法的指定位置参数的类型字符串：通过引用返回</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_getArgumentType</span><span class="params">(Method m, <span class="keyword">unsigned</span> <span class="keyword">int</span> index, <span class="keyword">char</span> *dst, <span class="keyword">size_t</span> dst_len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回指定方法的方法描述结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_method_description</span> &#123;</span></span><br><span class="line">    SEL _Nullable name;               <span class="comment">/**&lt; The name of the method */</span></span><br><span class="line">    <span class="keyword">char</span> * _Nullable types;           <span class="comment">/**&lt; The types of the method arguments */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">struct objc_method_description *<span class="title">method_getDescription</span><span class="params">(Method m)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-获取和设置Method的IMP"><a href="#4-2-2-获取和设置Method的IMP" class="headerlink" title="4.2.2 获取和设置Method的IMP"></a>4.2.2 获取和设置Method的IMP</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置方法的实现</span></span><br><span class="line"><span class="function">IMP <span class="title">method_setImplementation</span><span class="params">(Method m, IMP imp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 交换两个方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(Method m1, Method m2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>NSObject提供了一个methodForSelector:方法可以获得Method的IMP指针，通过指针调用实现代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ (IMP)instanceMethodForSelector:(SEL)sel;</span><br><span class="line">+ (IMP)methodForSelector:(SEL)sel;</span><br><span class="line">- (IMP)methodForSelector:(SEL)sel;</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> (*<span class="keyword">setter</span>)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>);</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">setter</span> = (<span class="keyword">void</span> (*)(<span class="keyword">id</span>, SEL, <span class="built_in">BOOL</span>))[target methodForSelector:<span class="keyword">@selector</span>(setFilled:)];</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">    <span class="keyword">setter</span>(targetList[i], <span class="keyword">@selector</span>(setFilled:), <span class="literal">YES</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-直接调用Method"><a href="#4-2-3-直接调用Method" class="headerlink" title="4.2.3 直接调用Method"></a>4.2.3 直接调用Method</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现，返回的是方法实现时的返回，参数receiver不能为空，这个比method_getImplementation和method_getName快</span></span><br><span class="line"><span class="function">id <span class="title">method_invoke</span><span class="params">(id receiver, Method m, ... )</span></span>;</span><br><span class="line"><span class="comment">// 调用 (返回一个数据结构的) 方法的实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">method_invoke_stret</span><span class="params">(id receiver, Method m, ...)</span> </span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-SEL的操作函数"><a href="#4-2-4-SEL的操作函数" class="headerlink" title="4.2.4 SEL的操作函数"></a>4.2.4 SEL的操作函数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回给定选择器指定的方法的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">sel_getName</span><span class="params">(SEL sel)</span></span>;</span><br><span class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法，将方法名映射到一个选择器，并返回这个选择器</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_registerName</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 在objectivec Runtime系统中注册一个方法</span></span><br><span class="line"><span class="function">SEL <span class="title">sel_getUid</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="comment">// 比较两个选择器</span></span><br><span class="line"><span class="function">BOOL <span class="title">sel_isEqual</span><span class="params">(SEL lhs, SEL rhs)</span></span>; <span class="comment">// Lhs --&gt; Left Hand Side，也就是算式左边的意思</span></span><br></pre></td></tr></table></figure>

<h2 id="4-3-Method调用流程objc-msgSend"><a href="#4-3-Method调用流程objc-msgSend" class="headerlink" title="4.3 Method调用流程objc_msgSend"></a>4.3 Method调用流程objc_msgSend</h2><p>消息函数，Objc中发送消息是用中括号把接收者和消息括起来，只到运行时才会把消息和方法实现绑定。</p>
<p>OC中的方法调用，其实都是转换为下面几个函数的调用。编译器会根据情况在objc_msgSend，objc_msgSend_stret，objc_msgSendSuper，或objc_msgSendSuper_stret四个方法中选一个调用。</p>
<ul>
<li>如果是传递给超类就会调用带super的函数；</li>
<li>如果返回是数据结构而不是一个值就会调用带stret的函数；</li>
<li>在i386平台返回类型为浮点消息会调用objc_msgSend_fpret函数。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这个函数将消息接收者和方法名(选择器)作为基础参数。</span></span><br><span class="line">   <span class="comment">// 使用self关键字来引用实例本身，self的内容即接收消息的对象是在Method运行时被传入</span></span><br><span class="line">   <span class="comment">// 还有方法选择器</span></span><br><span class="line"><span class="function">id <span class="title">objc_msgSend</span><span class="params">(id _Nullable self, SEL _Nonnull op, ...)</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="流程概述"><a href="#流程概述" class="headerlink" title="流程概述"></a>流程概述</h3><p>objc_msgSend的执行流程可以分为3大阶段：消息发送、动态方法解析、消息转发</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 消息发送阶段</span></span><br><span class="line"><span class="comment">//在objc-msg-arm64.s中</span></span><br><span class="line">▼ _objc_msgSend</span><br><span class="line">  ▼ CacheLookup  <span class="comment">// 缓存查找</span></span><br><span class="line">    ▼ CheckMiss <span class="comment">// 如果缓存没有命中</span></span><br><span class="line">      ▼ __objc_msgSend_uncached</span><br><span class="line">        ▼ MethodTableLookup</span><br><span class="line">        <span class="comment">// 其中有一行 bl __class_lookupMethodAndLoadCache3. 此时在objc-msg-arm64.s已经查不到该方法了。前缀减去</span></span><br><span class="line">        <span class="comment">// 一个_（符号修饰）然后全局搜索，可以在objc-runtime-new.mm中找到该方法_class_lookupMethodAndLoadCache3</span></span><br><span class="line"><span class="comment">//objc-runtime-new.mm</span></span><br><span class="line">  ▼ _class_lookupMethodAndLoadCache3</span><br><span class="line">  	<span class="comment">/*</span></span><br><span class="line"><span class="comment">  	 // 仅用于汇编中的方法查找。其他代码应该使用lookUpImp()。这种查找避免了乐观的缓存扫描，因为汇编中已经尝试过。</span></span><br><span class="line"><span class="comment">  	 IMP _class_lookupMethodAndLoadCache3(id obj, SEL sel, Class cls)&#123;</span></span><br><span class="line"><span class="comment">  	      // NO是cache. cache==NO跳过乐观的解锁查找(但在其他地方使用缓存);</span></span><br><span class="line"><span class="comment">          return lookUpImpOrForward(cls, sel, obj, YES, NO, YES);</span></span><br><span class="line"><span class="comment">     &#125;</span></span><br><span class="line"><span class="comment">  	 */</span></span><br><span class="line">    ▼ lookUpImpOrForward</span><br><span class="line">      ▶ cache_getImp            <span class="comment">// 查找当前类的cache</span></span><br><span class="line">      ▶ getMethodNoSuper_nolock <span class="comment">// 查找当前类的methods</span></span><br><span class="line">      ▶ cache_getImp            <span class="comment">// 查找父类(父类的父类...)的cache</span></span><br><span class="line">      ▶ getMethodNoSuper_nolock <span class="comment">// 查找父类(父类的父类...)的methods</span></span><br><span class="line">        ▼ search_method_list</span><br><span class="line">          ▶ findMethodInSortedMethodList  <span class="comment">//若有序，二分查找</span></span><br><span class="line">          ▶ <span class="comment">//若无序，线性查找</span></span><br><span class="line">      ▼ log_and_fill_cache  <span class="comment">// 不管是在本类、父类、基类中找到的，只要不在本类的cache中，就填充缓存</span></span><br><span class="line">        ▼ cache_fill</span><br><span class="line">          ▶ cache_fill_nolock</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 动态方法解析</span></span><br><span class="line">      ▼ _class_resolveMethod      <span class="comment">// 动态方法解析. 在运行时(动态)向特定类添加特定方法实现。</span></span><br><span class="line">        ▶ _class_resolveClassMethod    <span class="comment">// 如果是元类对象，调用类的该类方法(需要自己实现)，在该方法中，将要调用的方法添加到class/meta-class中。见MJPerson.m</span></span><br><span class="line">        ▶ _class_resolveInstanceMethod <span class="comment">// 如果是类对象，同上...</span></span><br><span class="line">        <span class="comment">//..动态解析过后，会重新走“消息发送”的流程</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -- 消息转发</span></span><br><span class="line">      ▶ _objc_msgForward_impcache <span class="comment">// 消息转发. No implementation found, and method resolver didn&#x27;t help. Use forwarding.</span></span><br></pre></td></tr></table></figure>

<p>大致流程图如下：</p>
<img src="/images/runtime/03.png" alt="03" style="zoom:80%;" />

<h3 id="4-3-1-消息发送"><a href="#4-3-1-消息发送" class="headerlink" title="4.3.1 消息发送"></a>4.3.1 消息发送</h3><ul>
<li>消息发送给一个对象时，objc_msgSend通过对象的isa指针获得类的结构体，先在Cache里找，找到就执行</li>
<li>没找到就在分发列表里查找方法的selector</li>
<li>没找到就通过objc_class结构体中指向父类的指针找到父类，然后在父类分发列表找</li>
<li>直到root class（NSObject）</li>
</ul>
<p>如果root class仍然找不到方法，不会直接报错，会进入以下两个补救阶段。不过安全起见，一些场景中，可以先添加方法能否响应的判断：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先调用respondsToSelector:来判断一下</span></span><br><span class="line"><span class="keyword">if</span> ([<span class="keyword">self</span> respondsToSelector:<span class="keyword">@selector</span>(method)]) &#123;</span><br><span class="line">     [<span class="keyword">self</span> performSelector:<span class="keyword">@selector</span>(method)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-动态方法解析"><a href="#4-3-2-动态方法解析" class="headerlink" title="4.3.2 动态方法解析"></a>4.3.2 动态方法解析</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> functionForMethod1(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@, %p&quot;</span>, <span class="keyword">self</span>, _cmd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel &#123;</span><br><span class="line">     <span class="built_in">NSString</span> *selectorString = <span class="built_in">NSStringFromSelector</span>(sel);</span><br><span class="line">     <span class="keyword">if</span> ([selectorString isEqualToString:<span class="string">@&quot;method1&quot;</span>]) &#123;</span><br><span class="line">          class_addMethod(<span class="keyword">self</span>.class, <span class="keyword">@selector</span>(method1), (IMP)functionForMethod1, <span class="string">&quot;@:&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以动态的提供一个方法的实现。例如可以用@dynamic关键字在类的实现文件中写个属性</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个表明会为这个属性动态提供set get方法，就是编译器是不会默认生成setPropertyName:和propertyName方法，需要动态提供。</span></span><br><span class="line"><span class="keyword">@dynamic</span> propertyName;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> dynamicMethodIMP(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd) &#123;</span><br><span class="line">     <span class="comment">// implementation ....</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 如果是对象方法找不到，动态方法解析 会调用+(BOOL)resolveInstanceMethod:(SEL)sel</span></span><br><span class="line"><span class="comment"> 如果是类方法找不到， 动态方法解析 会调用+(BOOL)resolveClassMethod:(SEL)sel</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveInstanceMethod:(SEL)sel&#123;&#125;</span><br><span class="line">  </span><br><span class="line">+ (<span class="built_in">BOOL</span>)resolveClassMethod:(SEL)sel</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (sel == <span class="keyword">@selector</span>(resolveThisMethodDynamically)) &#123;</span><br><span class="line">        <span class="comment">//v@:表示返回值和参数，可以在苹果官网查看Type Encoding相关文档 https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html</span></span><br><span class="line">        <span class="comment">// 最后用class_addMethod完成添加特定方法实现的操作</span></span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], sel, (IMP)dynamicMethodIMP, <span class="string">&quot;v@:&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [<span class="keyword">super</span> resolveInstanceMethod:sel];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-消息转发"><a href="#4-3-3-消息转发" class="headerlink" title="4.3.3 消息转发"></a>4.3.3 消息转发</h3><h4 id="1-重定向接收者"><a href="#1-重定向接收者" class="headerlink" title="1. 重定向接收者"></a>1. 重定向接收者</h4><p>如果无法处理消息会继续调用下面的方法，同时在这里Runtime系统实际上是给了一个替换消息接收者的机会，但是替换的对象千万不要是self，那样会进入死循环。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用这个方法通常在对象内部</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是实例方法</span></span><br><span class="line">- (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector</span><br><span class="line">&#123;</span><br><span class="line">     <span class="comment">// 将消息转发给alternateObject来处理</span></span><br><span class="line">     <span class="keyword">if</span>(aSelector == <span class="keyword">@selector</span>(mysteriousMethod:))&#123;</span><br><span class="line">          <span class="keyword">return</span> alternateObject;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> [<span class="keyword">super</span> forwardingTargetForSelector:aSelector];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果是类方法</span></span><br><span class="line">+ (<span class="keyword">id</span>)forwardingTargetForSelector:(SEL)aSelector&#123;</span><br><span class="line">   <span class="comment">// 这个return，不仅限于类对象，也可以是实例对象，前提是这个实例对象有名为aSelector的实例方法。因为前面已经说了，底层代码得到return的对象后，就会调用objc_msgSend，如果返回的实例对象，就相当于objc_msgSend(obj, @selector(test))，最后是能完成消息发送的</span></span><br><span class="line">   <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-最后进行转发"><a href="#2-最后进行转发" class="headerlink" title="2. 最后进行转发"></a>2. 最后进行转发</h4><p>如果以上两种都没法处理未知消息就需要完整消息转发了。调用如下方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//必须重写这个方法，消息转发使用这个方法获得的信息创建NSInvocation对象。如果没有实现，或者返回nil，消息转发结束。</span></span><br><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这一步是最后机会将消息转发给其它对象，对象会将未处理的消息相关的selector，target和参数都封装在anInvocation中。forwardInvocation:像未知消息分发中心，将未知消息转发给其它对象。注意的是forwardInvocation:方法只有在消息接收对象无法正常响应消息时才被调用。</span></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果是类方法</span></span><br><span class="line">+ (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector;</span><br><span class="line">+ (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation;</span><br></pre></td></tr></table></figure>


<p>范例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMethodSignature</span> *)methodSignatureForSelector:(SEL)aSelector &#123;</span><br><span class="line">     <span class="built_in">NSMethodSignature</span> *signature = [<span class="keyword">super</span> methodSignatureForSelector:aSelector];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (!signature) &#123;</span><br><span class="line">          <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:aSelector]) &#123;</span><br><span class="line">               signature = [SUTRuntimeMethodHelper instanceMethodSignatureForSelector:aSelector];</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> signature;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)forwardInvocation:(<span class="built_in">NSInvocation</span> *)anInvocation &#123;</span><br><span class="line">     <span class="keyword">if</span> ([SUTRuntimeMethodHelper instancesRespondToSelector:anInvocation.selector]) &#123;</span><br><span class="line">          [anInvocation invokeWithTarget:_helper];</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-4-消息转发和多继承"><a href="#4-3-4-消息转发和多继承" class="headerlink" title="4.3.4 消息转发和多继承"></a>4.3.4 消息转发和多继承</h3><p>OC是否支持多继承？有没有模拟多继承特性的办法？</p>
<p>转发和继承相似，一个Object把消息转发出去就好像它继承了另一个Object的方法一样。</p>
<p>消息转发弥补了objc不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。</p>
<p>虽然转发可以实现继承功能，但是NSObject还是必须表面上很严谨，像<code>respondsToSelector:</code>和<code>isKindOfClass:</code>这类方法只会考虑继承体系，不会考虑转发链。</p>
<h3 id="4-3-5-Message消息的参考文章"><a href="#4-3-5-Message消息的参考文章" class="headerlink" title="4.3.5 Message消息的参考文章"></a>4.3.5 Message消息的参考文章</h3><ul>
<li><a target="_blank" rel="noopener" href="https://mikeash.com/pyblog/friday-qa-2009-03-27-objectivec-message-forwarding.html">Message forwarding</a></li>
<li><a target="_blank" rel="noopener" href="https://www.mikeash.com/pyblog/friday-qa-2009-03-20-objectivec-messaging.html">objectivec messaging</a></li>
<li><a target="_blank" rel="noopener" href="http://www.mulle-kybernetik.com/artikel/Optimization/opti-9.html">The faster objc_msgSend</a></li>
</ul>
<h2 id="4-4-super和objc-msgSendSuper"><a href="#4-4-super和objc-msgSendSuper" class="headerlink" title="4.4 super和objc_msgSendSuper"></a>4.4 super和objc_msgSendSuper</h2><p><code>NSStringFromClass([self class])</code> 和 <code>NSStringFromClass([super class])</code> 输出都是self的类名。原因如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [super message]的底层实现:</span></span><br><span class="line"><span class="comment">// super调用，底层会转换为objc_msgSendSuper2函数的调用，接收2个参数</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">objc_super2</span> &#123;</span></span><br><span class="line">   id receiver;         <span class="comment">// receiver是self，表示消息接收者仍然是子类对象</span></span><br><span class="line">   Class current_class; <span class="comment">// 会从父类current_class.superclass开始查找方法的实现</span></span><br><span class="line">&#125;;</span><br><span class="line">SEL</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Sends a message with a simple return value to the superclass of an instance of a class.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param super 指向objc_super数据结构的指针。传递消息发送的上下文的值，包括要接收消息的类的实例和开始搜索方法实现的超类。including the instance of the class that is to receive the message and the superclass at which to start searching for the method implementation。</span></span><br><span class="line"><span class="comment"> * 由此可知，消息仍然是receiver来处理，superclass指定了`消息发送`阶段，方法从isa-&gt;superclass-&gt;superclass.superclass...-&gt;NSObject链中superclass为起点开始向上寻找。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @param op   SEL类型的指针。传递将处理消息的方法的选择器。</span></span><br><span class="line"><span class="comment"> * @param ...  A variable argument list containing the arguments to the method.</span></span><br><span class="line"><span class="comment"> * @return     The return value of the method identified by \e op.</span></span><br><span class="line"><span class="comment"> * @see objc_msgSend</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">id <span class="title">objc_msgSendSuper</span><span class="params">(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span>;</span><br><span class="line"><span class="function">id <span class="title">objc_msgSendSuper2</span><span class="params">(struct objc_super * _Nonnull super, SEL _Nonnull op, ...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>结论：super只是改变了方法查找链的起始位置，调用者是不变的。</p>
<h2 id="4-5-Method-Swizzling"><a href="#4-5-Method-Swizzling" class="headerlink" title="4.5 Method Swizzling"></a>4.5 Method Swizzling</h2><p>是改变一个selector实际实现的技术，可以在运行时修改selector对应的函数来修改Method的实现。前面的消息转发很强大，但是需要能够修改对应类的源码，但是对于有些类无法修改其源码时又要更改其方法实现时可以使用Method Swizzling，通过重新映射方法来达到目的，但是跟消息转发比起来调试会困难。</p>
<h3 id="4-5-1-使用method-swizzling需要注意的问题"><a href="#4-5-1-使用method-swizzling需要注意的问题" class="headerlink" title="4.5.1 使用method swizzling需要注意的问题"></a>4.5.1 使用method swizzling需要注意的问题</h3><ul>
<li><strong>Swizzling应该总在+load中执行</strong>：objectivec在运行时会自动调用类的两个方法+load和+initialize。+load会在类初始加载时调用，和+initialize比较+load能保证在类的初始化过程中被加载。<ul>
<li>Swizzling在+load中执行时，不要调用[super load]。原因同下面一条，如果是多继承，并且对同一个方法都进行了Swizzling（<em>没有在dispatch_once中执行</em>），那么调用[super load]以后，父类的Swizzling就失效了。</li>
</ul>
</li>
<li><strong>Swizzling应该总是在dispatch_once中执行</strong>：swizzling会改变全局状态，所以在运行时采取一些预防措施，使用dispatch_once就能够确保代码不管有多少线程都只被执行一次。这将成为method swizzling的最佳实践。<ul>
<li>如果不写dispatch_once，偶数次交换以后，相当于没有交换，Swizzling失效！</li>
</ul>
</li>
<li><strong>Swizzling时，需要注意class_getInstanceMethod的特性</strong>：该方法的实现中，如果这个类中没有实现selector这个方法，那么它会沿着继承链找到为止，即其可能返回的是它某父类的Method对象。所以提前判断很重要，避免错误的交换了父类中的方法。</li>
<li>交换的分类方法应尽量调用原实现。<ul>
<li>很多情况我们不清楚被交换的的方法具体做了什么内部逻辑，而且很多被交换的方法都是系统封装的方法，所以为了保证其逻辑性都应该在分类的交换方法中去调用原被交换方法。</li>
<li>注意：调用时方法交换已经完成，在分类方法中应该调用分类方法本身才正确。</li>
<li>作用：比如之前a应该和b互换了方法，c方法在不知情的状况下和a互换了方法。只有在交换的方法中调用原实现，才能保证c→b→a中的代码都能得到执行。</li>
</ul>
</li>
</ul>
<h3 id="4-5-2-实现一"><a href="#4-5-2-实现一" class="headerlink" title="4.5.2 实现一"></a>4.5.2 实现一</h3><p>举例说明如何使用Method Swizzling对一个类中注入一些我们的新的操作。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Tracking</span>)</span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">     <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">     <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          Class <span class="keyword">class</span> = [<span class="keyword">self</span> <span class="keyword">class</span>];</span><br><span class="line">          <span class="comment">// When swizzling a class method, use the following:</span></span><br><span class="line">          <span class="comment">// Class class = object_getClass((id)self);</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//通过method swizzling修改了UIViewController的@selector(viewWillAppear:)的指针使其指向了自定义的xxx_viewWillAppear</span></span><br><span class="line">          SEL originalSelector = <span class="keyword">@selector</span>(viewWillAppear:);</span><br><span class="line">          SEL swizzledSelector = <span class="keyword">@selector</span>(xxx_viewWillAppear:);</span><br><span class="line"></span><br><span class="line">          Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">          Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector);</span><br><span class="line"></span><br><span class="line">          <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>,</span><br><span class="line">               originalSelector,</span><br><span class="line">               method_getImplementation(swizzledMethod),</span><br><span class="line">               method_getTypeEncoding(swizzledMethod));</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//如果类中不存在要替换的方法，就先用class_addMethod和class_replaceMethod函数添加和替换两个方法实现。但如果已经有了要替换的方法，就调用method_exchangeImplementations函数交换两个方法的Implementation。</span></span><br><span class="line">          <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">               class_replaceMethod(<span class="keyword">class</span>,</span><br><span class="line">                    swizzledSelector,</span><br><span class="line">                    method_getImplementation(originalMethod),</span><br><span class="line">                    method_getTypeEncoding(originalMethod));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">          &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark - Method Swizzling</span></span><br><span class="line">- (<span class="keyword">void</span>)xxx_viewWillAppear:(<span class="built_in">BOOL</span>)animated &#123;</span><br><span class="line">     [<span class="keyword">self</span> xxx_viewWillAppear:animated];</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;viewWillAppear: %@&quot;</span>, <span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>


<p>method_exchangeImplementations做的事情和如下代码是一样的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IMP imp1 = <span class="built_in">method_getImplementation</span>(m1);</span><br><span class="line">IMP imp2 = <span class="built_in">method_getImplementation</span>(m2);</span><br><span class="line"><span class="built_in">method_setImplementation</span>(m1, imp2);</span><br><span class="line"><span class="built_in">method_setImplementation</span>(m2, imp1);</span><br></pre></td></tr></table></figure>

<h3 id="4-5-3-实现二"><a href="#4-5-3-实现二" class="headerlink" title="4.5.3 实现二"></a>4.5.3 实现二</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>) load&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Method originalMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(xxxx));</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(x_xxxxx));</span><br><span class="line">        <span class="comment">// 判断两个方法是不是空，本类和父类都找不到则直接return</span></span><br><span class="line">        <span class="keyword">if</span> (!originalMethod || !swizzledMethod) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 不管方法在不在本类，都执行class_addMethod方法，最后的结果是本类中两个方法都存在了，这样也不用管他们有没有被交换过。</span></span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], method_getName(originalMethod), method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        class_addMethod([<span class="keyword">self</span> <span class="keyword">class</span>], method_getName(swizzledMethod), method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="comment">// 交换，此时就不用再考虑本类父类的逻辑</span></span><br><span class="line">        method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-4-错误实现"><a href="#4-5-4-错误实现" class="headerlink" title="4.5.4 错误实现"></a>4.5.4 错误实现</h3><h4 id="1-不加判断直接exchange"><a href="#1-不加判断直接exchange" class="headerlink" title="1. 不加判断直接exchange"></a>1. 不加判断直接exchange</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Base</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)basePrint;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Base</span></span></span><br><span class="line">- (<span class="keyword">void</span>)basePrint&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">B</span> : <span class="title">Base</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">B</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line">  </span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">A</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)APrint;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">A</span></span></span><br><span class="line">+ (<span class="keyword">void</span>)load&#123;</span><br><span class="line">    Class cls = [B <span class="keyword">class</span>];</span><br><span class="line">    Method originalMethod = class_getInstanceMethod(cls, <span class="keyword">@selector</span>(basePrint));</span><br><span class="line">    Method swizzledMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(APrint));</span><br><span class="line">    <span class="comment">//这种不加判断的交换是不合理的。直接将父类的方法实现交换了</span></span><br><span class="line">    method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">&#125;</span><br><span class="line">- (<span class="keyword">void</span>)APrint&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;%s&quot;</span>,__func__);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h4 id="2-错误使用class-replaceMethod"><a href="#2-错误使用class-replaceMethod" class="headerlink" title="2. 错误使用class_replaceMethod"></a>2. 错误使用class_replaceMethod</h4><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>) load&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Method originalMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(xxxx));</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(x_xxxxx));</span><br><span class="line"><span class="comment">// ===== 错误一：如果本类中已有实现</span></span><br><span class="line">        class_replaceMethod([<span class="keyword">self</span> <span class="keyword">class</span>],</span><br><span class="line">                          method_getName(originalMethod),</span><br><span class="line">                          method_getImplementation(swizzledMethod),</span><br><span class="line">                          method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        class_replaceMethod([<span class="keyword">self</span> <span class="keyword">class</span>],</span><br><span class="line">                          method_getName(swizzledMethod),</span><br><span class="line">                          <span class="comment">//此时originalMethod已经被replace imp了，即其imp，实际上已经是swizzledMethod的IMP了</span></span><br><span class="line">                          method_getImplementation(originalMethod), </span><br><span class="line">                          method_getTypeEncoding(originalMethod));</span><br><span class="line"><span class="comment">// ===== 错误二：如果本类中没有实现</span></span><br><span class="line">        <span class="comment">// 当cls中此时没有origSelector的实现时，那class_replaceMethod实质上是class_addMethod，返回值为NULL</span></span><br><span class="line">        IMP previousIMP = class_replaceMethod([<span class="keyword">self</span> <span class="keyword">class</span>],</span><br><span class="line">                                      method_getName(originalMethod),,</span><br><span class="line">                                      method_getImplementation(swizzledMethod),</span><br><span class="line">                                      method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="comment">// 如果previousIMP，那么replaceMethod失败，即保持原样。</span></span><br><span class="line">        class_replaceMethod([<span class="keyword">self</span> <span class="keyword">class</span>],</span><br><span class="line">                            method_getName(swizzledMethod),,</span><br><span class="line">                            previousIMP,</span><br><span class="line">                            method_getTypeEncoding(originalMethod));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有几个关于Method Swizzling的资源可以参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling">How do I implement method swizzling?</a></li>
<li><a target="_blank" rel="noopener" href="http://nshipster.com/method-swizzling/">Method Swizzling</a></li>
<li><a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objectivec">What are the Dangers of Method Swizzling in Objective C?</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/rentzsch/jrswizzle">JRSwizzle</a></li>
</ul>
<h1 id="五、Category和Protocol"><a href="#五、Category和Protocol" class="headerlink" title="五、Category和Protocol"></a>五、Category和Protocol</h1><h2 id="5-1-分类Category"><a href="#5-1-分类Category" class="headerlink" title="5.1 分类Category"></a>5.1 分类Category</h2><h3 id="5-1-1-分类概述"><a href="#5-1-1-分类概述" class="headerlink" title="5.1.1 分类概述"></a>5.1.1 分类概述</h3><p>Category是Objective-C 2.0之后添加的语言特性。</p>
<p>Category 有那些用途？</p>
<ul>
<li>主要作用是为已经存在的类添加方法。常见的是给系统类添加方法、属性（需要关联对象）。</li>
<li>除此之外，apple还推荐了category的另外两个使用场景：<a target="_blank" rel="noopener" href="https://developer.apple.com/library/ios/documentation/General/Conceptual/DevPedia-CocoaCore/Category.html">官方文档</a><ul>
<li>可以把类的实现分开在几个不同的文件里面。这样做有几个显而易见的好处：<ul>
<li>可以减少单个文件的体积 </li>
<li>可以把不同的功能组织到不同的category里，实现按照不同的特性归类。</li>
<li>可以由多个开发者共同完成一个类</li>
<li>可以按需加载想要的category 等等。</li>
</ul>
</li>
<li>声明私有方法：为在.m文件中实现的方法，添加声明，使得外部可以调用。</li>
</ul>
</li>
</ul>
<p>不过除了apple推荐的使用场景，广大开发者脑洞大开，还衍生出了category的其他几个使用场景：</p>
<ul>
<li>模拟多继承</li>
<li>把framework的私有方法公开</li>
</ul>
<p>Objective-C的这个语言特性对于纯动态语言来说可能不算什么，比如javascript，你可以随时为一个“类”或者对象添加任意方法和实例变量。但是对于不是那么“动态”的语言而言，这确实是一个了不起的特性。</p>
<h3 id="5-1-2-category-t结构和Category"><a href="#5-1-2-category-t结构和Category" class="headerlink" title="5.1.2 category_t结构和Category"></a>5.1.2 category_t结构和Category</h3><p>指向分类的结构体的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;  <span class="comment">// 是指 class_name 而不是 category_name</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls;    <span class="comment">// 指向扩展的类对象，编译期间是不会定义的，而是在Runtime阶段通过name对应到对应的类对象</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span> <span class="comment">// 实例方法列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span>    <span class="comment">// 类方法列表，Meta Class方法列表的子集</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span>     <span class="comment">// 分类所实现的协议列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span>  <span class="comment">// category中添加的所有属性</span></span><br><span class="line">    <span class="comment">// Fields below this point are not always present on disk.</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *_<span class="title">classProperties</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> *<span class="title">Category</span>;</span></span><br></pre></td></tr></table></figure>

<p>从category的定义也可以看出category的：</p>
<ul>
<li>可为 (可以添加实例方法，类方法，甚至可以实现协议，添加属性(属性添加、使用，编译是能通过的，运行会crash))</li>
<li>不可为 (无法添加实例变量）<ul>
<li>编译后的类已经注册在runtime中，类结构体中的 ivars (实例变量的链表) 和 instance_size (实例变量的内存大小) 已经确定。</li>
<li>category_t 中并没有空间来存放类的成员变量Ivar。</li>
</ul>
</li>
</ul>
<p>Category里面的方法加载过程，objc源码中找到objc-os.mm，函数<code>_objc_init</code>就是runtime的加载入口由libSystem调用，开始初始化，之后objc-runtime-new.mm里的map_images会加载map到内存，<code>_read_images</code>开始初始化这个map，这时会load所有Class，Protocol和Category，NSObject的+load方法就是这个时候调用的。</p>
<h3 id="5-1-3-示例：分类的编译"><a href="#5-1-3-示例：分类的编译" class="headerlink" title="5.1.3 示例：分类的编译"></a>5.1.3 示例：分类的编译</h3><p>Lender+TT.h</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Lender.h&quot;</span></span></span><br><span class="line"><span class="built_in">NS_ASSUME_NONNULL_BEGIN</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Lender</span> (<span class="title">TT</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSString</span> * lxyname;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>Lender+TT.m</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&quot;Lender+TT.h&quot;</span></span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Lender</span> (<span class="title">TT</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)test&#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@&quot;xxxxxxxx&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>使用clang的命令去看看category到底会变成什么(主要是看一下分类中的属性底层是什么)：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">sizeof</span></span>(_objc_method),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;(struct objc_selector *)<span class="string">&quot;test&quot;</span>, <span class="string">&quot;v16@0:8&quot;</span>, (<span class="keyword">void</span> *)_I_Lender_TT_test&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//属性列表</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Lender_$_TT __attribute__ ((used, <span class="built_in">section</span> (<span class="string">&quot;__DATA,__objc_const&quot;</span>))) = &#123;</span><br><span class="line">	<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">	<span class="number">1</span>,</span><br><span class="line">	&#123;&#123;<span class="string">&quot;lxyname&quot;</span>,<span class="string">&quot;T@\&quot;NSString\&quot;,&amp;,N&quot;</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> __declspec(dllimport) <span class="class"><span class="keyword">struct</span> _<span class="title">class_t</span> <span class="title">OBJC_CLASS_</span>$_<span class="title">Lender</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//分类</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_Lender_</span>$_<span class="title">TT</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>,__<span class="title">objc_const</span>&quot;))) =</span> </span><br><span class="line">&#123;</span><br><span class="line">	<span class="string">&quot;Lender&quot;</span>,</span><br><span class="line">	<span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Lender,</span></span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	<span class="number">0</span>,</span><br><span class="line">	(<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_Lender_$_TT,  <span class="comment">//属性列表</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时期给分类结构的.cls赋值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_Lender_$_TT(<span class="keyword">void</span> ) &#123;</span><br><span class="line">	_OBJC_$_CATEGORY_Lender_$_TT.cls = &amp;OBJC_CLASS_$_Lender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> section(<span class="meta-string">&quot;.objc_inithooks$B&quot;</span>, long, read, write)</span></span><br><span class="line">__declspec(<span class="built_in">allocate</span>(<span class="string">&quot;.objc_inithooks$B&quot;</span>)) <span class="keyword">static</span> <span class="keyword">void</span> *OBJC_CATEGORY_SETUP[] = &#123;</span><br><span class="line">	(<span class="keyword">void</span> *)&amp;OBJC_CATEGORY_SETUP_$_Lender_$_TT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> *<span class="title">L_OBJC_LABEL_CATEGORY_</span>$ [1] __<span class="title">attribute__</span>((<span class="title">used</span>, <span class="title">section</span> (&quot;__<span class="title">DATA</span>, __<span class="title">objc_catlist</span>,<span class="title">regular</span>,<span class="title">no_dead_strip</span>&quot;)))=</span> &#123;</span><br><span class="line">	&amp;_OBJC_$_CATEGORY_Lender_$_TT,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">IMAGE_INFO</span> &#123;</span> <span class="keyword">unsigned</span> version; <span class="keyword">unsigned</span> flag; &#125; _OBJC_IMAGE_INFO = &#123; <span class="number">0</span>, <span class="number">2</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以看到：</p>
<ol>
<li><p>首先编译器生成了实例方法列表 <code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Lender_$_TT</code> 和属性列表 <code>_OBJC_$_PROP_LIST_Lender_$_TT</code>，两者的命名都遵循了公共前缀+类名+category名字的命名方式，而且实例方法列表里面填充的正是我们在 <code>TT</code> 这个category里面写的方法 <code>test</code>，而属性列表里面填充的也正是我们在 <code>TT</code> 里添加的 <code>lxyname</code> 属性。还有一个需要注意到的事实就是category的名字用来给各种列表以及后面的category结构体本身命名，而且有static来修饰，所以在同一个编译单元里我们的category名不能重复，否则会出现编译错误。</p>
</li>
<li><p>其次，编译器生成了category本身 <code>_OBJC_$_CATEGORY_Lender_$_TT</code>，并用前面生成的列表来初始化category本身。</p>
</li>
<li><p>最后，编译器在<strong>DATA segment(段)下的objc_catlist section(节)</strong> 里保存了一个大小为1的category_t的数组<code>L_OBJC_LABEL_CATEGORY_$</code>（当然，如果有多个category，会生成对应长度的数组^_^），用于运行期category的加载。</p>
</li>
</ol>
<h3 id="5-1-4-分类的运行时处理"><a href="#5-1-4-分类的运行时处理" class="headerlink" title="5.1.4 分类的运行时处理"></a>5.1.4 分类的运行时处理</h3><p>见<a href="https://tenloy.github.io/2021/10/21/dyld-objc.html#4-2-loadAllCategories-%E5%88%86%E7%B1%BB%E5%8A%A0%E8%BD%BD">dyld与Runtime—_objc_init、map_images、load_images的4.2小节：分类的加载</a></p>
<h2 id="5-2-类扩展-Extension"><a href="#5-2-类扩展-Extension" class="headerlink" title="5.2 类扩展(Extension)"></a>5.2 类扩展(Extension)</h2><p>extension看起来很像一个匿名的category，但是extension和有名字的category几乎完全是两个东西。 </p>
<p>extension在编译期决议，它就是类的一部分，在编译期和头文件里的@interface以及实现文件里的@implement一起形成一个完整的类，它伴随类的产生而产生，亦随之一起消亡。extension一般用来隐藏类的私有信息，你必须有一个类的源码才能为一个类添加extension，所以你无法为系统的类比如NSString添加extension。（详见官方文档<a target="_blank" rel="noopener" href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html">Customizing Existing Classes</a>）</p>
<p>但是category则完全不一样，它是在运行期决议的。可以为系统 framework、第三方框架等添加 category。 </p>
<p>就category和extension的区别来看，我们可以推导出一个明显的事实，extension可以添加实例变量，而category是无法添加实例变量的（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p>
<h2 id="5-3-Protocol"><a href="#5-3-Protocol" class="headerlink" title="5.3 Protocol"></a>5.3 Protocol</h2><p>Protocol其实就是一个对象结构体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">objc_object</span> <span class="title">Protocol</span>;</span></span><br></pre></td></tr></table></figure>

<h2 id="5-4-操作函数"><a href="#5-4-操作函数" class="headerlink" title="5.4 操作函数"></a>5.4 操作函数</h2><h3 id="5-4-1-Category操作函数"><a href="#5-4-1-Category操作函数" class="headerlink" title="5.4.1 Category操作函数"></a>5.4.1 Category操作函数</h3><p>Category操作函数信息都包含在objc_class中，我们可以通过objc_class的操作函数来获取分类的操作函数信息。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> : <span class="title">NSObject</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method1;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)method2;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span></span></span><br><span class="line">- (<span class="keyword">void</span>)method1 &#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">RuntimeCategoryClass</span> (<span class="title">Category</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)method2 &#123;&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> mark -</span></span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@&quot;测试objc_class中的方法列表是否包含分类中的方法&quot;</span>);</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> outCount = <span class="number">0</span>;</span><br><span class="line">Method *methodList = class_copyMethodList(RuntimeCategoryClass.class, &amp;outCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">     Method method = methodList[i];</span><br><span class="line"></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name = sel_getName(method_getName(method));</span><br><span class="line"></span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;RuntimeCategoryClass&#x27;s method: %s&quot;</span>, name);</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (strcmp(name, sel_getName(<span class="keyword">@selector</span>(method2)))) &#123;</span><br><span class="line">          <span class="built_in">NSLog</span>(<span class="string">@&quot;分类方法method2在objc_class的方法列表中&quot;</span>);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.213</span> [<span class="number">561</span>:<span class="number">151847</span>] 测试objc_class中的方法列表是否包含分类中的方法</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.215</span> [<span class="number">561</span>:<span class="number">151847</span>] RuntimeCategoryClass<span class="string">&#x27;s method: method2</span></span><br><span class="line"><span class="string">2014-11-08 10:36:39.215 [561:151847] RuntimeCategoryClass&#x27;</span>s method: method1</span><br><span class="line"><span class="number">2014</span><span class="number">-11</span><span class="number">-08</span> <span class="number">10</span>:<span class="number">36</span>:<span class="number">39.215</span> [<span class="number">561</span>:<span class="number">151847</span>] 分类方法method2在objc_class的方法列表中</span><br></pre></td></tr></table></figure>

<h3 id="5-4-2-Protocol操作函数"><a href="#5-4-2-Protocol操作函数" class="headerlink" title="5.4.2 Protocol操作函数"></a>5.4.2 Protocol操作函数</h3><p>Runtime提供了Protocol的一系列函数操作，函数包括：</p>
<h4 id="1-获取协议"><a href="#1-获取协议" class="headerlink" title="1. 获取协议"></a>1. 获取协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定的协议</span></span><br><span class="line"><span class="function">Protocol *<span class="title">objc_getProtocol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取运行时所知道的所有协议的数组</span></span><br><span class="line"><span class="function">Protocol **<span class="title">objc_copyProtocolList</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-查询协议的信息"><a href="#2-查询协议的信息" class="headerlink" title="2. 查询协议的信息"></a>2. 查询协议的信息</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回协议名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">protocol_getName</span><span class="params">(Protocol *proto)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试两个协议是否相等</span></span><br><span class="line"><span class="function">BOOL <span class="title">protocol_isEqual</span><span class="params">(Protocol *self, Protocol *other)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定条件的方法描述数组</span></span><br><span class="line"><span class="function">struct objc_method_description *<span class="title">protocol_copyMethodDescriptionList</span><span class="params">(Protocol *p, </span></span></span><br><span class="line"><span class="function"><span class="params">                                   BOOL isRequiredMethod,BOOL isInstanceMethod,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中指定方法的方法描述</span></span><br><span class="line"><span class="function">struct objc_method_description <span class="title">protocol_getMethodDescription</span><span class="params">(Protocol *p, SEL aSel, </span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredMethod, BOOL isInstanceMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议中的属性列表</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> *<span class="title">protocol_copyPropertyList</span><span class="params">(Protocol *proto, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取协议的指定属性</span></span><br><span class="line"><span class="function"><span class="keyword">objc_property_t</span> <span class="title">protocol_getProperty</span><span class="params">(Protocol *p, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br><span class="line"><span class="comment">// 获取协议遵守的协议</span></span><br><span class="line"><span class="function">Protocol ** <span class="title">protocol_copyProtocolList</span><span class="params">(Protocol *p, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查看协议是否遵守了另一个协议</span></span><br><span class="line"><span class="function">BOOL <span class="title">protocol_conformsToProtocol</span><span class="params">(Protocol *self, Protocol *other)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="3-动态创建协议"><a href="#3-动态创建协议" class="headerlink" title="3. 动态创建协议"></a>3. 动态创建协议</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新的协议实例</span></span><br><span class="line"><span class="function">Protocol *<span class="title">objc_allocateProtocol</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addMethodDescription</span><span class="params">(Protocol *proto_gen, SEL name, <span class="keyword">const</span> <span class="keyword">char</span> *types,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BOOL isRequiredMethod, BOOL isInstanceMethod)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加属性 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addProperty</span><span class="params">(Protocol *proto_gen, <span class="keyword">const</span> <span class="keyword">char</span> *name, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">const</span> <span class="keyword">objc_property_attribute_t</span> *attrs, </span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="keyword">unsigned</span> <span class="keyword">int</span> count,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BOOL isRequiredProperty, BOOL isInstanceProperty)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为协议添加一个已注册的协议。proto必须正在构造中。addition则不能，必须是已注册的。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">protocol_addProtocol</span><span class="params">(Protocol *proto, Protocol *addition)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在运行时中注册新创建的协议。</span></span><br><span class="line"><span class="comment">// 创建一个新协议后必须使用这个进行注册这个新协议，但是注册后不能够再修改和添加新方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_registerProtocol</span><span class="params">(Protocol *proto_gen)</span></span>;</span><br></pre></td></tr></table></figure>

<h1 id="六、Block"><a href="#六、Block" class="headerlink" title="六、Block"></a>六、Block</h1><p>runtime中一些支持block操作的函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个指针函数的指针，该函数调用时会调用特定的block</span></span><br><span class="line"><span class="function">IMP <span class="title">imp_implementationWithBlock</span><span class="params">(id block)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回与IMP(使用imp_implementationWithBlock创建的)相关的block</span></span><br><span class="line"><span class="function">id <span class="title">imp_getBlock</span><span class="params">(IMP anImp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解除block与IMP(使用imp_implementationWithBlock创建的)的关联关系，并释放block的拷贝</span></span><br><span class="line"><span class="function">BOOL <span class="title">imp_removeBlock</span><span class="params">(IMP anImp)</span></span>;</span><br></pre></td></tr></table></figure>


<p>测试代码</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">MyRuntimeBlock</span> : <span class="title">NSObject</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">MyRuntimeBlock</span></span></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">IMP imp = imp_implementationWithBlock(^(<span class="keyword">id</span> obj, <span class="built_in">NSString</span> *str) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(<span class="string">@&quot;%@&quot;</span>, str);</span><br><span class="line">&#125;);</span><br><span class="line">class_addMethod(MyRuntimeBlock.class, <span class="keyword">@selector</span>(testBlock:), imp, <span class="string">&quot;v@:@&quot;</span>);</span><br><span class="line">MyRuntimeBlock *runtime = [[MyRuntimeBlock alloc] init];</span><br><span class="line">[runtime performSelector:<span class="keyword">@selector</span>(testBlock:) withObject:<span class="string">@&quot;hello world!&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">14</span>:<span class="number">03</span>:<span class="number">19.779</span> [<span class="number">1172</span>:<span class="number">395446</span>] hello world!</span><br></pre></td></tr></table></figure>

<h1 id="七、Runtime的应用"><a href="#七、Runtime的应用" class="headerlink" title="七、Runtime的应用"></a>七、Runtime的应用</h1><h2 id="7-1-获取系统提供的库相关信息"><a href="#7-1-获取系统提供的库相关信息" class="headerlink" title="7.1 获取系统提供的库相关信息"></a>7.1 获取系统提供的库相关信息</h2><p>主要函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取所有加载的objective-c框架和动态库的名称</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">objc_copyImageNames</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定类所在动态库</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">class_getImageName</span><span class="params">(Class cls)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取指定库或框架中所有类的类名</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> **<span class="title">objc_copyClassNamesForImage</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *image, <span class="keyword">unsigned</span> <span class="keyword">int</span> *outCount)</span></span>;</span><br></pre></td></tr></table></figure>

<p>示例：通过这些函数获取某个类所在的库，以及某个库中包含哪些类：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;获取指定类所在动态库&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;UIView&#x27;s Framework: %s&quot;</span>, <span class="built_in">class_getImageName</span>(<span class="built_in">NSClassFromString</span>(@<span class="string">&quot;UIView&quot;</span>)));</span><br><span class="line"></span><br><span class="line"><span class="built_in">NSLog</span>(@<span class="string">&quot;获取指定库或框架中所有类的类名&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> ** classes = <span class="built_in">objc_copyClassNamesForImage</span>(<span class="built_in">class_getImageName</span>(<span class="built_in">NSClassFromString</span>(@<span class="string">&quot;UIView&quot;</span>)), &amp;outCount);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; outCount; i++) &#123;</span><br><span class="line">     <span class="built_in">NSLog</span>(@<span class="string">&quot;class name: %s&quot;</span>, classes[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果</span></span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.689</span> [<span class="number">7</span>:<span class="number">1</span>] 获取指定类所在动态库</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.690</span> [<span class="number">7</span>:<span class="number">1</span>] UIView<span class="number">&#x27;</span>s Framework: /System/Library/Frameworks/UIKit.framework/UIKit</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.690</span> [<span class="number">7</span>:<span class="number">1</span>] 获取指定库或框架中所有类的类名</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> UIKeyboardPredictiveSettings</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewTopFrame</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.691</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIOnePartImageView</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewSelectionBar</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerWheelView</span><br><span class="line"><span class="number">12</span>:<span class="number">57</span>:<span class="number">32.692</span> [<span class="number">7</span>:<span class="number">1</span>] <span class="class"><span class="keyword">class</span> <span class="title">name</span>:</span> _UIPickerViewTestParameters</span><br></pre></td></tr></table></figure>

<h2 id="7-2-对App的用户行为进行追踪"><a href="#7-2-对App的用户行为进行追踪" class="headerlink" title="7.2 对App的用户行为进行追踪"></a>7.2 对App的用户行为进行追踪</h2><p>就是用户点击时把事件记录下来。一般比较做法就是在viewDidAppear里记录事件，这样会让这样记录事件的代码遍布整个项目中。继承或类别也会有问题。这时利用Method Swizzling把一个方法的实现和另一个方法的实现进行替换。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先定义一个类别，添加要Swizzled的方法</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">UIViewController</span> (<span class="title">Logging</span>)</span></span><br><span class="line">- (<span class="keyword">void</span>)swizzled_viewDidAppear:(<span class="built_in">BOOL</span>)animated</span><br><span class="line">&#123; <span class="comment">// call original implementation</span></span><br><span class="line">     [<span class="keyword">self</span> swizzled_viewDidAppear:animated]; <span class="comment">// Logging</span></span><br><span class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([<span class="keyword">self</span> <span class="keyword">class</span>])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来实现swizzle方法</span></span><br><span class="line"><span class="keyword">void</span> swizzleMethod(Class <span class="keyword">class</span>, SEL originalSelector, SEL swizzledSelector) &#123; <span class="comment">// the method might not exist in the class, but in its superclass</span></span><br><span class="line">     Method originalMethod = class_getInstanceMethod(<span class="keyword">class</span>, originalSelector);</span><br><span class="line">     Method swizzledMethod = class_getInstanceMethod(<span class="keyword">class</span>, swizzledSelector); <span class="comment">// class_addMethod will fail if original method already exists</span></span><br><span class="line">     <span class="built_in">BOOL</span> didAddMethod = class_addMethod(<span class="keyword">class</span>, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); <span class="comment">// the method doesn’t exist and we just added one</span></span><br><span class="line">     <span class="keyword">if</span> (didAddMethod) &#123;</span><br><span class="line">          class_replaceMethod(<span class="keyword">class</span>, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> &#123;</span><br><span class="line">          method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后要确保在程序启动的时候调用swizzleMethod方法在之前的UIViewController的Logging类别里添加+load:方法，然后在+load:里把viewDidAppear替换掉</span></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     swizzleMethod([<span class="keyword">self</span> <span class="keyword">class</span>], <span class="keyword">@selector</span>(viewDidAppear:), <span class="keyword">@selector</span>(swizzled_viewDidAppear:));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更简化直接用新的IMP取代原IMP，不是替换，只需要有全局的函数指针指向原IMP即可。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">void</span></span> (gOriginalViewDidAppear)(id, SEL, BOOL);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">newViewDidAppear</span><span class="params">(UIViewController *self, SEL _cmd, BOOL animated)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="comment">// call original implementation</span></span><br><span class="line">     <span class="built_in">gOriginalViewDidAppear</span>(self, _cmd, animated); <span class="comment">// Logging</span></span><br><span class="line">     [Logging logWithEventName:<span class="built_in">NSStringFromClass</span>([self class])];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load</span><br><span class="line">&#123;</span><br><span class="line">     Method originalMethod = <span class="built_in">class_getInstanceMethod</span>(self, @<span class="built_in">selector</span>(viewDidAppear:));</span><br><span class="line">     gOriginalViewDidAppear = (<span class="keyword">void</span> *)<span class="built_in">method_getImplementation</span>(originalMethod);</span><br><span class="line">     <span class="keyword">if</span>(!<span class="built_in">class_addMethod</span>(self, @<span class="built_in">selector</span>(viewDidAppear:), (IMP) newViewDidAppear, <span class="built_in">method_getTypeEncoding</span>(originalMethod))) &#123;</span><br><span class="line">          <span class="built_in">method_setImplementation</span>(originalMethod, (IMP) newViewDidAppear);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Method Swizzling可以把事件代码或Logging，Authentication，Caching等跟主要业务逻辑代码解耦。这种处理方式叫做<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Cross-cutting_concern">Cross Cutting Concerns</a>。</p>
<p>用Method Swizzling动态给指定的方法添加代码解决Cross Cutting Concerns的编程方式叫<a target="_blank" rel="noopener" href="http://en.wikipedia.org/wiki/Aspect-oriented_programming">Aspect Oriented Programming</a>。</p>
<p>目前有些第三方库可以很方便的使用AOP，比如<a target="_blank" rel="noopener" href="https://github.com/steipete/Aspects">Aspects</a>。这里是使用<a target="_blank" rel="noopener" href="https://github.com/okcomp/AspectsDemo">Aspects的范例</a>。</p>

    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="https://tenloy.github.io">Tenloy</a>
            <p>原文链接：<a href="https://tenloy.github.io/2020/10/28/runtime-data-structure.html">https://tenloy.github.io/2020/10/28/runtime-data-structure.html</a>
            <p>发表日期：2020.10.28 , 10:26 AM</p>
            <p>更新日期：2024.05.09 , 10:53 AM</p>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Crative Commons 4.0 许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2020/12/09/pki.html" title= "常见的PKI标准(X.509、PKCS)及证书相关介绍">
                    <div class="nextTitle">常见的PKI标准(X.509、PKCS)及证书相关介绍</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/09/11/GCD.html" title= "Objective-C — 深入浅出GCD常用API">
                    <div class="prevTitle">Objective-C — 深入浅出GCD常用API</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:luotengoto@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/Tenloy" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <a href="https://www.jianshu.com/u/8db1bc12db9f" class="iconfont-jian jianshu" target="_blank" title=jianshu></a>
            
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:40vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81Runtime%E6%A6%82%E8%BF%B0"><span class="toc-text">一、Runtime概述</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-Runtime%E5%81%9A%E4%BA%86%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">1.1 Runtime做了什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%AD%A6%E4%B9%A0%E9%93%BE%E6%8E%A5"><span class="toc-text">1.2 学习链接</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Object%E3%80%81Class%E4%B8%8EMetaClass"><span class="toc-text">二、Object、Class与MetaClass</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E7%AE%80%E5%9B%BE"><span class="toc-text">关系简图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-objc-object%E4%B8%8Eid"><span class="toc-text">2.1 objc_object与id</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-text">对象是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-objc-class"><span class="toc-text">2.2 objc_class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-1-%E6%88%90%E5%91%98-isa-t-isa"><span class="toc-text">2.2.1 成员: isa_t isa</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ETagged-Pointer"><span class="toc-text">关于Tagged Pointer</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-2-%E6%88%90%E5%91%98-cache-t-cache"><span class="toc-text">2.2.2 成员: cache_t cache</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A6%81%E7%82%B9%EF%BC%9A"><span class="toc-text">要点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-3-%E6%88%90%E5%91%98-class-data-bits-t-bits"><span class="toc-text">2.2.3 成员: class_data_bits_t bits</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">1. 数据结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-class-rw-t%E4%B8%8Eclass-ro-t%E7%AE%80%E4%BB%8B"><span class="toc-text">2. class_rw_t与class_ro_t简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-bits%E5%9C%A8%E7%BC%96%E8%AF%91%E3%80%81%E8%BF%90%E8%A1%8C%E6%9C%9F%E9%97%B4%E5%80%BC%E7%9A%84%E6%94%B9%E5%8F%98"><span class="toc-text">3. bits在编译、运行期间值的改变</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-4-%E6%96%B9%E6%B3%95-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B%E4%B8%AD%EF%BC%8C%E7%8A%B6%E6%80%81%E8%AF%BB%E5%86%99"><span class="toc-text">2.2.4 方法: 类加载过程中，状态读写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-5-%E6%96%B9%E6%B3%95-%E7%B1%BB%E7%8A%B6%E6%80%81%E8%8E%B7%E5%8F%96"><span class="toc-text">2.2.5 方法: 类状态获取</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2-6-%E6%96%B9%E6%B3%95-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-text">2.2.6 方法: 内存分配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-class-rw-t"><span class="toc-text">2.3 class_rw_t</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4-class-ro-t"><span class="toc-text">2.4 class_ro_t</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-1-ivarLayout%E4%B8%8EweakIvarLayout"><span class="toc-text">2.4.1 ivarLayout与weakIvarLayout</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%80%BC%E7%9A%84%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="toc-text">1. 值的存储格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">2. 操作函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E7%A4%BA%E4%BE%8B"><span class="toc-text">3. 示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-text">4. 使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-2-%E5%87%A0%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-text">2.4.2 几点总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-5-%E5%85%83%E7%B1%BB-Meta-Class"><span class="toc-text">2.5 元类(Meta Class)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%AD%98%E5%9C%A8%E5%85%83%E7%B1%BB%EF%BC%9F"><span class="toc-text">2.5.1 为什么存在元类？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-2-%E5%85%83%E7%B1%BB%E7%9A%84isa-%E2%80%94-%E7%B1%BB"><span class="toc-text">2.5.2 元类的isa — 类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-3-%E5%85%83%E7%B1%BB%E7%9A%84superclass-%E2%80%94-%E7%88%B6%E7%B1%BB"><span class="toc-text">2.5.3 元类的superclass — 父类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-5-4-%E6%80%BB%E7%BB%93"><span class="toc-text">2.5.4 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-6-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">2.6 类与对象操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-1-%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96%E5%92%8C%E5%88%A4%E6%96%AD%E5%87%BD%E6%95%B0"><span class="toc-text">2.6.1 类型获取和判断函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E7%B1%BB%E5%9E%8B%E8%8E%B7%E5%8F%96"><span class="toc-text">1. 类型获取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD"><span class="toc-text">2. 类型判断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%88%A4%E6%96%AD%E6%98%AF%E5%90%A6%E6%98%AF%E5%85%83%E7%B1%BB"><span class="toc-text">3. 判断是否是元类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-2-%E7%B1%BB%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">2.6.2 类相关操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96name"><span class="toc-text">1. 获取name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96super-class"><span class="toc-text">2. 获取super_class</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E8%8E%B7%E5%8F%96instance-size"><span class="toc-text">3. 获取instance_size</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-ivars-%E6%93%8D%E4%BD%9C"><span class="toc-text">4. 成员变量(ivars)操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-%E6%96%B9%E6%B3%95%E6%93%8D%E4%BD%9C"><span class="toc-text">5. 方法操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-%E5%8D%8F%E8%AE%AE%E6%93%8D%E4%BD%9C"><span class="toc-text">6. 协议操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-%E8%8E%B7%E5%8F%96%E7%89%88%E6%9C%AC%E5%8F%B7"><span class="toc-text">7. 获取版本号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-%E7%A4%BA%E4%BE%8B"><span class="toc-text">8. 示例</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-3-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-text">2.6.3 动态创建类和对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E7%B1%BB"><span class="toc-text">1. 动态创建类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-text">2. 动态创建对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-4-%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">2.6.4 实例对象相关操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E6%93%8D%E4%BD%9C-%E6%95%B4%E4%B8%AA%E5%AF%B9%E8%B1%A1-%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">1. 操作 整个对象 的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%93%8D%E4%BD%9C-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%B1%BB-%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-text">2. 操作 对象的类 的函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-6-5-%E8%8E%B7%E5%8F%96%E7%B1%BB%E5%AE%9A%E4%B9%89"><span class="toc-text">2.6.5 获取类定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E3%80%81%E5%B1%9E%E6%80%A7%E4%B8%8E%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1"><span class="toc-text">三、成员变量、属性与关联对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8BIvar"><span class="toc-text">3.1 实例变量类型Ivar</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-Ivar%E7%BB%93%E6%9E%84"><span class="toc-text">3.1.1 Ivar结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-2-Ivar%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E6%B7%BB%E5%8A%A0"><span class="toc-text">3.1.2 Ivar的获取和添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-3-%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">3.1.3 实例变量操作函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-%E5%B1%9E%E6%80%A7%E7%B1%BB%E5%9E%8Bproperty-t"><span class="toc-text">3.2 属性类型property_t</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-1-property-t%E7%BB%93%E6%9E%84%E5%92%8Cobjc-property-t"><span class="toc-text">3.2.1 property_t结构和objc_property_t</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-2-property%E7%9A%84%E8%8E%B7%E5%8F%96%E5%92%8C%E6%B7%BB%E5%8A%A0"><span class="toc-text">3.2.2 property的获取和添加</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-3-property%E7%9A%84%E7%89%B9%E6%80%A7attributes"><span class="toc-text">3.2.3 property的特性attributes</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-4-%E7%A4%BA%E4%BE%8B"><span class="toc-text">3.2.4 示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-3-%E5%85%B3%E8%81%94%E5%AF%B9%E8%B1%A1"><span class="toc-text">3.3 关联对象</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Method%E5%92%8C%E6%B6%88%E6%81%AF"><span class="toc-text">四、Method和消息</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-method-t%E3%80%81SEL%E5%92%8CIMP"><span class="toc-text">4.1 method_t、SEL和IMP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-1-method-t%E7%BB%93%E6%9E%84%E5%92%8CMethod"><span class="toc-text">4.1.1 method_t结构和Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-2-SEL"><span class="toc-text">4.1.2 SEL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-3-IMP"><span class="toc-text">4.1.3 IMP</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-Method%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">4.2 Method相关操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-1-%E8%8E%B7%E5%8F%96Method%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">4.2.1 获取Method的信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-2-%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AEMethod%E7%9A%84IMP"><span class="toc-text">4.2.2 获取和设置Method的IMP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-3-%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8Method"><span class="toc-text">4.2.3 直接调用Method</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-4-SEL%E7%9A%84%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">4.2.4 SEL的操作函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-Method%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8Bobjc-msgSend"><span class="toc-text">4.3 Method调用流程objc_msgSend</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">流程概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-1-%E6%B6%88%E6%81%AF%E5%8F%91%E9%80%81"><span class="toc-text">4.3.1 消息发送</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-2-%E5%8A%A8%E6%80%81%E6%96%B9%E6%B3%95%E8%A7%A3%E6%9E%90"><span class="toc-text">4.3.2 动态方法解析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-3-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91"><span class="toc-text">4.3.3 消息转发</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E9%87%8D%E5%AE%9A%E5%90%91%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-text">1. 重定向接收者</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9C%80%E5%90%8E%E8%BF%9B%E8%A1%8C%E8%BD%AC%E5%8F%91"><span class="toc-text">2. 最后进行转发</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-4-%E6%B6%88%E6%81%AF%E8%BD%AC%E5%8F%91%E5%92%8C%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-text">4.3.4 消息转发和多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-5-Message%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-text">4.3.5 Message消息的参考文章</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4-super%E5%92%8Cobjc-msgSendSuper"><span class="toc-text">4.4 super和objc_msgSendSuper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5-Method-Swizzling"><span class="toc-text">4.5 Method Swizzling</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-1-%E4%BD%BF%E7%94%A8method-swizzling%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text">4.5.1 使用method swizzling需要注意的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-2-%E5%AE%9E%E7%8E%B0%E4%B8%80"><span class="toc-text">4.5.2 实现一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-3-%E5%AE%9E%E7%8E%B0%E4%BA%8C"><span class="toc-text">4.5.3 实现二</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-4-%E9%94%99%E8%AF%AF%E5%AE%9E%E7%8E%B0"><span class="toc-text">4.5.4 错误实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E4%B8%8D%E5%8A%A0%E5%88%A4%E6%96%AD%E7%9B%B4%E6%8E%A5exchange"><span class="toc-text">1. 不加判断直接exchange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E9%94%99%E8%AF%AF%E4%BD%BF%E7%94%A8class-replaceMethod"><span class="toc-text">2. 错误使用class_replaceMethod</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81Category%E5%92%8CProtocol"><span class="toc-text">五、Category和Protocol</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%88%86%E7%B1%BBCategory"><span class="toc-text">5.1 分类Category</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1-%E5%88%86%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-text">5.1.1 分类概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-2-category-t%E7%BB%93%E6%9E%84%E5%92%8CCategory"><span class="toc-text">5.1.2 category_t结构和Category</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-3-%E7%A4%BA%E4%BE%8B%EF%BC%9A%E5%88%86%E7%B1%BB%E7%9A%84%E7%BC%96%E8%AF%91"><span class="toc-text">5.1.3 示例：分类的编译</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-4-%E5%88%86%E7%B1%BB%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%A4%84%E7%90%86"><span class="toc-text">5.1.4 分类的运行时处理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E7%B1%BB%E6%89%A9%E5%B1%95-Extension"><span class="toc-text">5.2 类扩展(Extension)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3-Protocol"><span class="toc-text">5.3 Protocol</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-4-%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">5.4 操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-1-Category%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">5.4.1 Category操作函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-2-Protocol%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-text">5.4.2 Protocol操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E8%8E%B7%E5%8F%96%E5%8D%8F%E8%AE%AE"><span class="toc-text">1. 获取协议</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E6%9F%A5%E8%AF%A2%E5%8D%8F%E8%AE%AE%E7%9A%84%E4%BF%A1%E6%81%AF"><span class="toc-text">2. 查询协议的信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%8D%8F%E8%AE%AE"><span class="toc-text">3. 动态创建协议</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81Block"><span class="toc-text">六、Block</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81Runtime%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-text">七、Runtime的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-%E8%8E%B7%E5%8F%96%E7%B3%BB%E7%BB%9F%E6%8F%90%E4%BE%9B%E7%9A%84%E5%BA%93%E7%9B%B8%E5%85%B3%E4%BF%A1%E6%81%AF"><span class="toc-text">7.1 获取系统提供的库相关信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-%E5%AF%B9App%E7%9A%84%E7%94%A8%E6%88%B7%E8%A1%8C%E4%B8%BA%E8%BF%9B%E8%A1%8C%E8%BF%BD%E8%B8%AA"><span class="toc-text">7.2 对App的用户行为进行追踪</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    
    
    
    
        <span class="sidebar-category-name" data-categories="数据结构与算法"><span class="iconfont-archer">&#xe60a;</span>数据结构与算法</span>
    
        <span class="sidebar-category-name" data-categories="计算机组成原理"><span class="iconfont-archer">&#xe60a;</span>计算机组成原理</span>
    
        <span class="sidebar-category-name" data-categories="计算机网络"><span class="iconfont-archer">&#xe60a;</span>计算机网络</span>
    
        <span class="sidebar-category-name" data-categories="汇编语言"><span class="iconfont-archer">&#xe60a;</span>汇编语言</span>
    
        <span class="sidebar-category-name" data-categories="数据的存储与传输"><span class="iconfont-archer">&#xe60a;</span>数据的存储与传输</span>
    
        <span class="sidebar-category-name" data-categories="操作系统"><span class="iconfont-archer">&#xe60a;</span>操作系统</span>
    
        <span class="sidebar-category-name" data-categories="互联网标准RFC"><span class="iconfont-archer">&#xe60a;</span>互联网标准RFC</span>
    
        <span class="sidebar-category-name" data-categories="编译链接与装载"><span class="iconfont-archer">&#xe60a;</span>编译链接与装载</span>
    
        <span class="sidebar-category-name" data-categories="iOS"><span class="iconfont-archer">&#xe60a;</span>iOS</span>
    
        <span class="sidebar-category-name" data-categories="架构与设计模式"><span class="iconfont-archer">&#xe60a;</span>架构与设计模式</span>
    
        <span class="sidebar-category-name" data-categories="图形处理与渲染"><span class="iconfont-archer">&#xe60a;</span>图形处理与渲染</span>
    
        <span class="sidebar-category-name" data-categories="软件工程"><span class="iconfont-archer">&#xe60a;</span>软件工程</span>
    
        <span class="sidebar-category-name" data-categories="音视频处理"><span class="iconfont-archer">&#xe60a;</span>音视频处理</span>
    
        <span class="sidebar-category-name" data-categories="DSL"><span class="iconfont-archer">&#xe60a;</span>DSL</span>
    
        <span class="sidebar-category-name" data-categories="Swift"><span class="iconfont-archer">&#xe60a;</span>Swift</span>
    
        <span class="sidebar-category-name" data-categories="Git"><span class="iconfont-archer">&#xe60a;</span>Git</span>
    
        <span class="sidebar-category-name" data-categories="Web"><span class="iconfont-archer">&#xe60a;</span>Web</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 75
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-side-search"> 
                <span class="iconfont-jian search-icon">&#xe7fc;搜索</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2022 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span><a class="archive-post-title" href= "/2022/05/05/sqlite.html" >iOS SQLite的使用与优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href= "/2022/04/28/mmap.html" >内存映射mmap函数的原理与应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/18</span><a class="archive-post-title" href= "/2022/03/18/avfoundation.html" >AVFoundation Programming Guide(译)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span><a class="archive-post-title" href= "/2022/03/17/avframework.html" >iOS音视频库概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2022/02/09/OAuth.html" >[转] OAuth 2.0简述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/18</span><a class="archive-post-title" href= "/2022/01/18/wkwebview-buges.html" >WKWebView使用过程中遇到的坑</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/22</span><a class="archive-post-title" href= "/2021/11/22/bit-calculation.html" >[转] 位运算实现加、减、乘、除运算</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span><a class="archive-post-title" href= "/2021/11/10/git-use.html" >Git的使用总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/21</span><a class="archive-post-title" href= "/2021/10/21/dyld-objc.html" >(六) dyld与Runtime—_objc_init、map_images、load_images</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/18</span><a class="archive-post-title" href= "/2021/10/18/compile-dynamic-link.html" >(五) Mach-O 文件的动态链接、库、Dyld(含dlopen)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span><a class="archive-post-title" href= "/2021/10/10/compile-load.html" >(四) Mach-O 文件的装载、ASLR及符号地址</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/08</span><a class="archive-post-title" href= "/2021/10/08/compile-static-link.html" >(三) Mach-O 文件的静态链接</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/06</span><a class="archive-post-title" href= "/2021/10/06/compile-macho.html" >(二) Mach-O 文件结构</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2021/10/05/compile-clang-llvm.html" >(一) Clang/LLVM 介绍、OC 程序的编译过程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/02</span><a class="archive-post-title" href= "/2021/10/02/makefile.html" >[转] Make 命令的使用与NodeJS案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/2021/09/28/architectural-pattern.html" >常见架构模式: MVC、MVP、MVVM、VIPER</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href= "/2021/09/25/design-pattern.html" >常见的设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href= "/2021/09/20/program-thought.html" >常见的编程范式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing-case.html" >图形处理(三) - 图形处理实践案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing.html" >图形处理(二) - 图形与视频处理相关的框架</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2021/09/13/image-encode-decode.html" >图形处理(一) - 图片的加载与编解码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/12</span><a class="archive-post-title" href= "/2021/09/12/iOS-Render.html" >[转] iOS离屏渲染原理及优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2021/09/11/core-animation03.html" >Core-Animation(三) - 渲染流程探究及性能分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/09</span><a class="archive-post-title" href= "/2021/09/09/core-animation02.html" >Core Animation(二) - 隐式动画、CATransaction与CAAction</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/07</span><a class="archive-post-title" href= "/2021/09/07/core-animation01.html" >Core Animation(一) - UIView与CALayer、布局与绘制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span><a class="archive-post-title" href= "/2021/09/05/AFN-Analyse.html" >[转] AFN框架实现解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/04</span><a class="archive-post-title" href= "/2021/09/04/nrl-session.html" >NSURLSession概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2021/09/02/Log.html" >移动端日志库设计</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href= "/2021/08/01/Crash-Monitor.html" >iOS崩溃监控与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2021/07/30/Lag-Monitor.html" >iOS卡顿监控与堆栈获取</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/SwiftUI.html" >SwiftUI</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/Swift-Version-History.html" >Swift版本更新API介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/26</span><a class="archive-post-title" href= "/2021/07/26/RunLoop-Reposted-From-ibireme.html" >[转] 深入理解RunLoop—ibireme</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2021/07/25/Protocol-Buffer.html" >Protocol Buffer的基本介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href= "/2021/07/24/base64.html" >Base64编码及iOS中的Base64</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span><a class="archive-post-title" href= "/2021/07/23/chinese-encode.html" >[转] 彻底弄懂常见的7种中文字符编码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/10</span><a class="archive-post-title" href= "/2021/07/10/p-npc-np.html" >P问题、NP问题、NPC、NP-Hard、P=NP?</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href= "/2021/06/30/probability.html" >(六) 概率算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/28</span><a class="archive-post-title" href= "/2021/06/28/branch-bound.html" >(五) 分支限界算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/26</span><a class="archive-post-title" href= "/2021/06/26/back-track.html" >(四) 回溯法(试探算法)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/24</span><a class="archive-post-title" href= "/2021/06/24/greed.html" >(三) 贪心算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/22</span><a class="archive-post-title" href= "/2021/06/22/dynamic-programming.html" >(二) 动态规划算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href= "/2021/06/20/divide-and-conquer.html" >(一) 分治算法及减治、变治算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span><a class="archive-post-title" href= "/2021/06/18/several-programming.html" >穷举、递推、迭代(辗转法)、递归算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/15</span><a class="archive-post-title" href= "/2021/06/15/datastruction-overview.html" >数据结构与算法概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/06</span><a class="archive-post-title" href= "/2021/06/06/Web-Module.html" >前端各种模块化方案总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Fiber.html" >[转] 最通俗的 React Fiber(时间分片)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Coroutine.html" >[转] 什么是协程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href= "/2021/05/19/DSL.html" >[转] 谈谈DSL以及DSL的应用（以CocoaPods 为例）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href= "/2021/05/03/iOS-private-pod.html" >私有Pod库部署</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/29</span><a class="archive-post-title" href= "/2021/04/29/iOS-ComRouter.html" >[转] iOS的组件化方案</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/27</span><a class="archive-post-title" href= "/2021/04/27/iOS-CI.html" >iOS的持续集成</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/26</span><a class="archive-post-title" href= "/2021/04/26/Containers.html" >常见的容器概念：Linux容器、Docker容器、服务器容器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span><a class="archive-post-title" href= "/2021/04/24/Dock-Reprinted-from-RuanYIFeng.html" >[转] Docker入门教程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span><a class="archive-post-title" href= "/2021/04/20/Sync-Async.html" >同步和异步解读及编程中的使用场景</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span><a class="archive-post-title" href= "/2021/04/17/Arm64-Handbook.html" >ARM64指令简易手册</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span><a class="archive-post-title" href= "/2021/04/16/Arm64-Introduce.html" >iOS需要了解的ARM64汇编</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span><a class="archive-post-title" href= "/2021/04/13/Command-Line.html" >CLI Shell、Terminal、脚本(语言)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href= "/2021/04/10/Ins-SysCall-Kernel-Shell.html" >指令、系统调用、库、Shell、APP的层次关系</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span><a class="archive-post-title" href= "/2021/04/08/ISA-Microarch-Soc.html" >指令集、微架构、手机芯片(Soc)及ARM的介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span><a class="archive-post-title" href= "/2021/04/02/Engineering.html" >工程化、动态化、容器化、组件化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2021/04/01/GithubPages-Hexo.html" >使用Hexo+Github Pages搭建个人博客</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/22</span><a class="archive-post-title" href= "/2020/12/22/aes.html" >数据加密 — 对称加密(以AES为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href= "/2020/12/21/aes-standard.html" >[转] AES标准及Rijndael算法解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span><a class="archive-post-title" href= "/2020/12/20/asymmetric.html" >数据加密 — 非对称加密(加签/加密，以RSA为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/09</span><a class="archive-post-title" href= "/2020/12/09/pki.html" >常见的PKI标准(X.509、PKCS)及证书相关介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href= "/2020/10/28/runtime-data-structure.html" >Objc Runtime总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2020/09/11/GCD.html" >Objective-C — 深入浅出GCD常用API</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/06</span><a class="archive-post-title" href= "/2020/09/06/oc-block.html" >Objective-C — Block</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/26</span><a class="archive-post-title" href= "/2020/08/26/AutoreleasePool.html" >AutoreleasePool</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/24</span><a class="archive-post-title" href= "/2020/08/24/oc-memory-manage.html" >Objective-C — 内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href= "/2020/08/01/ui-navigation-bar.html" >[转] 导航栏的架构介绍及使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/15</span><a class="archive-post-title" href= "/2020/07/15/symbol-decl.html" >变量声明、函数声明的作用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2020/07/01/ios-apns.html" >iOS APNS接收逻辑梳理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/2020/06/13/ios-vest.html" >iOS制作马甲总结</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="AutoreleasePool"><span class="iconfont-archer">&#xe606;</span>AutoreleasePool</span>
    
        <span class="sidebar-tag-name" data-tags="GCD"><span class="iconfont-archer">&#xe606;</span>GCD</span>
    
        <span class="sidebar-tag-name" data-tags="hexo"><span class="iconfont-archer">&#xe606;</span>hexo</span>
    
        <span class="sidebar-tag-name" data-tags="ISA"><span class="iconfont-archer">&#xe606;</span>ISA</span>
    
        <span class="sidebar-tag-name" data-tags="Microarch"><span class="iconfont-archer">&#xe606;</span>Microarch</span>
    
        <span class="sidebar-tag-name" data-tags="Soc"><span class="iconfont-archer">&#xe606;</span>Soc</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="Docker"><span class="iconfont-archer">&#xe606;</span>Docker</span>
    
        <span class="sidebar-tag-name" data-tags="CLI"><span class="iconfont-archer">&#xe606;</span>CLI</span>
    
        <span class="sidebar-tag-name" data-tags="Shell"><span class="iconfont-archer">&#xe606;</span>Shell</span>
    
        <span class="sidebar-tag-name" data-tags="ARM64"><span class="iconfont-archer">&#xe606;</span>ARM64</span>
    
        <span class="sidebar-tag-name" data-tags="协程"><span class="iconfont-archer">&#xe606;</span>协程</span>
    
        <span class="sidebar-tag-name" data-tags="DSL"><span class="iconfont-archer">&#xe606;</span>DSL</span>
    
        <span class="sidebar-tag-name" data-tags="Fiber"><span class="iconfont-archer">&#xe606;</span>Fiber</span>
    
        <span class="sidebar-tag-name" data-tags="dp"><span class="iconfont-archer">&#xe606;</span>dp</span>
    
        <span class="sidebar-tag-name" data-tags="RunLoop"><span class="iconfont-archer">&#xe606;</span>RunLoop</span>
    
        <span class="sidebar-tag-name" data-tags="SwiftUI"><span class="iconfont-archer">&#xe606;</span>SwiftUI</span>
    
        <span class="sidebar-tag-name" data-tags="Log"><span class="iconfont-archer">&#xe606;</span>Log</span>
    
        <span class="sidebar-tag-name" data-tags="Swift-Syntax"><span class="iconfont-archer">&#xe606;</span>Swift-Syntax</span>
    
        <span class="sidebar-tag-name" data-tags="CrashMonitor"><span class="iconfont-archer">&#xe606;</span>CrashMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="LagMonitor"><span class="iconfont-archer">&#xe606;</span>LagMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="AFN"><span class="iconfont-archer">&#xe606;</span>AFN</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Tenloy"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


