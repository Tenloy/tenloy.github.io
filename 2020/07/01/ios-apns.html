<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Tenloy">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Tenloy">
    
    <meta name="keywords" content="Tenloy,iOS,Swift">
    
    <meta name="description" content="学习 生活 记录 回忆">
    <meta name="description" content="一、设置 注册远程通知[[UIApplication sharedApplication] registerForRemoteNotifications]; 如果使用极光的话，[JPUSHService registerForRemoteNotificationConfig:entity delegate:self]; 包装实现了上述api的功能 注意：  registerForRemoteNot">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS APNS接收逻辑梳理">
<meta property="og:url" content="https://tenloy.github.io/2020/07/01/ios-apns.html">
<meta property="og:site_name" content="Tenloy&#39;s Blog">
<meta property="og:description" content="一、设置 注册远程通知[[UIApplication sharedApplication] registerForRemoteNotifications]; 如果使用极光的话，[JPUSHService registerForRemoteNotificationConfig:entity delegate:self]; 包装实现了上述api的功能 注意：  registerForRemoteNot">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://tenloy.github.io/images/ios/push.webp">
<meta property="og:image" content="https://tenloy.github.io/images/ios/app-extension.webp">
<meta property="og:image" content="https://tenloy.github.io/images/ios/app-extension2.webp">
<meta property="og:image" content="https://tenloy.github.io/images/ios/app-extension3.webp">
<meta property="og:image" content="https://tenloy.github.io/images/ios/app-extension4.webp">
<meta property="article:published_time" content="2020-07-01T03:30:00.000Z">
<meta property="article:modified_time" content="2024-05-05T07:05:27.000Z">
<meta property="article:author" content="Tenloy">
<meta property="article:tag" content="Tenloy, iOS, Tenloy Blog, 博客，Swift, 编译, 计算机">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://tenloy.github.io/images/ios/push.webp">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>iOS APNS接收逻辑梳理 · Tenloy&#39;s Blog</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
        <!-- algolia -->
        <script>
            
            var hits = JSON.parse('{"per_page":10}')
            var labels = JSON.parse('{"input_placeholder":"Search for Posts","hits_empty":"没有找到任何搜索结果: ${query}","hits_stats":"找到约${hits}条结果（用时${time}ms）"}')

            var algolia = {
                applicationID: 'V0HYXBS9FB',
                apiKey: '6550d5de786935564142097c3e78c380',
                indexName: 'law_blog_index',
                hits: hits,
                labels: labels
            }
        </script>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Tenloy's Blog" type="application/atom+xml">
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >Tenloy&#39;s Blog</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">iOS APNS接收逻辑梳理</a>
            </div>
    </div>
    
    <!-- 将home-link的操作改为应用到header-top-right上 -->
    <div class="header-top-right">
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-search">
                <span class="iconfont-jian tl-search-icon">&#xe7fc;搜索</span>
            </div>
            
        <a class="home-link" href=/>Tenloy's Blog</a>
    </div>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:40vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            iOS APNS接收逻辑梳理
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">4.9k</span>Reading time: <span class="post-count reading-time">18 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/07/01</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h2 id="一、设置-注册远程通知"><a href="#一、设置-注册远程通知" class="headerlink" title="一、设置 注册远程通知"></a>一、设置 注册远程通知</h2><p><code>[[UIApplication sharedApplication] registerForRemoteNotifications];</code></p>
<p>如果使用极光的话，<code>[JPUSHService registerForRemoteNotificationConfig:entity delegate:self]</code>; 包装实现了上述api的功能</p>
<p>注意：</p>
<ul>
<li><code>registerForRemoteNotifications</code>可以直接调用来注册远程推送，而不需要用户允许。也就是说只要调用该方法，就可以在AppDelegate的<code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code>中获取到设备的device token。</li>
<li>那么通常的弹窗询问权限有什么用呢？其实只是请求用户允许在推送通知到来时能够有alert, badge和sound，而并不是在请求注册推送本身的权限。</li>
<li><strong>用户不允许应用的推送，静默推送依然会送达用户设备</strong>，只是不会有alert, badge和sound。这也符合静默推送的正常使用场景。</li>
</ul>
<h2 id="二、处理-注册远程通知成功、失败回调"><a href="#二、处理-注册远程通知成功、失败回调" class="headerlink" title="二、处理 注册远程通知成功、失败回调"></a>二、处理 注册远程通知成功、失败回调</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> Typically, the system calls this method only after you call your WKExtension object’s registerForRemoteNotifications method, but WatchKit may call it under other rare circumstances. For example, WatchKit calls the method when the user launches an app after setting up the watch using a different device’s backup. In this case, the app doesn’t know the new device’s token until the user launches it.</span></span><br><span class="line"><span class="comment"> 如果这个方法不调用，那么APNS通知是收不到的，当然`应用内消息`可以照常使用</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didRegisterForRemoteNotificationsWithDeviceToken:(<span class="built_in">NSData</span> *)deviceToken API_AVAILABLE(ios(<span class="number">3.0</span>));</span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didFailToRegisterForRemoteNotificationsWithError:(<span class="built_in">NSError</span> *)error API_AVAILABLE(ios(<span class="number">3.0</span>));</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>有时候，会出现上面两个方法都不调用，导致推送接收不到。</strong>极光打印出<code>Not get deviceToken yet.</code> 可以从以下几个问题排查：</p>
<ul>
<li>推送证书 </li>
<li>是真机，且应用推送权限开启</li>
<li>确定调用了<code>registerForRemoteNotification</code>(不管是极光的还是原生的) </li>
<li>网络问题<ul>
<li>可以参考极光的文档：<a target="_blank" rel="noopener" href="https://docs.jiguang.cn/jpush/client/iOS/ios_faq/">SDK FAQ</a></li>
<li>我的解决方案：<strong>飞行模式开启-关闭</strong>，然后就好使了(更新：飞行模式、关机重启已经解决不了这个网络问题了，只能<strong>设置-还原网络设置</strong>了，好使了…)</li>
</ul>
</li>
</ul>
<img src="/images/ios/push.webp" alt="极光：JPush iOS 调试思维导图" style="zoom:80%;" />

<p><strong>极光在能正确获取到deviceToken但收不到推送的情况：</strong></p>
<p>我们是使用alias进行推送的，极光的逻辑是：</p>
<ul>
<li>JPush SDK 注册完成之后，生成一个RegistrationID(与deviceToken关联，是会变化的，每次变化生成一个新的时，极光后台统计数据，会计入一个用户新增)，然后设置别名的本质是将<code>alias与RegistrationID</code>关联起来。<a target="_blank" rel="noopener" href="https://community.jiguang.cn/article/111901">参考文档1</a>、<a target="_blank" rel="noopener" href="https://community.jiguang.cn/article/38100">参考文档2</a></li>
<li>一个alias下可以绑定多个RegistrationID，如果一个别名被指定到了多个用户，当给指定这个别名发消息时，服务器端 API 会同时给这多个用户发送消息。</li>
<li>如果我们为每台设备设置了唯一的一个别名(比如是idfa)，但是用极光的API却查出这个别名下对应了多个设备(即RegistrationID)，那么可能是在RegistrationID的有效期内没有调用<code>deleteAlias:</code>解除绑定(比如用户卸载，导致没机会解除)。极光提供了<a target="_blank" rel="noopener" href="https://docs.jiguang.cn/jpush/server/push/rest_api_v3_device/#_5">查询、删除接口</a>来操作alias与RegistrationID之间的关系</li>
<li><strong>极光于 2020/03/10 对「别名设置」的上限进行限制，最多允许绑定 10 个设备</strong>，如果超出了，设置别名会失败</li>
<li>如果RegistrationID变化之后，没有在该设备上再次调用<code>setAlias:</code>重新绑定alias与RegistrationID，就会导致通过alias找不到目前设备正确的RegistrationID，导致推送收不到</li>
<li><strong>综上所述，客户端与服务端之间使用RegistrationID标识，来推送，更为好用一点</strong></li>
</ul>
<h2 id="三、处理-设备接收到通知的回调"><a href="#三、处理-设备接收到通知的回调" class="headerlink" title="三、处理 设备接收到通知的回调"></a>三、处理 设备接收到通知的回调</h2><h3 id="3-1-iOS-10之前"><a href="#3-1-iOS-10之前" class="headerlink" title="3.1 iOS 10之前"></a>3.1 iOS 10之前</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法1: 兼容iOS 3 — iOS 10</span></span><br><span class="line"><span class="comment"> * 过期后，分别由方法4 5来代替处理`用户可见远程通知`，由方法3来代替处理`静默远程通知silent remote notifications`</span></span><br><span class="line"><span class="comment"> * If a remote notification arrives while your app is active, WatchKit calls this method to deliver the notification payload. 即只有当APP处于活跃状态时，收到远程通知，才会触发这个方法。</span></span><br><span class="line"><span class="comment"> * 活跃分为：前台、后台活跃，当处于前台时不显示通知alert，直接触发这个方法(iOS 10之后如果想在前台显示alert，需要实现方法4，iOS10之前，则需要自己发local notification来显示alert)。当处于后台活跃状态时，会显示，点击通知才会触发这个方法</span></span><br><span class="line"><span class="comment"> * 注意：如果实现了方法3，这个方法就不会被回调</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法2: 兼容iOS 4 — iOS 10</span></span><br><span class="line"><span class="comment"> * 过期后, 分别由方法4 5来代替处理本地通知</span></span><br><span class="line"><span class="comment"> * If a local notification arrives while your app is active, WatchKit calls this method to deliver the notification payload. 更详细的没测试</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法3: 兼容iOS 7及以后</span></span><br><span class="line"><span class="comment"> * Tells the delegate that a background notification has arrived. 即APP处于挂起、kill状态都会触发这个方法。触发 与alert显示情况与方法1相同：处于前台时，不alert，直接调用；挂起或kill状态，点击通知会触发</span></span><br><span class="line"><span class="comment"> * 实现此方法来处理传入的后台通知。当通知到达时，系统会启动您的应用程序或将其从挂起状态唤醒，您的应用程序会收到在后台运行的一小段时间。</span></span><br><span class="line"><span class="comment"> * 可以使用后台执行时间处理通知并下载其相关内容。一旦完成对通知的处理，就必须调用fetchCompletionHandler完成处理程序。您的应用程序有30秒的挂钟时间来处理通知并调用处理程序，时间到了系统会终止您的应用程序。请尽可能快地调用处理程序，因为系统会跟踪应用程序后台通知的运行时间、功耗和数据成本。</span></span><br><span class="line"><span class="comment"> * 后台通知是低优先级的，系统根据目标设备的功率考虑限制这些通知。APNs不保证设备会收到推送通知，而那些在处理后台通知时消耗大量能量或时间的应用程序可能不会收到后台时间来处理未来的通知。</span></span><br><span class="line"><span class="comment"> * 应用程序因为远程通知而启动或恢复，也将调用此方法。注意，此方法与方法1冲突，如果实现了此方法，则不会调用方法1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo fetchCompletionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">UIBackgroundFetchResult</span>))completionHandler;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-iOS-10及以后"><a href="#3-2-iOS-10及以后" class="headerlink" title="3.2 iOS 10及以后"></a>3.2 iOS 10及以后</h3><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法4: 兼容iOS 10及以后</span></span><br><span class="line"><span class="comment"> * 只有当应用程序位于前台时，才会在收到通知时调用该方法。如果方法没有实现，或者没有及时调用处理程序，则前台不会显示通知。应用程序可以选择以声音、徽章、警报和/或在通知列表中显示通知。取决于通知中的信息是否对用户可见</span></span><br><span class="line"><span class="comment"> * 实现了该方法后，方法1 3会收到影响，在前台时，不再是不显示+直接触发方法1 3，而是触发本方法，点击之后触发方法1 3</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(<span class="keyword">void</span> (^)(UNNotificationPresentationOptions options))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法5: 兼容iOS 10及以后</span></span><br><span class="line"><span class="comment"> * 当用户通过打开应用程序、取消通知或选择UNNotificationAction来响应通知时，会调用该方法。必须在应用程序从application:didFinishLaunchingWithOptions:返回之前设置delegate。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(<span class="keyword">void</span>(^)(<span class="keyword">void</span>))completionHandler;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法6: 兼容iOS 12及以后</span></span><br><span class="line"><span class="comment"> * 极光的解释：当从应用外部通知界面或通知设置界面进入应用时，该方法将回调。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">- (<span class="keyword">void</span>)userNotificationCenter:(UNUserNotificationCenter *)center openSettingsForNotification:(<span class="keyword">nullable</span> UNNotification *)notification;</span><br></pre></td></tr></table></figure>

<h2 id="四、测试接收到APNS时，API的调用"><a href="#四、测试接收到APNS时，API的调用" class="headerlink" title="四、测试接收到APNS时，API的调用"></a>四、测试接收到APNS时，API的调用</h2><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">实现方法<span class="number">1345</span></span><br><span class="line">  前台</span><br><span class="line">    显示+调用willPresent  点击调用didReceiveNotificationResponse</span><br><span class="line">  后台/非active状态</span><br><span class="line">    显示+谁都不调  点击调用didReceiveNotificationResponse</span><br><span class="line"></span><br><span class="line">实现方法<span class="number">135</span></span><br><span class="line">  前台</span><br><span class="line">    不显示+调用didReceiveRemoteNotification:fetchCompletionHandler</span><br><span class="line">  后台/非active状态</span><br><span class="line">    显示+谁都不调  点击调用didReceiveNotificationResponse</span><br><span class="line"></span><br><span class="line">实现方法<span class="number">134</span></span><br><span class="line">  前台</span><br><span class="line">    显示+调用willPresent  点击调用didReceiveRemoteNotification:fetchCompletionHandler</span><br><span class="line">  后台/非active状态</span><br><span class="line">    显示+谁都不调  点击调用didReceiveRemoteNotification:fetchCompletionHandler</span><br><span class="line"></span><br><span class="line">只实现方法<span class="number">1</span> <span class="number">3</span></span><br><span class="line">  前台</span><br><span class="line">    不显示+调用didReceiveRemoteNotification:fetchCompletionHandler</span><br><span class="line">  后台/非active状态</span><br><span class="line">    显示+谁都不调  点击调用didReceiveRemoteNotification:fetchCompletionHandler</span><br></pre></td></tr></table></figure>
<h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><ul>
<li>方法1 2是在iOS 10之前，用来接收<code>remote notification</code>、<code>local notification</code>的</li>
<li>方法3，是为了实现<code>Silent/Background Remote Notifications</code>而出的API，但在功能的设计上，直接囊括了方法1的功能(当APNS消息中<code>content-available = false</code>时，功能与方法1相同)，所以只要实现了方法3，方法1就不会再被调用。<ul>
<li>方法3比方法1功能更全面的一点是：方法1的方法是说明中，只有在active状态下，收到远程推送才调用。而方法3，在挂起、kill状态下，点击推送唤醒APP时，也会调用</li>
</ul>
</li>
<li>方法4 5是在iOS 10之后新出的框架<code>&lt;UserNotifications/UNUserNotificationCenter.h&gt;</code>用来取代之前的通知处理方式，并增加了很多新的特性，又将方法1的职责争取了过来，两者结合使用，使得方法123不再被调用(注意：在实现静默推送时，仍需用到方法3)</li>
<li>当收到静默通知时，会自动触发方法3(无论是前台、后台、挂起状态)。</li>
<li><code>&lt;UserNotifications.framework&gt;</code>库带来的特性：<ul>
<li>iOS 10之前，默认App在前台运行时不会进行弹窗，使得需要在方法3中，判断是前台状态，然后发送<code>local notification</code>。iOS 10之后，只需要实现方法4，调用<code>completionHandler(UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert);</code>即可</li>
<li><code>UNNotificationServiceExtension</code>，可以实现在通知展示之前拦截，自定义，实现通知上富文本、图片的展示。另外，附带着终于可以实现iOS的送达数据统计</li>
<li><code>getDeliveredNotificationsWithCompletionHandler</code> 可以获取通知中心已展示的通知</li>
<li>注意：在使用时，必须在<code>didFinishLaunchingWithOptions</code>返回之前设置代理：<code>[UNUserNotificationCenter currentNotificationCenter].delegate = self;</code></li>
</ul>
</li>
<li>此外，一些版本的关于通知的特性：<ul>
<li>iOS 8 <code>UIUserNotificationSettings</code>：修改了推送的注册接口，在原本的推送type的基础上，增加了一个<code>categories</code>参数，这个参数的目的是用来注册一组和通知关联起来的button的事件。</li>
<li>iOS 12，关于推送，又出了一些新特性：比如APP推送分组、消息左滑出现通知管理等</li>
<li>可以查看极光的汇总：<a target="_blank" rel="noopener" href="https://docs.jiguang.cn/jpush/client/iOS/ios_new_fetures/">https://docs.jiguang.cn/jpush/client/iOS/ios_new_fetures/</a></li>
</ul>
</li>
</ul>
<h2 id="六、静默推送"><a href="#六、静默推送" class="headerlink" title="六、静默推送"></a>六、静默推送</h2><p>静默推送(silent/background remote notification)</p>
<p>iOS 7在推送方面最大的变化就是允许，应用收到通知后在后台（background）状态下运行一段代码，可用于从服务器获取内容更新。功能使用场景：（多媒体）聊天，Email更新，基于通知的订阅内容同步等功能，提升了终端用户的体验。<strong>用户不允许应用的推送，静默推送依然会送达用户设备。</strong></p>
<p>如果只携带<code>content-available: 1</code>，不携带任何badge，sound 和消息内容等参数，<code>alert字段可以有，但value必须为空</code>，则可以不打扰用户的情况下进行内容更新等操作即为<code>“Silent/Background Remote Notifications”</code>，如果不携带此字段则是普通的<code>Remote Notification</code>。可以查看苹果文档<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app?language=objc">Pushing Background Updates to Your App</a></p>
<p>客户端设置：需要在Xcode 中修改应用的<code>Capabilities</code> ，在<strong>Background Modes里面勾选Remote notifications（推送唤醒）</strong></p>
<p>限制与注意：</p>
<ul>
<li>“Silent Remote Notifications”是在 Apple 的限制下有一定的频率控制，但具体频率不详。所以并不是所有的 “Silent Remote Notifications” 都能按照预期到达客户端触发函数。</li>
<li>“Background”下提供给应用的运行时间窗是有限制的，如果需要下载较大的文件请参考 Apple 的 NSURLSession 的介绍。</li>
<li>根据方法3的说明：系统会跟踪应用程序后台通知的运行时间、功耗和数据成本。<code>background remote notification</code>是低优先级的，系统根据目标设备的功率考虑限制这些通知。APNs不保证设备会收到推送通知，而那些在处理后台通知时消耗大量能量或时间的应用程序可能不会收到后台时间来处理未来的通知。</li>
<li>“Background Remote Notification” 的前提是要求客户端处于Background 或 Suspended 状态，如果用户通过 App Switcher 将应用从后台 Kill 掉应用将不会唤醒应用处理 background 代码。(<strong>这是极光文档中的说明，但是测试了一下，在前台收到也会触发方法3</strong>)</li>
<li>静默推送：收到推送（没有文字没有声音），不用点开通知，不用打开APP，就能执行<strong>方法3</strong>，用户完全感觉不到</li>
<li><strong>注意</strong>：使用极光的Web页面进行推送测试，在iOS 13以下，无论是前台、后台状态都会触发方法3。但在iOS 13的系统中，只会在前台收到静默推送才会触发方法3(记录于2020-03-30)。查阅了一些资料，可能是<code>apns-push-type: background </code>的问题(由于没有业务场景使用，并没有深究)。参考文档：<a target="_blank" rel="noopener" href="https://blog.csdn.net/lutuxuezhe/article/details/102377994">iOS13 静默推送填坑</a>、<a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/pushing_background_updates_to_your_app?language=objc">Apple Developer Document—Pushing Background Updates to Your App</a></li>
</ul>
<h2 id="七、融云推送消息的发送机制"><a href="#七、融云推送消息的发送机制" class="headerlink" title="七、融云推送消息的发送机制"></a>七、融云推送消息的发送机制</h2><p>APP内运行的时候，不走通知机制</p>
<p>退出APP两分钟之内(没有杀死)，状态栏上的是本地通知，走方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">        didReceiveLocalNotification:(<span class="built_in">UILocalNotification</span> *)notification </span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<p>退出APP超出两分钟，但是APP，没有被杀死、冻结的时候，状态栏上的是远程通知，走方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)application:(<span class="built_in">UIApplication</span> *)application</span><br><span class="line">        didReceiveRemoteNotification:(<span class="built_in">NSDictionary</span> *)userInfo       </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当APP被杀死，状态栏上的也算远程通知吧，走方法：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions</span><br><span class="line"><span class="comment">// 远程推送的内容</span></span><br><span class="line">   <span class="built_in">NSDictionary</span> *remoteNotificationUserInfo = launchOptions[<span class="built_in">UIApplicationLaunchOptionsRemoteNotificationKey</span>];</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="八、NotificationServiceExtension的集成与调试"><a href="#八、NotificationServiceExtension的集成与调试" class="headerlink" title="八、NotificationServiceExtension的集成与调试"></a>八、NotificationServiceExtension的集成与调试</h2><p><code>NotificationServiceExtension</code>属于<code>AppExtension</code>（扩展）的范畴，属于官方推出的扩展。同<code>NotificationContentExtension</code>一同丰富用户的推送体验，让开发者可以本地拦截和修改推送内容的机会，可以自定义自己的推送内容展示样式。大大提高了整体的用户体验。</p>
<ul>
<li>只允许修改推送内容，不能包含任何的UI显示。</li>
<li>开发者无法自己初始化，在推送到达的时候iOS系统会自动创建<code>UNNotificationServiceExtension</code>对象。开发者只能通过扩展Target下的<code>NotificationServiceExtension</code>的子类来修改自己App推送的内容。</li>
<li>iOS收到App的推送的时候，系统自动初始化<code>UNNotificationServiceExtension</code>对象，然后回调给App的扩展子类的方法<code>didReceiveNotificationRequest:withContentHandler:</code>。</li>
<li>响应函数的操作时间只有30秒；如果未处理超时处理，系统会按照默认显示推送。</li>
<li>服务端推送的payload格式要求：必须是alert类型。<ul>
<li><code>aps</code>字段必须包含有<code>alert</code>字段，<code>alert</code>里必须是<code>title、subtitle、body</code>任何一个。</li>
<li><code>aps</code>字段必须包含有<code>mutable-content</code>字段，其值必须为1。</li>
</ul>
</li>
</ul>
<p>调试：（网上说的几种方式）</p>
<ul>
<li>方式1：(<em>不生效</em>)<ul>
<li>主工程编译，真机运行；</li>
<li>扩展Target编译运行，选择主工程App，Attachment连接启动。</li>
<li>模拟推送一波，<code>UNNotificationServiceExtension</code>的扩展之类，断点即可执行。</li>
</ul>
</li>
<li>方式2：(<em>代码编译报错</em>)<ul>
<li>直接运行扩展的Target，会弹窗让你<code>Choose an app to run</code>，选择主工程APP运行</li>
</ul>
</li>
<li>方式3：<a target="_blank" rel="noopener" href="https://blog.ficowshen.com/page/post/78">如何用 Xcode 来调试 App Extension？</a>（<em>NICE！</em>）</li>
</ul>
<p>不同的 App Extension 有不同的使用场景，这个启用了 App Extension 的场景（系统区域）叫做扩展点（extension point）。（App Extension 只会在其所属的扩展点被启动，所以如果要调试 App Extension，我们要先确定 App Extension 的扩展点。）</p>
<p><code>Notification Service Extension</code> 的扩展点就是 <strong>在系统收到远程推送后至系统展示推送内容之前</strong>。我们需要确保该 Extension 的进程在这个场景被正常启动，随后我们才可以对其进行调试（在 Xcode 中为该 Extension 设置的断点才会被击中）。</p>
<ul>
<li>如果 App Extension 已经在运行，您可以通过 Xcode 的菜单 <code>Debug</code> - <code>Attach to Process</code> 浏览并查找该进程。</li>
<li>不过，对于类似 <code>Notification Service Extension</code> 这种会在某个时期启动，然后自动停止的进程：<ul>
<li>一种方式：您可能需要在发送了远程推送后，尽快去 <code>Attach to Process</code> 列表寻找相关的进程。如果进程在被启动后很快又被终结了，导致您无法在列表中发现该进程，您也可以尝试让该进程睡眠一段时间，比如：<code>sleep(10)</code>。</li>
<li>另一种方式：如果您已经知道进程的 ID 或者名称，您可以直接进行查找： <code>Debug</code> - <code>Attach to Process by PID or Name</code> (对于推送扩展进程，这里是指 UNNotificationServiceExtension 的实现 Target 名称)。<ul>
<li>如果该进程未运行，调试器会一直等待。The debugger will wait for processes that aren’t running.</li>
<li>如果报错，那么很可能是没有找对进程，建议先确认输入的名称或者 PID 是否正确。如果进程名存在重名情况，您就需要自行检查 Xcode 应该连接的是哪一个进程，通过PID来选定。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="九、补充：AppExtension"><a href="#九、补充：AppExtension" class="headerlink" title="九、补充：AppExtension"></a>九、补充：AppExtension</h2><h3 id="9-1-概述"><a href="#9-1-概述" class="headerlink" title="9.1 概述"></a>9.1 概述</h3><p>三个概念：</p>
<ul>
<li>App Extension，Apple定义为”扩展“，也可以理解为”插件“。</li>
<li>Host App，能够调起extension的app被称为host app。例如，如果创建的是share extension，host app可能是Safari浏览器；如果创建的是widget extension，host app可能是系统的Today app。</li>
<li>Containing App，包含一个或者多个的Extension的App叫做ContainingApp，也叫做宿主App。</li>
</ul>
<p>扩展不是独立App，系统将其初始化为单独的进程。</p>
<p>基于安全和性能的考虑，每一个扩展运行在一个单独的进程中，它拥有自己的<code>bundle</code>， <code>bundle</code>后缀名是<code>.appex</code>。</p>
<p>iOS系统把扩展定义为 额外功能的触发入口点，它不是一个独立的App。因此，它必须依赖于宿主App，不能单独存在，也就没办法单独提审AppStore。</p>
<h3 id="9-2-生命周期-Life-Cycle"><a href="#9-2-生命周期-Life-Cycle" class="headerlink" title="9.2 生命周期(Life Cycle)"></a>9.2 生命周期(Life Cycle)</h3><ol>
<li>用户触发“扩展”，如UI触发或者代码触发。</li>
<li>iOS系统自动唤起“扩展”。</li>
<li>执行“扩展”代码。</li>
<li>执行完成后，系统杀死“扩展”，回收资源。</li>
</ol>
<img src="/images/ios/app-extension.webp" alt="app-extension" style="zoom:80%;" />

<h3 id="9-3-扩展与宿主APP的通信"><a href="#9-3-扩展与宿主APP的通信" class="headerlink" title="9.3 扩展与宿主APP的通信"></a>9.3 扩展与宿主APP的通信</h3><ul>
<li><p>Host App 与 ContainingApp 无法直接通信！</p>
</li>
<li><p>扩展与Host App的通信是基于<code>request/response</code>模型。</p>
<ul>
<li><code>request/response</code>是通过 ”上下文“ 机制实现。HostApp为”扩展“提供运行的<code>上下文(an extension context)</code>。大致流程是，HostApp将 <code>RequestData</code> 通过<code>上下文(an extension context)</code> 输送给 扩展AppExtension，扩展进行处理（UI显示，用户交互，代码处理等），处理完成后将 <code>ResponseData</code> 返回给HostApp。</li>
<li>由于”扩展“是一个独立的进程，一般一个App也是一个独立进程，因此它们间通信应该是基于进程间的通信方式。例如Socket、管道、XPC等，官方好像未明确说明。<ul>
<li>疑似XPC。现象：扩展Target的源文件info.plist文件中，有个key CFBundlePackageType，有些扩展中值为<code>$(PRODUCT_BUNDLE_PACKAGE_TYPE)</code>，有的直接显示为<code>XPC!</code>（表示这个 bundle 是一个 XPC Service）</li>
</ul>
</li>
</ul>
<img src="/images/ios/app-extension2.webp" alt="app-extension2" style="zoom:68%;" /></li>
<li><p>一般，扩展与ContainingApp是无法直接通信的，例如扩展允许的时候，宿主App可能还未运行。受限的通信：</p>
<img src="/images/ios/app-extension3.webp" alt="app-extension3" style="zoom:68%;" />

<ul>
<li><code>A Today widget</code> 可以通过UrlSchemes的方式唤起ContainingApp。通过<code>NSExtensionContext</code>的方法<code>openURL:completionHandler:</code>。</li>
<li>扩展和ContainingApp可以通过<code>shared container</code>实现间接、双向通信。<ul>
<li>虽然AppExtension的Bundle被导入如ContainingApp的包内，但是彼此的沙盒是没办法访问的。Apple发明了<code>share container</code>的中间层，来实现彼此的数据共享问题。也被称之为<code>AppGroup</code>的概念。</li>
<li>这也映射软件工程的一句经典话语：多了个中间层，一切都显得那么美好。</li>
<li>基本原理如下：Apple允许 <strong>App进程</strong> 和 <strong>扩展进程</strong> 都可以对<code>SharedContainer</code>的共享数据区进行操作。</li>
</ul>
</li>
</ul>
</li>
</ul>
  <img src="/images/ios/app-extension4.webp" alt="app-extension3" style="zoom:68%;" />


    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="https://tenloy.github.io">Tenloy</a>
            <p>原文链接：<a href="https://tenloy.github.io/2020/07/01/ios-apns.html">https://tenloy.github.io/2020/07/01/ios-apns.html</a>
            <p>发表日期：2020.07.01 , 11:30 AM</p>
            <p>更新日期：2024.05.05 , 3:05 PM</p>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">Crative Commons 4.0 许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2020/07/15/symbol-decl.html" title= "变量声明、函数声明的作用">
                    <div class="nextTitle">变量声明、函数声明的作用</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2020/06/13/ios-vest.html" title= "iOS制作马甲总结">
                    <div class="prevTitle">iOS制作马甲总结</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:luotengoto@163.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="//github.com/Tenloy" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <a href="https://www.jianshu.com/u/8db1bc12db9f" class="iconfont-jian jianshu" target="_blank" title=jianshu></a>
            
        
    
        
            
                <a href="/atom.xml" class="iconfont-archer rss" target="_blank" title=rss></a>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:40vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E8%AE%BE%E7%BD%AE-%E6%B3%A8%E5%86%8C%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5"><span class="toc-text">一、设置 注册远程通知</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E5%A4%84%E7%90%86-%E6%B3%A8%E5%86%8C%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5%E6%88%90%E5%8A%9F%E3%80%81%E5%A4%B1%E8%B4%A5%E5%9B%9E%E8%B0%83"><span class="toc-text">二、处理 注册远程通知成功、失败回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E5%A4%84%E7%90%86-%E8%AE%BE%E5%A4%87%E6%8E%A5%E6%94%B6%E5%88%B0%E9%80%9A%E7%9F%A5%E7%9A%84%E5%9B%9E%E8%B0%83"><span class="toc-text">三、处理 设备接收到通知的回调</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-iOS-10%E4%B9%8B%E5%89%8D"><span class="toc-text">3.1 iOS 10之前</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-iOS-10%E5%8F%8A%E4%BB%A5%E5%90%8E"><span class="toc-text">3.2 iOS 10及以后</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%B5%8B%E8%AF%95%E6%8E%A5%E6%94%B6%E5%88%B0APNS%E6%97%B6%EF%BC%8CAPI%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-text">四、测试接收到APNS时，API的调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E6%80%BB%E7%BB%93"><span class="toc-text">五、总结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E9%9D%99%E9%BB%98%E6%8E%A8%E9%80%81"><span class="toc-text">六、静默推送</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E8%9E%8D%E4%BA%91%E6%8E%A8%E9%80%81%E6%B6%88%E6%81%AF%E7%9A%84%E5%8F%91%E9%80%81%E6%9C%BA%E5%88%B6"><span class="toc-text">七、融云推送消息的发送机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81NotificationServiceExtension%E7%9A%84%E9%9B%86%E6%88%90%E4%B8%8E%E8%B0%83%E8%AF%95"><span class="toc-text">八、NotificationServiceExtension的集成与调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E8%A1%A5%E5%85%85%EF%BC%9AAppExtension"><span class="toc-text">九、补充：AppExtension</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">9.1 概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F-Life-Cycle"><span class="toc-text">9.2 生命周期(Life Cycle)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-%E6%89%A9%E5%B1%95%E4%B8%8E%E5%AE%BF%E4%B8%BBAPP%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-text">9.3 扩展与宿主APP的通信</span></a></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    
    
    
    
        <span class="sidebar-category-name" data-categories="数据结构与算法"><span class="iconfont-archer">&#xe60a;</span>数据结构与算法</span>
    
        <span class="sidebar-category-name" data-categories="计算机组成原理"><span class="iconfont-archer">&#xe60a;</span>计算机组成原理</span>
    
        <span class="sidebar-category-name" data-categories="计算机网络"><span class="iconfont-archer">&#xe60a;</span>计算机网络</span>
    
        <span class="sidebar-category-name" data-categories="汇编语言"><span class="iconfont-archer">&#xe60a;</span>汇编语言</span>
    
        <span class="sidebar-category-name" data-categories="数据的存储与传输"><span class="iconfont-archer">&#xe60a;</span>数据的存储与传输</span>
    
        <span class="sidebar-category-name" data-categories="操作系统"><span class="iconfont-archer">&#xe60a;</span>操作系统</span>
    
        <span class="sidebar-category-name" data-categories="互联网标准RFC"><span class="iconfont-archer">&#xe60a;</span>互联网标准RFC</span>
    
        <span class="sidebar-category-name" data-categories="编译链接与装载"><span class="iconfont-archer">&#xe60a;</span>编译链接与装载</span>
    
        <span class="sidebar-category-name" data-categories="iOS"><span class="iconfont-archer">&#xe60a;</span>iOS</span>
    
        <span class="sidebar-category-name" data-categories="架构与设计模式"><span class="iconfont-archer">&#xe60a;</span>架构与设计模式</span>
    
        <span class="sidebar-category-name" data-categories="图形处理与渲染"><span class="iconfont-archer">&#xe60a;</span>图形处理与渲染</span>
    
        <span class="sidebar-category-name" data-categories="软件工程"><span class="iconfont-archer">&#xe60a;</span>软件工程</span>
    
        <span class="sidebar-category-name" data-categories="音视频处理"><span class="iconfont-archer">&#xe60a;</span>音视频处理</span>
    
        <span class="sidebar-category-name" data-categories="DSL"><span class="iconfont-archer">&#xe60a;</span>DSL</span>
    
        <span class="sidebar-category-name" data-categories="Swift"><span class="iconfont-archer">&#xe60a;</span>Swift</span>
    
        <span class="sidebar-category-name" data-categories="Git"><span class="iconfont-archer">&#xe60a;</span>Git</span>
    
        <span class="sidebar-category-name" data-categories="Web"><span class="iconfont-archer">&#xe60a;</span>Web</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 75
        </div>
        <!-- search  -->
        
            <div class="site-search popup-trigger tl-side-search"> 
                <span class="iconfont-jian search-icon">&#xe7fc;搜索</span>
            </div>
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2022 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/05</span><a class="archive-post-title" href= "/2022/05/05/sqlite.html" >iOS SQLite的使用与优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/28</span><a class="archive-post-title" href= "/2022/04/28/mmap.html" >内存映射mmap函数的原理与应用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/18</span><a class="archive-post-title" href= "/2022/03/18/avfoundation.html" >AVFoundation Programming Guide(译)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/17</span><a class="archive-post-title" href= "/2022/03/17/avframework.html" >iOS音视频库概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2022/02/09/OAuth.html" >[转] OAuth 2.0简述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/18</span><a class="archive-post-title" href= "/2022/01/18/wkwebview-buges.html" >WKWebView使用过程中遇到的坑</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/22</span><a class="archive-post-title" href= "/2021/11/22/bit-calculation.html" >[转] 位运算实现加、减、乘、除运算</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/10</span><a class="archive-post-title" href= "/2021/11/10/git-use.html" >Git的使用总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/21</span><a class="archive-post-title" href= "/2021/10/21/dyld-objc.html" >(六) dyld与Runtime—_objc_init、map_images、load_images</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/18</span><a class="archive-post-title" href= "/2021/10/18/compile-dynamic-link.html" >(五) Mach-O 文件的动态链接、库、Dyld(含dlopen)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/10</span><a class="archive-post-title" href= "/2021/10/10/compile-load.html" >(四) Mach-O 文件的装载、ASLR及符号地址</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/08</span><a class="archive-post-title" href= "/2021/10/08/compile-static-link.html" >(三) Mach-O 文件的静态链接</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/06</span><a class="archive-post-title" href= "/2021/10/06/compile-macho.html" >(二) Mach-O 文件结构</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/05</span><a class="archive-post-title" href= "/2021/10/05/compile-clang-llvm.html" >(一) Clang/LLVM 介绍、OC 程序的编译过程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/02</span><a class="archive-post-title" href= "/2021/10/02/makefile.html" >[转] Make 命令的使用与NodeJS案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/2021/09/28/architectural-pattern.html" >常见架构模式: MVC、MVP、MVVM、VIPER</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/25</span><a class="archive-post-title" href= "/2021/09/25/design-pattern.html" >常见的设计模式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/20</span><a class="archive-post-title" href= "/2021/09/20/program-thought.html" >常见的编程范式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing-case.html" >图形处理(三) - 图形处理实践案例</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/15</span><a class="archive-post-title" href= "/2021/09/15/graphics-processing.html" >图形处理(二) - 图形与视频处理相关的框架</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/13</span><a class="archive-post-title" href= "/2021/09/13/image-encode-decode.html" >图形处理(一) - 图片的加载与编解码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/12</span><a class="archive-post-title" href= "/2021/09/12/iOS-Render.html" >[转] iOS离屏渲染原理及优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2021/09/11/core-animation03.html" >Core-Animation(三) - 渲染流程探究及性能分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/09</span><a class="archive-post-title" href= "/2021/09/09/core-animation02.html" >Core Animation(二) - 隐式动画、CATransaction与CAAction</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/07</span><a class="archive-post-title" href= "/2021/09/07/core-animation01.html" >Core Animation(一) - UIView与CALayer、布局与绘制</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/05</span><a class="archive-post-title" href= "/2021/09/05/AFN-Analyse.html" >[转] AFN框架实现解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/04</span><a class="archive-post-title" href= "/2021/09/04/nrl-session.html" >NSURLSession概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/02</span><a class="archive-post-title" href= "/2021/09/02/Log.html" >移动端日志库设计</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href= "/2021/08/01/Crash-Monitor.html" >iOS崩溃监控与分析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/30</span><a class="archive-post-title" href= "/2021/07/30/Lag-Monitor.html" >iOS卡顿监控与堆栈获取</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/SwiftUI.html" >SwiftUI</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/29</span><a class="archive-post-title" href= "/2021/07/29/Swift-Version-History.html" >Swift版本更新API介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/26</span><a class="archive-post-title" href= "/2021/07/26/RunLoop-Reposted-From-ibireme.html" >[转] 深入理解RunLoop—ibireme</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/25</span><a class="archive-post-title" href= "/2021/07/25/Protocol-Buffer.html" >Protocol Buffer的基本介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/24</span><a class="archive-post-title" href= "/2021/07/24/base64.html" >Base64编码及iOS中的Base64</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/23</span><a class="archive-post-title" href= "/2021/07/23/chinese-encode.html" >[转] 彻底弄懂常见的7种中文字符编码</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/10</span><a class="archive-post-title" href= "/2021/07/10/p-npc-np.html" >P问题、NP问题、NPC、NP-Hard、P=NP?</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/30</span><a class="archive-post-title" href= "/2021/06/30/probability.html" >(六) 概率算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/28</span><a class="archive-post-title" href= "/2021/06/28/branch-bound.html" >(五) 分支限界算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/26</span><a class="archive-post-title" href= "/2021/06/26/back-track.html" >(四) 回溯法(试探算法)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/24</span><a class="archive-post-title" href= "/2021/06/24/greed.html" >(三) 贪心算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/22</span><a class="archive-post-title" href= "/2021/06/22/dynamic-programming.html" >(二) 动态规划算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/20</span><a class="archive-post-title" href= "/2021/06/20/divide-and-conquer.html" >(一) 分治算法及减治、变治算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/18</span><a class="archive-post-title" href= "/2021/06/18/several-programming.html" >穷举、递推、迭代(辗转法)、递归算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/15</span><a class="archive-post-title" href= "/2021/06/15/datastruction-overview.html" >数据结构与算法概述</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/06</span><a class="archive-post-title" href= "/2021/06/06/Web-Module.html" >前端各种模块化方案总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Fiber.html" >[转] 最通俗的 React Fiber(时间分片)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/27</span><a class="archive-post-title" href= "/2021/05/27/Coroutine.html" >[转] 什么是协程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/19</span><a class="archive-post-title" href= "/2021/05/19/DSL.html" >[转] 谈谈DSL以及DSL的应用（以CocoaPods 为例）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">05/03</span><a class="archive-post-title" href= "/2021/05/03/iOS-private-pod.html" >私有Pod库部署</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/29</span><a class="archive-post-title" href= "/2021/04/29/iOS-ComRouter.html" >[转] iOS的组件化方案</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/27</span><a class="archive-post-title" href= "/2021/04/27/iOS-CI.html" >iOS的持续集成</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/26</span><a class="archive-post-title" href= "/2021/04/26/Containers.html" >常见的容器概念：Linux容器、Docker容器、服务器容器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/24</span><a class="archive-post-title" href= "/2021/04/24/Dock-Reprinted-from-RuanYIFeng.html" >[转] Docker入门教程</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/20</span><a class="archive-post-title" href= "/2021/04/20/Sync-Async.html" >同步和异步解读及编程中的使用场景</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/17</span><a class="archive-post-title" href= "/2021/04/17/Arm64-Handbook.html" >ARM64指令简易手册</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/16</span><a class="archive-post-title" href= "/2021/04/16/Arm64-Introduce.html" >iOS需要了解的ARM64汇编</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/13</span><a class="archive-post-title" href= "/2021/04/13/Command-Line.html" >CLI Shell、Terminal、脚本(语言)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/10</span><a class="archive-post-title" href= "/2021/04/10/Ins-SysCall-Kernel-Shell.html" >指令、系统调用、库、Shell、APP的层次关系</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/08</span><a class="archive-post-title" href= "/2021/04/08/ISA-Microarch-Soc.html" >指令集、微架构、手机芯片(Soc)及ARM的介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/02</span><a class="archive-post-title" href= "/2021/04/02/Engineering.html" >工程化、动态化、容器化、组件化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">04/01</span><a class="archive-post-title" href= "/2021/04/01/GithubPages-Hexo.html" >使用Hexo+Github Pages搭建个人博客</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/22</span><a class="archive-post-title" href= "/2020/12/22/aes.html" >数据加密 — 对称加密(以AES为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/21</span><a class="archive-post-title" href= "/2020/12/21/aes-standard.html" >[转] AES标准及Rijndael算法解析</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span><a class="archive-post-title" href= "/2020/12/20/asymmetric.html" >数据加密 — 非对称加密(加签/加密，以RSA为例)</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/09</span><a class="archive-post-title" href= "/2020/12/09/pki.html" >常见的PKI标准(X.509、PKCS)及证书相关介绍</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/28</span><a class="archive-post-title" href= "/2020/10/28/runtime-data-structure.html" >Objc Runtime总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/11</span><a class="archive-post-title" href= "/2020/09/11/GCD.html" >Objective-C — 深入浅出GCD常用API</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/06</span><a class="archive-post-title" href= "/2020/09/06/oc-block.html" >Objective-C — Block</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/26</span><a class="archive-post-title" href= "/2020/08/26/AutoreleasePool.html" >AutoreleasePool</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/24</span><a class="archive-post-title" href= "/2020/08/24/oc-memory-manage.html" >Objective-C — 内存管理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">08/01</span><a class="archive-post-title" href= "/2020/08/01/ui-navigation-bar.html" >[转] 导航栏的架构介绍及使用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/15</span><a class="archive-post-title" href= "/2020/07/15/symbol-decl.html" >变量声明、函数声明的作用</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">07/01</span><a class="archive-post-title" href= "/2020/07/01/ios-apns.html" >iOS APNS接收逻辑梳理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/2020/06/13/ios-vest.html" >iOS制作马甲总结</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="AutoreleasePool"><span class="iconfont-archer">&#xe606;</span>AutoreleasePool</span>
    
        <span class="sidebar-tag-name" data-tags="hexo"><span class="iconfont-archer">&#xe606;</span>hexo</span>
    
        <span class="sidebar-tag-name" data-tags="GCD"><span class="iconfont-archer">&#xe606;</span>GCD</span>
    
        <span class="sidebar-tag-name" data-tags="ISA"><span class="iconfont-archer">&#xe606;</span>ISA</span>
    
        <span class="sidebar-tag-name" data-tags="Microarch"><span class="iconfont-archer">&#xe606;</span>Microarch</span>
    
        <span class="sidebar-tag-name" data-tags="Soc"><span class="iconfont-archer">&#xe606;</span>Soc</span>
    
        <span class="sidebar-tag-name" data-tags="CLI"><span class="iconfont-archer">&#xe606;</span>CLI</span>
    
        <span class="sidebar-tag-name" data-tags="Shell"><span class="iconfont-archer">&#xe606;</span>Shell</span>
    
        <span class="sidebar-tag-name" data-tags="ARM64"><span class="iconfont-archer">&#xe606;</span>ARM64</span>
    
        <span class="sidebar-tag-name" data-tags="多线程"><span class="iconfont-archer">&#xe606;</span>多线程</span>
    
        <span class="sidebar-tag-name" data-tags="Docker"><span class="iconfont-archer">&#xe606;</span>Docker</span>
    
        <span class="sidebar-tag-name" data-tags="DSL"><span class="iconfont-archer">&#xe606;</span>DSL</span>
    
        <span class="sidebar-tag-name" data-tags="协程"><span class="iconfont-archer">&#xe606;</span>协程</span>
    
        <span class="sidebar-tag-name" data-tags="Fiber"><span class="iconfont-archer">&#xe606;</span>Fiber</span>
    
        <span class="sidebar-tag-name" data-tags="dp"><span class="iconfont-archer">&#xe606;</span>dp</span>
    
        <span class="sidebar-tag-name" data-tags="RunLoop"><span class="iconfont-archer">&#xe606;</span>RunLoop</span>
    
        <span class="sidebar-tag-name" data-tags="SwiftUI"><span class="iconfont-archer">&#xe606;</span>SwiftUI</span>
    
        <span class="sidebar-tag-name" data-tags="CrashMonitor"><span class="iconfont-archer">&#xe606;</span>CrashMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="Swift-Syntax"><span class="iconfont-archer">&#xe606;</span>Swift-Syntax</span>
    
        <span class="sidebar-tag-name" data-tags="Log"><span class="iconfont-archer">&#xe606;</span>Log</span>
    
        <span class="sidebar-tag-name" data-tags="LagMonitor"><span class="iconfont-archer">&#xe606;</span>LagMonitor</span>
    
        <span class="sidebar-tag-name" data-tags="AFN"><span class="iconfont-archer">&#xe606;</span>AFN</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Tenloy"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
        <div class="site-search">
  <div class="algolia-popup popup">
    <div class="algolia-search">
      <div class="algolia-search-input-icon">
        <i class="fa fa-search"></i>
      </div>
      <div class="algolia-search-input" id="algolia-search-input"></div>
    </div>

    <div class="algolia-results">
      <div id="algolia-stats"></div>
      <div id="algolia-hits"></div>
      <div id="algolia-pagination" class="algolia-pagination"></div>
    </div>

    <span class="popup-btn-close">
      <i class="iconfont-archer">&#xe609;</i>
    </span>
  </div>
</div>
        <script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.8.0/dist/instantsearch.min.js" defer></script>
        <script src="/scripts/search.js" defer></script>
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


